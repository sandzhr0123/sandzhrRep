/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _vue = __webpack_require__(2);

	var _vue2 = _interopRequireDefault(_vue);

	var _App = __webpack_require__(3);

	var _App2 = _interopRequireDefault(_App);

	var _router = __webpack_require__(22);

	var _router2 = _interopRequireDefault(_router);

	var _index = __webpack_require__(242);

	var _index2 = _interopRequireDefault(_index);

	var _IO = __webpack_require__(141);

	var _IO2 = _interopRequireDefault(_IO);

	var _cookie = __webpack_require__(167);

	var _cookie2 = _interopRequireDefault(_cookie);

	var _vueTouch = __webpack_require__(250);

	var _vueTouch2 = _interopRequireDefault(_vueTouch);

	var _sticky = __webpack_require__(252);

	var _sticky2 = _interopRequireDefault(_sticky);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_vue2.default.config.debug = true;

	window.log = console.log;

	_vue2.default.prototype.ajax = _IO2.default.ajax;

	_vue2.default.prototype.cookie = _cookie2.default;

	Object.defineProperty(_vue2.default.prototype, '$sticky', {
	    value: _sticky2.default
	});

	_vue2.default.use(_vueTouch2.default, { name: 'v-touch' });

	var data = {
	    router: _router2.default,
	    store: _index2.default,
	    render: function render(h) {
	        return h(_App2.default);
	    }
	};

	var app = new _vue2.default(data).$mount('#app');

	_router2.default.beforeEach(function (to, from, next) {
	    if (to.meta.requireAuth) {
	        //!isEmptyObject(store.state.user)
	        if (_cookie2.default.get('token')) {
	            next();
	        }
	        //如果没有，跳到登录页面
	        else {
	                next({
	                    path: '/login',
	                    query: { redirect: to.fullPath } });
	            }
	    } else {
	        next();
	    }
	});

	function isEmptyObject(obj) {
	    for (var key in obj) {
	        return false;
	    }
	    return true;
	}

/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * Vue.js v2.2.6
	 * (c) 2014-2017 Evan You
	 * Released under the MIT License.
	 */
	!function(e,t){ true?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Vue=t()}(this,function(){"use strict";function e(e){return null==e?"":"object"==typeof e?JSON.stringify(e,null,2):String(e)}function t(e){var t=parseFloat(e);return isNaN(t)?e:t}function n(e,t){for(var n=Object.create(null),r=e.split(","),i=0;i<r.length;i++)n[r[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}function r(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}function i(e,t){return $i.call(e,t)}function o(e){return"string"==typeof e||"number"==typeof e}function a(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}function s(e,t){function n(n){var r=arguments.length;return r?r>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n}function c(e,t){t=t||0;for(var n=e.length-t,r=new Array(n);n--;)r[n]=e[n+t];return r}function u(e,t){for(var n in t)e[n]=t[n];return e}function l(e){return null!==e&&"object"==typeof e}function f(e){return ki.call(e)===Ai}function p(e){for(var t={},n=0;n<e.length;n++)e[n]&&u(t,e[n]);return t}function d(){}function v(e,t){var n=l(e),r=l(t);if(!n||!r)return!n&&!r&&String(e)===String(t);try{return JSON.stringify(e)===JSON.stringify(t)}catch(n){return e===t}}function h(e,t){for(var n=0;n<e.length;n++)if(v(e[n],t))return n;return-1}function m(e){var t=!1;return function(){t||(t=!0,e())}}function g(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function y(e,t,n,r){Object.defineProperty(e,t,{value:n,enumerable:!!r,writable:!0,configurable:!0})}function _(e){if(!ji.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}function b(e){return/native code/.test(e.toString())}function $(e){qi.target&&Wi.push(qi.target),qi.target=e}function w(){qi.target=Wi.pop()}function x(e,t){e.__proto__=t}function C(e,t,n){for(var r=0,i=n.length;r<i;r++){var o=n[r];y(e,o,t[o])}}function k(e,t){if(l(e)){var n;return i(e,"__ob__")&&e.__ob__ instanceof Xi?n=e.__ob__:Qi.shouldConvert&&!Ui()&&(Array.isArray(e)||f(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new Xi(e)),t&&n&&n.vmCount++,n}}function A(e,t,n,r){var i=new qi,o=Object.getOwnPropertyDescriptor(e,t);if(!o||o.configurable!==!1){var a=o&&o.get,s=o&&o.set,c=k(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=a?a.call(e):n;return qi.target&&(i.depend(),c&&c.dep.depend(),Array.isArray(t)&&S(t)),t},set:function(t){var r=a?a.call(e):n;t===r||t!==t&&r!==r||(s?s.call(e,t):n=t,c=k(t),i.notify())}})}}function O(e,t,n){if(Array.isArray(e)&&"number"==typeof t)return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(i(e,t))return e[t]=n,n;var r=e.__ob__;return e._isVue||r&&r.vmCount?n:r?(A(r.value,t,n),r.dep.notify(),n):(e[t]=n,n)}function T(e,t){if(Array.isArray(e)&&"number"==typeof t)return void e.splice(t,1);var n=e.__ob__;e._isVue||n&&n.vmCount||i(e,t)&&(delete e[t],n&&n.dep.notify())}function S(e){for(var t=void 0,n=0,r=e.length;n<r;n++)t=e[n],t&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&S(t)}function E(e,t){if(!t)return e;for(var n,r,o,a=Object.keys(t),s=0;s<a.length;s++)n=a[s],r=e[n],o=t[n],i(e,n)?f(r)&&f(o)&&E(r,o):O(e,n,o);return e}function j(e,t){return t?e?e.concat(t):Array.isArray(t)?t:[t]:e}function N(e,t){var n=Object.create(e||null);return t?u(n,t):n}function I(e){var t=e.props;if(t){var n,r,i,o={};if(Array.isArray(t))for(n=t.length;n--;)"string"==typeof(r=t[n])&&(i=wi(r),o[i]={type:null});else if(f(t))for(var a in t)r=t[a],i=wi(a),o[i]=f(r)?r:{type:r};e.props=o}}function L(e){var t=e.directives;if(t)for(var n in t){var r=t[n];"function"==typeof r&&(t[n]={bind:r,update:r})}}function D(e,t,n){function r(r){var i=eo[r]||to;l[r]=i(e[r],t[r],n,r)}I(t),L(t);var o=t.extends;if(o&&(e="function"==typeof o?D(e,o.options,n):D(e,o,n)),t.mixins)for(var a=0,s=t.mixins.length;a<s;a++){var c=t.mixins[a];c.prototype instanceof nt&&(c=c.options),e=D(e,c,n)}var u,l={};for(u in e)r(u);for(u in t)i(e,u)||r(u);return l}function M(e,t,n,r){if("string"==typeof n){var o=e[t];if(i(o,n))return o[n];var a=wi(n);if(i(o,a))return o[a];var s=xi(a);if(i(o,s))return o[s];var c=o[n]||o[a]||o[s];return c}}function P(e,t,n,r){var o=t[e],a=!i(n,e),s=n[e];if(H(Boolean,o.type)&&(a&&!i(o,"default")?s=!1:H(String,o.type)||""!==s&&s!==Ci(e)||(s=!0)),void 0===s){s=R(r,o,e);var c=Qi.shouldConvert;Qi.shouldConvert=!0,k(s),Qi.shouldConvert=c}return s}function R(e,t,n){if(i(t,"default")){var r=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:"function"==typeof r&&"Function"!==F(t.type)?r.call(e):r}}function F(e){var t=e&&e.toString().match(/^\s*function (\w+)/);return t&&t[1]}function H(e,t){if(!Array.isArray(t))return F(t)===F(e);for(var n=0,r=t.length;n<r;n++)if(F(t[n])===F(e))return!0;return!1}function U(e,t,n){if(Si.errorHandler)Si.errorHandler.call(null,e,t,n);else{if(!Ii||"undefined"==typeof console)throw e;console.error(e)}}function B(e){return new no(void 0,void 0,void 0,String(e))}function V(e){var t=new no(e.tag,e.data,e.children,e.text,e.elm,e.context,e.componentOptions);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isCloned=!0,t}function z(e){for(var t=e.length,n=new Array(t),r=0;r<t;r++)n[r]=V(e[r]);return n}function J(e){function t(){var e=arguments,n=t.fns;if(!Array.isArray(n))return n.apply(null,arguments);for(var r=0;r<n.length;r++)n[r].apply(null,e)}return t.fns=e,t}function K(e,t,n,r,i){var o,a,s,c;for(o in e)a=e[o],s=t[o],c=ao(o),a&&(s?a!==s&&(s.fns=a,e[o]=s):(a.fns||(a=e[o]=J(a)),n(c.name,a,c.once,c.capture)));for(o in t)e[o]||(c=ao(o),r(c.name,t[o],c.capture))}function q(e,t,n){function i(){n.apply(this,arguments),r(o.fns,i)}var o,a=e[t];a?a.fns&&a.merged?(o=a,o.fns.push(i)):o=J([a,i]):o=J([i]),o.merged=!0,e[t]=o}function W(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}function Z(e){return o(e)?[B(e)]:Array.isArray(e)?G(e):void 0}function G(e,t){var n,r,i,a=[];for(n=0;n<e.length;n++)null!=(r=e[n])&&"boolean"!=typeof r&&(i=a[a.length-1],Array.isArray(r)?a.push.apply(a,G(r,(t||"")+"_"+n)):o(r)?i&&i.text?i.text+=String(r):""!==r&&a.push(B(r)):r.text&&i&&i.text?a[a.length-1]=B(i.text+r.text):(r.tag&&null==r.key&&null!=t&&(r.key="__vlist"+t+"_"+n+"__"),a.push(r)));return a}function Y(e){return e&&e.filter(function(e){return e&&e.componentOptions})[0]}function Q(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&te(e,t)}function X(e,t,n){n?io.$once(e,t):io.$on(e,t)}function ee(e,t){io.$off(e,t)}function te(e,t,n){io=e,K(t,n||{},X,ee,e)}function ne(e,t){var n={};if(!e)return n;for(var r,i,o=[],a=0,s=e.length;a<s;a++)if(i=e[a],(i.context===t||i.functionalContext===t)&&i.data&&(r=i.data.slot)){var c=n[r]||(n[r]=[]);"template"===i.tag?c.push.apply(c,i.children):c.push(i)}else o.push(i);return o.every(re)||(n.default=o),n}function re(e){return e.isComment||" "===e.text}function ie(e){for(var t={},n=0;n<e.length;n++)t[e[n][0]]=e[n][1];return t}function oe(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}function ae(e,t,n){e.$el=t,e.$options.render||(e.$options.render=oo),fe(e,"beforeMount");var r;return r=function(){e._update(e._render(),n)},e._watcher=new ho(e,r,d),n=!1,null==e.$vnode&&(e._isMounted=!0,fe(e,"mounted")),e}function se(e,t,n,r,i){var o=!!(i||e.$options._renderChildren||r.data.scopedSlots||e.$scopedSlots!==Ei);if(e.$options._parentVnode=r,e.$vnode=r,e._vnode&&(e._vnode.parent=r),e.$options._renderChildren=i,t&&e.$options.props){Qi.shouldConvert=!1;for(var a=e._props,s=e.$options._propKeys||[],c=0;c<s.length;c++){var u=s[c];a[u]=P(u,e.$options.props,t,e)}Qi.shouldConvert=!0,e.$options.propsData=t}if(n){var l=e.$options._parentListeners;e.$options._parentListeners=n,te(e,n,l)}o&&(e.$slots=ne(i,r.context),e.$forceUpdate())}function ce(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function ue(e,t){if(t){if(e._directInactive=!1,ce(e))return}else if(e._directInactive)return;if(e._inactive||null==e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)ue(e.$children[n]);fe(e,"activated")}}function le(e,t){if(!(t&&(e._directInactive=!0,ce(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)le(e.$children[n]);fe(e,"deactivated")}}function fe(e,t){var n=e.$options[t];if(n)for(var r=0,i=n.length;r<i;r++)try{n[r].call(e)}catch(n){U(n,e,t+" hook")}e._hasHookEvent&&e.$emit("hook:"+t)}function pe(){co.length=0,uo={},lo=fo=!1}function de(){fo=!0;var e,t,n;for(co.sort(function(e,t){return e.id-t.id}),po=0;po<co.length;po++)e=co[po],t=e.id,uo[t]=null,e.run();var r=co.slice();for(pe(),po=r.length;po--;)e=r[po],n=e.vm,n._watcher===e&&n._isMounted&&fe(n,"updated");Bi&&Si.devtools&&Bi.emit("flush")}function ve(e){var t=e.id;if(null==uo[t]){if(uo[t]=!0,fo){for(var n=co.length-1;n>=0&&co[n].id>e.id;)n--;co.splice(Math.max(n,po)+1,0,e)}else co.push(e);lo||(lo=!0,zi(de))}}function he(e){mo.clear(),me(e,mo)}function me(e,t){var n,r,i=Array.isArray(e);if((i||l(e))&&Object.isExtensible(e)){if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(i)for(n=e.length;n--;)me(e[n],t);else for(r=Object.keys(e),n=r.length;n--;)me(e[r[n]],t)}}function ge(e,t,n){go.get=function(){return this[t][n]},go.set=function(e){this[t][n]=e},Object.defineProperty(e,n,go)}function ye(e){e._watchers=[];var t=e.$options;t.props&&_e(e,t.props),t.methods&&ke(e,t.methods),t.data?be(e):k(e._data={},!0),t.computed&&we(e,t.computed),t.watch&&Ae(e,t.watch)}function _e(e,t){var n=e.$options.propsData||{},r=e._props={},i=e.$options._propKeys=[],o=!e.$parent;Qi.shouldConvert=o;for(var a in t)!function(o){i.push(o);var a=P(o,t,n,e);A(r,o,a),o in e||ge(e,"_props",o)}(a);Qi.shouldConvert=!0}function be(e){var t=e.$options.data;t=e._data="function"==typeof t?$e(t,e):t||{},f(t)||(t={});for(var n=Object.keys(t),r=e.$options.props,o=n.length;o--;)r&&i(r,n[o])||g(n[o])||ge(e,"_data",n[o]);k(t,!0)}function $e(e,t){try{return e.call(t)}catch(e){return U(e,t,"data()"),{}}}function we(e,t){var n=e._computedWatchers=Object.create(null);for(var r in t){var i=t[r],o="function"==typeof i?i:i.get;n[r]=new ho(e,o,d,yo),r in e||xe(e,r,i)}}function xe(e,t,n){"function"==typeof n?(go.get=Ce(t),go.set=d):(go.get=n.get?n.cache!==!1?Ce(t):n.get:d,go.set=n.set?n.set:d),Object.defineProperty(e,t,go)}function Ce(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),qi.target&&t.depend(),t.value}}function ke(e,t){e.$options.props;for(var n in t)e[n]=null==t[n]?d:s(t[n],e)}function Ae(e,t){for(var n in t){var r=t[n];if(Array.isArray(r))for(var i=0;i<r.length;i++)Oe(e,n,r[i]);else Oe(e,n,r)}}function Oe(e,t,n){var r;f(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,r)}function Te(e,t,n,r,i){if(e){var o=n.$options._base;if(l(e)&&(e=o.extend(e)),"function"==typeof e){if(!e.cid)if(e.resolved)e=e.resolved;else if(!(e=je(e,o,function(){n.$forceUpdate()})))return;Xe(e),t=t||{},t.model&&Me(e.options,t);var a=Ne(t,e,i);if(e.options.functional)return Se(e,a,t,n,r);var s=t.on;t.on=t.nativeOn,e.options.abstract&&(t={}),Le(t);var c=e.options.name||i;return new no("vue-component-"+e.cid+(c?"-"+c:""),t,void 0,void 0,void 0,n,{Ctor:e,propsData:a,listeners:s,tag:i,children:r})}}}function Se(e,t,n,r,i){var o={},a=e.options.props;if(a)for(var s in a)o[s]=P(s,a,t);var c=Object.create(r),u=function(e,t,n,r){return Pe(c,e,t,n,r,!0)},l=e.options.render.call(null,u,{props:o,data:n,parent:r,children:i,slots:function(){return ne(i,r)}});return l instanceof no&&(l.functionalContext=r,n.slot&&((l.data||(l.data={})).slot=n.slot)),l}function Ee(e,t,n,r){var i=e.componentOptions,o={_isComponent:!0,parent:t,propsData:i.propsData,_componentTag:i.tag,_parentVnode:e,_parentListeners:i.listeners,_renderChildren:i.children,_parentElm:n||null,_refElm:r||null},a=e.data.inlineTemplate;return a&&(o.render=a.render,o.staticRenderFns=a.staticRenderFns),new i.Ctor(o)}function je(e,t,n){if(!e.requested){e.requested=!0;var r=e.pendingCallbacks=[n],i=!0,o=function(n){if(l(n)&&(n=t.extend(n)),e.resolved=n,!i)for(var o=0,a=r.length;o<a;o++)r[o](n)},a=function(e){},s=e(o,a);return s&&"function"==typeof s.then&&!e.resolved&&s.then(o,a),i=!1,e.resolved}e.pendingCallbacks.push(n)}function Ne(e,t,n){var r=t.options.props;if(r){var i={},o=e.attrs,a=e.props,s=e.domProps;if(o||a||s)for(var c in r){var u=Ci(c);Ie(i,a,c,u,!0)||Ie(i,o,c,u)||Ie(i,s,c,u)}return i}}function Ie(e,t,n,r,o){if(t){if(i(t,n))return e[n]=t[n],o||delete t[n],!0;if(i(t,r))return e[n]=t[r],o||delete t[r],!0}return!1}function Le(e){e.hook||(e.hook={});for(var t=0;t<bo.length;t++){var n=bo[t],r=e.hook[n],i=_o[n];e.hook[n]=r?De(i,r):i}}function De(e,t){return function(n,r,i,o){e(n,r,i,o),t(n,r,i,o)}}function Me(e,t){var n=e.model&&e.model.prop||"value",r=e.model&&e.model.event||"input";(t.props||(t.props={}))[n]=t.model.value;var i=t.on||(t.on={});i[r]?i[r]=[t.model.callback].concat(i[r]):i[r]=t.model.callback}function Pe(e,t,n,r,i,a){return(Array.isArray(n)||o(n))&&(i=r,r=n,n=void 0),a&&(i=wo),Re(e,t,n,r,i)}function Re(e,t,n,r,i){if(n&&n.__ob__)return oo();if(!t)return oo();Array.isArray(r)&&"function"==typeof r[0]&&(n=n||{},n.scopedSlots={default:r[0]},r.length=0),i===wo?r=Z(r):i===$o&&(r=W(r));var o,a;if("string"==typeof t){var s;a=Si.getTagNamespace(t),o=Si.isReservedTag(t)?new no(Si.parsePlatformTagName(t),n,r,void 0,void 0,e):(s=M(e.$options,"components",t))?Te(s,n,e,r,t):new no(t,n,r,void 0,void 0,e)}else o=Te(t,n,e,r);return o?(a&&Fe(o,a),o):oo()}function Fe(e,t){if(e.ns=t,"foreignObject"!==e.tag&&e.children)for(var n=0,r=e.children.length;n<r;n++){var i=e.children[n];i.tag&&!i.ns&&Fe(i,t)}}function He(e,t){var n,r,i,o,a;if(Array.isArray(e)||"string"==typeof e)for(n=new Array(e.length),r=0,i=e.length;r<i;r++)n[r]=t(e[r],r);else if("number"==typeof e)for(n=new Array(e),r=0;r<e;r++)n[r]=t(r+1,r);else if(l(e))for(o=Object.keys(e),n=new Array(o.length),r=0,i=o.length;r<i;r++)a=o[r],n[r]=t(e[a],a,r);return n}function Ue(e,t,n,r){var i=this.$scopedSlots[e];if(i)return n=n||{},r&&u(n,r),i(n)||t;var o=this.$slots[e];return o||t}function Be(e){return M(this.$options,"filters",e,!0)||Ti}function Ve(e,t,n){var r=Si.keyCodes[t]||n;return Array.isArray(r)?r.indexOf(e)===-1:r!==e}function ze(e,t,n,r){if(n)if(l(n)){Array.isArray(n)&&(n=p(n));var i;for(var o in n){if("class"===o||"style"===o)i=e;else{var a=e.attrs&&e.attrs.type;i=r||Si.mustUseProp(t,a,o)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}o in i||(i[o]=n[o])}}else;return e}function Je(e,t){var n=this._staticTrees[e];return n&&!t?Array.isArray(n)?z(n):V(n):(n=this._staticTrees[e]=this.$options.staticRenderFns[e].call(this._renderProxy),qe(n,"__static__"+e,!1),n)}function Ke(e,t,n){return qe(e,"__once__"+t+(n?"_"+n:""),!0),e}function qe(e,t,n){if(Array.isArray(e))for(var r=0;r<e.length;r++)e[r]&&"string"!=typeof e[r]&&We(e[r],t+"_"+r,n);else We(e,t,n)}function We(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function Ze(e){e.$vnode=null,e._vnode=null,e._staticTrees=null;var t=e.$options._parentVnode,n=t&&t.context;e.$slots=ne(e.$options._renderChildren,n),e.$scopedSlots=Ei,e._c=function(t,n,r,i){return Pe(e,t,n,r,i,!1)},e.$createElement=function(t,n,r,i){return Pe(e,t,n,r,i,!0)}}function Ge(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}function Ye(e){var t=e.$options.inject;if(t)for(var n=Array.isArray(t),r=n?t:Vi?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++)!function(i){for(var o=r[i],a=n?o:t[o],s=e;s;){if(s._provided&&a in s._provided){A(e,o,s._provided[a]);break}s=s.$parent}}(i)}function Qe(e,t){var n=e.$options=Object.create(e.constructor.options);n.parent=t.parent,n.propsData=t.propsData,n._parentVnode=t._parentVnode,n._parentListeners=t._parentListeners,n._renderChildren=t._renderChildren,n._componentTag=t._componentTag,n._parentElm=t._parentElm,n._refElm=t._refElm,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}function Xe(e){var t=e.options;if(e.super){var n=Xe(e.super);if(n!==e.superOptions){e.superOptions=n;var r=et(e);r&&u(e.extendOptions,r),t=e.options=D(n,e.extendOptions),t.name&&(t.components[t.name]=e)}}return t}function et(e){var t,n=e.options,r=e.sealedOptions;for(var i in n)n[i]!==r[i]&&(t||(t={}),t[i]=tt(n[i],r[i]));return t}function tt(e,t){if(Array.isArray(e)){var n=[];t=Array.isArray(t)?t:[t];for(var r=0;r<e.length;r++)t.indexOf(e[r])<0&&n.push(e[r]);return n}return e}function nt(e){this._init(e)}function rt(e){e.use=function(e){if(!e.installed){var t=c(arguments,1);return t.unshift(this),"function"==typeof e.install?e.install.apply(e,t):"function"==typeof e&&e.apply(null,t),e.installed=!0,this}}}function it(e){e.mixin=function(e){this.options=D(this.options,e)}}function ot(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,r=n.cid,i=e._Ctor||(e._Ctor={});if(i[r])return i[r];var o=e.name||n.options.name,a=function(e){this._init(e)};return a.prototype=Object.create(n.prototype),a.prototype.constructor=a,a.cid=t++,a.options=D(n.options,e),a.super=n,a.options.props&&at(a),a.options.computed&&st(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,Si._assetTypes.forEach(function(e){a[e]=n[e]}),o&&(a.options.components[o]=a),a.superOptions=n.options,a.extendOptions=e,a.sealedOptions=u({},a.options),i[r]=a,a}}function at(e){var t=e.options.props;for(var n in t)ge(e.prototype,"_props",n)}function st(e){var t=e.options.computed;for(var n in t)xe(e.prototype,n,t[n])}function ct(e){Si._assetTypes.forEach(function(t){e[t]=function(e,n){return n?("component"===t&&f(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}})}function ut(e){return e&&(e.Ctor.options.name||e.tag)}function lt(e,t){return"string"==typeof e?e.split(",").indexOf(t)>-1:e instanceof RegExp&&e.test(t)}function ft(e,t){for(var n in e){var r=e[n];if(r){var i=ut(r.componentOptions);i&&!t(i)&&(pt(r),e[n]=null)}}}function pt(e){e&&(e.componentInstance._inactive||fe(e.componentInstance,"deactivated"),e.componentInstance.$destroy())}function dt(e){for(var t=e.data,n=e,r=e;r.componentInstance;)r=r.componentInstance._vnode,r.data&&(t=vt(r.data,t));for(;n=n.parent;)n.data&&(t=vt(t,n.data));return ht(t)}function vt(e,t){return{staticClass:mt(e.staticClass,t.staticClass),class:e.class?[e.class,t.class]:t.class}}function ht(e){var t=e.class,n=e.staticClass;return n||t?mt(n,gt(t)):""}function mt(e,t){return e?t?e+" "+t:e:t||""}function gt(e){var t="";if(!e)return t;if("string"==typeof e)return e;if(Array.isArray(e)){for(var n,r=0,i=e.length;r<i;r++)e[r]&&(n=gt(e[r]))&&(t+=n+" ");return t.slice(0,-1)}if(l(e)){for(var o in e)e[o]&&(t+=o+" ");return t.slice(0,-1)}return t}function yt(e){return Ko(e)?"svg":"math"===e?"math":void 0}function _t(e){if(!Ii)return!0;if(Wo(e))return!1;if(e=e.toLowerCase(),null!=Zo[e])return Zo[e];var t=document.createElement(e);return e.indexOf("-")>-1?Zo[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Zo[e]=/HTMLUnknownElement/.test(t.toString())}function bt(e){if("string"==typeof e){var t=document.querySelector(e);return t?t:document.createElement("div")}return e}function $t(e,t){var n=document.createElement(e);return"select"!==e?n:(t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n)}function wt(e,t){return document.createElementNS(zo[e],t)}function xt(e){return document.createTextNode(e)}function Ct(e){return document.createComment(e)}function kt(e,t,n){e.insertBefore(t,n)}function At(e,t){e.removeChild(t)}function Ot(e,t){e.appendChild(t)}function Tt(e){return e.parentNode}function St(e){return e.nextSibling}function Et(e){return e.tagName}function jt(e,t){e.textContent=t}function Nt(e,t,n){e.setAttribute(t,n)}function It(e,t){var n=e.data.ref;if(n){var i=e.context,o=e.componentInstance||e.elm,a=i.$refs;t?Array.isArray(a[n])?r(a[n],o):a[n]===o&&(a[n]=void 0):e.data.refInFor?Array.isArray(a[n])&&a[n].indexOf(o)<0?a[n].push(o):a[n]=[o]:a[n]=o}}function Lt(e){return void 0===e||null===e}function Dt(e){return void 0!==e&&null!==e}function Mt(e){return e===!0}function Pt(e,t){return e.key===t.key&&e.tag===t.tag&&e.isComment===t.isComment&&Dt(e.data)===Dt(t.data)&&Rt(e,t)}function Rt(e,t){if("input"!==e.tag)return!0;var n;return(Dt(n=e.data)&&Dt(n=n.attrs)&&n.type)===(Dt(n=t.data)&&Dt(n=n.attrs)&&n.type)}function Ft(e,t,n){var r,i,o={};for(r=t;r<=n;++r)i=e[r].key,Dt(i)&&(o[i]=r);return o}function Ht(e,t){(e.data.directives||t.data.directives)&&Ut(e,t)}function Ut(e,t){var n,r,i,o=e===Qo,a=t===Qo,s=Bt(e.data.directives,e.context),c=Bt(t.data.directives,t.context),u=[],l=[];for(n in c)r=s[n],i=c[n],r?(i.oldValue=r.value,zt(i,"update",t,e),i.def&&i.def.componentUpdated&&l.push(i)):(zt(i,"bind",t,e),i.def&&i.def.inserted&&u.push(i));if(u.length){var f=function(){for(var n=0;n<u.length;n++)zt(u[n],"inserted",t,e)};o?q(t.data.hook||(t.data.hook={}),"insert",f):f()}if(l.length&&q(t.data.hook||(t.data.hook={}),"postpatch",function(){for(var n=0;n<l.length;n++)zt(l[n],"componentUpdated",t,e)}),!o)for(n in s)c[n]||zt(s[n],"unbind",e,e,a)}function Bt(e,t){var n=Object.create(null);if(!e)return n;var r,i;for(r=0;r<e.length;r++)i=e[r],i.modifiers||(i.modifiers=ta),n[Vt(i)]=i,i.def=M(t.$options,"directives",i.name,!0);return n}function Vt(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function zt(e,t,n,r,i){var o=e.def&&e.def[t];o&&o(n.elm,e,n,r,i)}function Jt(e,t){if(e.data.attrs||t.data.attrs){var n,r,i=t.elm,o=e.data.attrs||{},a=t.data.attrs||{};a.__ob__&&(a=t.data.attrs=u({},a));for(n in a)r=a[n],o[n]!==r&&Kt(i,n,r);Mi&&a.value!==o.value&&Kt(i,"value",a.value);for(n in o)null==a[n]&&(Uo(n)?i.removeAttributeNS(Ho,Bo(n)):Ro(n)||i.removeAttribute(n))}}function Kt(e,t,n){Fo(t)?Vo(n)?e.removeAttribute(t):e.setAttribute(t,t):Ro(t)?e.setAttribute(t,Vo(n)||"false"===n?"false":"true"):Uo(t)?Vo(n)?e.removeAttributeNS(Ho,Bo(t)):e.setAttributeNS(Ho,t,n):Vo(n)?e.removeAttribute(t):e.setAttribute(t,n)}function qt(e,t){var n=t.elm,r=t.data,i=e.data;if(r.staticClass||r.class||i&&(i.staticClass||i.class)){var o=dt(t),a=n._transitionClasses;a&&(o=mt(o,gt(a))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}function Wt(e){function t(){(a||(a=[])).push(e.slice(v,i).trim()),v=i+1}var n,r,i,o,a,s=!1,c=!1,u=!1,l=!1,f=0,p=0,d=0,v=0;for(i=0;i<e.length;i++)if(r=n,n=e.charCodeAt(i),s)39===n&&92!==r&&(s=!1);else if(c)34===n&&92!==r&&(c=!1);else if(u)96===n&&92!==r&&(u=!1);else if(l)47===n&&92!==r&&(l=!1);else if(124!==n||124===e.charCodeAt(i+1)||124===e.charCodeAt(i-1)||f||p||d){switch(n){case 34:c=!0;break;case 39:s=!0;break;case 96:u=!0;break;case 40:d++;break;case 41:d--;break;case 91:p++;break;case 93:p--;break;case 123:f++;break;case 125:f--}if(47===n){for(var h=i-1,m=void 0;h>=0&&" "===(m=e.charAt(h));h--);m&&oa.test(m)||(l=!0)}}else void 0===o?(v=i+1,o=e.slice(0,i).trim()):t();if(void 0===o?o=e.slice(0,i).trim():0!==v&&t(),a)for(i=0;i<a.length;i++)o=Zt(o,a[i]);return o}function Zt(e,t){var n=t.indexOf("(");return n<0?'_f("'+t+'")('+e+")":'_f("'+t.slice(0,n)+'")('+e+","+t.slice(n+1)}function Gt(e){console.error("[Vue compiler]: "+e)}function Yt(e,t){return e?e.map(function(e){return e[t]}).filter(function(e){return e}):[]}function Qt(e,t,n){(e.props||(e.props=[])).push({name:t,value:n})}function Xt(e,t,n){(e.attrs||(e.attrs=[])).push({name:t,value:n})}function en(e,t,n,r,i,o){(e.directives||(e.directives=[])).push({name:t,rawName:n,value:r,arg:i,modifiers:o})}function tn(e,t,n,r,i){r&&r.capture&&(delete r.capture,t="!"+t),r&&r.once&&(delete r.once,t="~"+t);var o;r&&r.native?(delete r.native,o=e.nativeEvents||(e.nativeEvents={})):o=e.events||(e.events={});var a={value:n,modifiers:r},s=o[t];Array.isArray(s)?i?s.unshift(a):s.push(a):o[t]=s?i?[a,s]:[s,a]:a}function nn(e,t,n){var r=rn(e,":"+t)||rn(e,"v-bind:"+t);if(null!=r)return Wt(r);if(n!==!1){var i=rn(e,t);if(null!=i)return JSON.stringify(i)}}function rn(e,t){var n;if(null!=(n=e.attrsMap[t]))for(var r=e.attrsList,i=0,o=r.length;i<o;i++)if(r[i].name===t){r.splice(i,1);break}return n}function on(e,t,n){var r=n||{},i=r.number,o=r.trim,a="$$v";o&&(a="(typeof $$v === 'string'? $$v.trim(): $$v)"),i&&(a="_n("+a+")");var s=an(t,a);e.model={value:"("+t+")",expression:'"'+t+'"',callback:"function ($$v) {"+s+"}"}}function an(e,t){var n=sn(e);return null===n.idx?e+"="+t:"var $$exp = "+n.exp+", $$idx = "+n.idx+";if (!Array.isArray($$exp)){"+e+"="+t+"}else{$$exp.splice($$idx, 1, "+t+")}"}function sn(e){if(To=e,Oo=To.length,Eo=jo=No=0,e.indexOf("[")<0||e.lastIndexOf("]")<Oo-1)return{exp:e,idx:null};for(;!un();)So=cn(),ln(So)?pn(So):91===So&&fn(So);return{exp:e.substring(0,jo),idx:e.substring(jo+1,No)}}function cn(){return To.charCodeAt(++Eo)}function un(){return Eo>=Oo}function ln(e){return 34===e||39===e}function fn(e){var t=1;for(jo=Eo;!un();)if(e=cn(),ln(e))pn(e);else if(91===e&&t++,93===e&&t--,0===t){No=Eo;break}}function pn(e){for(var t=e;!un()&&(e=cn())!==t;);}function dn(e,t,n){Io=n;var r=t.value,i=t.modifiers,o=e.tag,a=e.attrsMap.type;if("select"===o)mn(e,r,i);else if("input"===o&&"checkbox"===a)vn(e,r,i);else if("input"===o&&"radio"===a)hn(e,r,i);else if("input"===o||"textarea"===o)gn(e,r,i);else if(!Si.isReservedTag(o))return on(e,r,i),!1;return!0}function vn(e,t,n){var r=n&&n.number,i=nn(e,"value")||"null",o=nn(e,"true-value")||"true",a=nn(e,"false-value")||"false";Qt(e,"checked","Array.isArray("+t+")?_i("+t+","+i+")>-1"+("true"===o?":("+t+")":":_q("+t+","+o+")")),tn(e,sa,"var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+o+"):("+a+");if(Array.isArray($$a)){var $$v="+(r?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$c){$$i<0&&("+t+"=$$a.concat($$v))}else{$$i>-1&&("+t+"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{"+t+"=$$c}",null,!0)}function hn(e,t,n){var r=n&&n.number,i=nn(e,"value")||"null";i=r?"_n("+i+")":i,Qt(e,"checked","_q("+t+","+i+")"),tn(e,sa,an(t,i),null,!0)}function mn(e,t,n){var r=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(r?"_n(val)":"val")+"})",o="var $$selectedVal = "+i+";";o=o+" "+an(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),tn(e,"change",o,null,!0)}function gn(e,t,n){var r=e.attrsMap.type,i=n||{},o=i.lazy,a=i.number,s=i.trim,c=!o&&"range"!==r,u=o?"change":"range"===r?aa:"input",l="$event.target.value";s&&(l="$event.target.value.trim()"),a&&(l="_n("+l+")");var f=an(t,l);c&&(f="if($event.target.composing)return;"+f),Qt(e,"value","("+t+")"),tn(e,u,f,null,!0),(s||a||"number"===r)&&tn(e,"blur","$forceUpdate()")}function yn(e){var t;e[aa]&&(t=Di?"change":"input",e[t]=[].concat(e[aa],e[t]||[]),delete e[aa]),e[sa]&&(t=Hi?"click":"change",e[t]=[].concat(e[sa],e[t]||[]),delete e[sa])}function _n(e,t,n,r){if(n){var i=t,o=Lo;t=function(n){null!==(1===arguments.length?i(n):i.apply(null,arguments))&&bn(e,t,r,o)}}Lo.addEventListener(e,t,r)}function bn(e,t,n,r){(r||Lo).removeEventListener(e,t,n)}function $n(e,t){if(e.data.on||t.data.on){var n=t.data.on||{},r=e.data.on||{};Lo=t.elm,yn(n),K(n,r,_n,bn,t.context)}}function wn(e,t){if(e.data.domProps||t.data.domProps){var n,r,i=t.elm,o=e.data.domProps||{},a=t.data.domProps||{};a.__ob__&&(a=t.data.domProps=u({},a));for(n in o)null==a[n]&&(i[n]="");for(n in a)if(r=a[n],"textContent"!==n&&"innerHTML"!==n||(t.children&&(t.children.length=0),r!==o[n]))if("value"===n){i._value=r;var s=null==r?"":String(r);xn(i,t,s)&&(i.value=s)}else i[n]=r}}function xn(e,t,n){return!e.composing&&("option"===t.tag||Cn(e,n)||kn(e,n))}function Cn(e,t){return document.activeElement!==e&&e.value!==t}function kn(e,n){var r=e.value,i=e._vModifiers;return i&&i.number||"number"===e.type?t(r)!==t(n):i&&i.trim?r.trim()!==n.trim():r!==n}function An(e){var t=On(e.style);return e.staticStyle?u(e.staticStyle,t):t}function On(e){return Array.isArray(e)?p(e):"string"==typeof e?la(e):e}function Tn(e,t){var n,r={};if(t)for(var i=e;i.componentInstance;)i=i.componentInstance._vnode,i.data&&(n=An(i.data))&&u(r,n);(n=An(e.data))&&u(r,n);for(var o=e;o=o.parent;)o.data&&(n=An(o.data))&&u(r,n);return r}function Sn(e,t){var n=t.data,r=e.data;if(n.staticStyle||n.style||r.staticStyle||r.style){var i,o,a=t.elm,s=e.data.staticStyle,c=e.data.style||{},l=s||c,f=On(t.data.style)||{};t.data.style=f.__ob__?u({},f):f;var p=Tn(t,!0);for(o in l)null==p[o]&&da(a,o,"");for(o in p)(i=p[o])!==l[o]&&da(a,o,null==i?"":i)}}function En(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(/\s+/).forEach(function(t){return e.classList.add(t)}):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function jn(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(/\s+/).forEach(function(t){return e.classList.remove(t)}):e.classList.remove(t);else{for(var n=" "+(e.getAttribute("class")||"")+" ",r=" "+t+" ";n.indexOf(r)>=0;)n=n.replace(r," ");e.setAttribute("class",n.trim())}}function Nn(e){if(e){if("object"==typeof e){var t={};return e.css!==!1&&u(t,ga(e.name||"v")),u(t,e),t}return"string"==typeof e?ga(e):void 0}}function In(e){ka(function(){ka(e)})}function Ln(e,t){(e._transitionClasses||(e._transitionClasses=[])).push(t),En(e,t)}function Dn(e,t){e._transitionClasses&&r(e._transitionClasses,t),jn(e,t)}function Mn(e,t,n){var r=Pn(e,t),i=r.type,o=r.timeout,a=r.propCount;if(!i)return n();var s=i===_a?wa:Ca,c=0,u=function(){e.removeEventListener(s,l),n()},l=function(t){t.target===e&&++c>=a&&u()};setTimeout(function(){c<a&&u()},o+1),e.addEventListener(s,l)}function Pn(e,t){var n,r=window.getComputedStyle(e),i=r[$a+"Delay"].split(", "),o=r[$a+"Duration"].split(", "),a=Rn(i,o),s=r[xa+"Delay"].split(", "),c=r[xa+"Duration"].split(", "),u=Rn(s,c),l=0,f=0;return t===_a?a>0&&(n=_a,l=a,f=o.length):t===ba?u>0&&(n=ba,l=u,f=c.length):(l=Math.max(a,u),n=l>0?a>u?_a:ba:null,f=n?n===_a?o.length:c.length:0),{type:n,timeout:l,propCount:f,hasTransform:n===_a&&Aa.test(r[$a+"Property"])}}function Rn(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map(function(t,n){return Fn(t)+Fn(e[n])}))}function Fn(e){return 1e3*Number(e.slice(0,-1))}function Hn(e,n){var r=e.elm;r._leaveCb&&(r._leaveCb.cancelled=!0,r._leaveCb());var i=Nn(e.data.transition);if(i&&!r._enterCb&&1===r.nodeType){for(var o=i.css,a=i.type,s=i.enterClass,c=i.enterToClass,u=i.enterActiveClass,f=i.appearClass,p=i.appearToClass,d=i.appearActiveClass,v=i.beforeEnter,h=i.enter,g=i.afterEnter,y=i.enterCancelled,_=i.beforeAppear,b=i.appear,$=i.afterAppear,w=i.appearCancelled,x=i.duration,C=so,k=so.$vnode;k&&k.parent;)k=k.parent,C=k.context;var A=!C._isMounted||!e.isRootInsert;if(!A||b||""===b){var O=A&&f?f:s,T=A&&d?d:u,S=A&&p?p:c,E=A?_||v:v,j=A&&"function"==typeof b?b:h,N=A?$||g:g,I=A?w||y:y,L=t(l(x)?x.enter:x),D=o!==!1&&!Mi,M=Vn(j),P=r._enterCb=m(function(){D&&(Dn(r,S),Dn(r,T)),P.cancelled?(D&&Dn(r,O),I&&I(r)):N&&N(r),r._enterCb=null});e.data.show||q(e.data.hook||(e.data.hook={}),"insert",function(){var t=r.parentNode,n=t&&t._pending&&t._pending[e.key];n&&n.tag===e.tag&&n.elm._leaveCb&&n.elm._leaveCb(),j&&j(r,P)}),E&&E(r),D&&(Ln(r,O),Ln(r,T),In(function(){Ln(r,S),Dn(r,O),P.cancelled||M||(Bn(L)?setTimeout(P,L):Mn(r,a,P))})),e.data.show&&(n&&n(),j&&j(r,P)),D||M||P()}}}function Un(e,n){function r(){w.cancelled||(e.data.show||((i.parentNode._pending||(i.parentNode._pending={}))[e.key]=e),p&&p(i),_&&(Ln(i,c),Ln(i,f),In(function(){Ln(i,u),Dn(i,c),w.cancelled||b||(Bn($)?setTimeout(w,$):Mn(i,s,w))})),d&&d(i,w),_||b||w())}var i=e.elm;i._enterCb&&(i._enterCb.cancelled=!0,i._enterCb());var o=Nn(e.data.transition);if(!o)return n();if(!i._leaveCb&&1===i.nodeType){
	var a=o.css,s=o.type,c=o.leaveClass,u=o.leaveToClass,f=o.leaveActiveClass,p=o.beforeLeave,d=o.leave,v=o.afterLeave,h=o.leaveCancelled,g=o.delayLeave,y=o.duration,_=a!==!1&&!Mi,b=Vn(d),$=t(l(y)?y.leave:y),w=i._leaveCb=m(function(){i.parentNode&&i.parentNode._pending&&(i.parentNode._pending[e.key]=null),_&&(Dn(i,u),Dn(i,f)),w.cancelled?(_&&Dn(i,c),h&&h(i)):(n(),v&&v(i)),i._leaveCb=null});g?g(r):r()}}function Bn(e){return"number"==typeof e&&!isNaN(e)}function Vn(e){if(!e)return!1;var t=e.fns;return t?Vn(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function zn(e,t){t.data.show||Hn(t)}function Jn(e,t,n){var r=t.value,i=e.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=e.options.length;s<c;s++)if(a=e.options[s],i)o=h(r,qn(a))>-1,a.selected!==o&&(a.selected=o);else if(v(qn(a),r))return void(e.selectedIndex!==s&&(e.selectedIndex=s));i||(e.selectedIndex=-1)}}function Kn(e,t){for(var n=0,r=t.length;n<r;n++)if(v(qn(t[n]),e))return!1;return!0}function qn(e){return"_value"in e?e._value:e.value}function Wn(e){e.target.composing=!0}function Zn(e){e.target.composing=!1,Gn(e.target,"input")}function Gn(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function Yn(e){return!e.componentInstance||e.data&&e.data.transition?e:Yn(e.componentInstance._vnode)}function Qn(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?Qn(Y(t.children)):e}function Xn(e){var t={},n=e.$options;for(var r in n.propsData)t[r]=e[r];var i=n._parentListeners;for(var o in i)t[wi(o)]=i[o];return t}function er(e,t){return/\d-keep-alive$/.test(t.tag)?e("keep-alive"):null}function tr(e){for(;e=e.parent;)if(e.data.transition)return!0}function nr(e,t){return t.key===e.key&&t.tag===e.tag}function rr(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function ir(e){e.data.newPos=e.elm.getBoundingClientRect()}function or(e){var t=e.data.pos,n=e.data.newPos,r=t.left-n.left,i=t.top-n.top;if(r||i){e.data.moved=!0;var o=e.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}function ar(e){return Fa=Fa||document.createElement("div"),Fa.innerHTML=e,Fa.textContent}function sr(e,t){var n=t?ws:$s;return e.replace(n,function(e){return bs[e]})}function cr(e,t){function n(t){l+=t,e=e.substring(t)}function r(e,n,r){var i,s;if(null==n&&(n=l),null==r&&(r=l),e&&(s=e.toLowerCase()),e)for(i=a.length-1;i>=0&&a[i].lowerCasedTag!==s;i--);else i=0;if(i>=0){for(var c=a.length-1;c>=i;c--)t.end&&t.end(a[c].tag,n,r);a.length=i,o=i&&a[i-1].tag}else"br"===s?t.start&&t.start(e,[],!0,n,r):"p"===s&&(t.start&&t.start(e,[],!1,n,r),t.end&&t.end(e,n,r))}for(var i,o,a=[],s=t.expectHTML,c=t.isUnaryTag||Oi,u=t.canBeLeftOpenTag||Oi,l=0;e;){if(i=e,o&&ys(o)){var f=o.toLowerCase(),p=_s[f]||(_s[f]=new RegExp("([\\s\\S]*?)(</"+f+"[^>]*>)","i")),d=0,v=e.replace(p,function(e,n,r){return d=r.length,ys(f)||"noscript"===f||(n=n.replace(/<!--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),t.chars&&t.chars(n),""});l+=e.length-v.length,e=v,r(f,l-d,l)}else{var h=e.indexOf("<");if(0===h){if(Ya.test(e)){var m=e.indexOf("-->");if(m>=0){n(m+3);continue}}if(Qa.test(e)){var g=e.indexOf("]>");if(g>=0){n(g+2);continue}}var y=e.match(Ga);if(y){n(y[0].length);continue}var _=e.match(Za);if(_){var b=l;n(_[0].length),r(_[1],b,l);continue}var $=function(){var t=e.match(qa);if(t){var r={tagName:t[1],attrs:[],start:l};n(t[0].length);for(var i,o;!(i=e.match(Wa))&&(o=e.match(Ja));)n(o[0].length),r.attrs.push(o);if(i)return r.unarySlash=i[1],n(i[0].length),r.end=l,r}}();if($){!function(e){var n=e.tagName,i=e.unarySlash;s&&("p"===o&&Va(n)&&r(o),u(n)&&o===n&&r(n));for(var l=c(n)||"html"===n&&"head"===o||!!i,f=e.attrs.length,p=new Array(f),d=0;d<f;d++){var v=e.attrs[d];Xa&&v[0].indexOf('""')===-1&&(""===v[3]&&delete v[3],""===v[4]&&delete v[4],""===v[5]&&delete v[5]);var h=v[3]||v[4]||v[5]||"";p[d]={name:v[1],value:sr(h,t.shouldDecodeNewlines)}}l||(a.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:p}),o=n),t.start&&t.start(n,p,l,e.start,e.end)}($);continue}}var w=void 0,x=void 0,C=void 0;if(h>=0){for(x=e.slice(h);!(Za.test(x)||qa.test(x)||Ya.test(x)||Qa.test(x)||(C=x.indexOf("<",1))<0);)h+=C,x=e.slice(h);w=e.substring(0,h),n(h)}h<0&&(w=e,e=""),t.chars&&w&&t.chars(w)}if(e===i){t.chars&&t.chars(e);break}}r()}function ur(e,t){var n=t?Cs(t):xs;if(n.test(e)){for(var r,i,o=[],a=n.lastIndex=0;r=n.exec(e);){i=r.index,i>a&&o.push(JSON.stringify(e.slice(a,i)));var s=Wt(r[1].trim());o.push("_s("+s+")"),a=i+r[0].length}return a<e.length&&o.push(JSON.stringify(e.slice(a))),o.join("+")}}function lr(e,t){function n(e){e.pre&&(s=!1),os(e.tag)&&(c=!1)}es=t.warn||Gt,ss=t.getTagNamespace||Oi,as=t.mustUseProp||Oi,os=t.isPreTag||Oi,rs=Yt(t.modules,"preTransformNode"),ns=Yt(t.modules,"transformNode"),is=Yt(t.modules,"postTransformNode"),ts=t.delimiters;var r,i,o=[],a=t.preserveWhitespace!==!1,s=!1,c=!1;return cr(e,{warn:es,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,start:function(e,a,u){var l=i&&i.ns||ss(e);Di&&"svg"===l&&(a=Tr(a));var f={type:1,tag:e,attrsList:a,attrsMap:Ar(a),parent:i,children:[]};l&&(f.ns=l),Or(f)&&!Ui()&&(f.forbidden=!0);for(var p=0;p<rs.length;p++)rs[p](f,t);if(s||(fr(f),f.pre&&(s=!0)),os(f.tag)&&(c=!0),s)pr(f);else{hr(f),mr(f),br(f),dr(f),f.plain=!f.key&&!a.length,vr(f),$r(f),wr(f);for(var d=0;d<ns.length;d++)ns[d](f,t);xr(f)}if(r?o.length||r.if&&(f.elseif||f.else)&&_r(r,{exp:f.elseif,block:f}):r=f,i&&!f.forbidden)if(f.elseif||f.else)gr(f,i);else if(f.slotScope){i.plain=!1;var v=f.slotTarget||'"default"';(i.scopedSlots||(i.scopedSlots={}))[v]=f}else i.children.push(f),f.parent=i;u?n(f):(i=f,o.push(f));for(var h=0;h<is.length;h++)is[h](f,t)},end:function(){var e=o[o.length-1],t=e.children[e.children.length-1];t&&3===t.type&&" "===t.text&&!c&&e.children.pop(),o.length-=1,i=o[o.length-1],n(e)},chars:function(e){if(i&&(!Di||"textarea"!==i.tag||i.attrsMap.placeholder!==e)){var t=i.children;if(e=c||e.trim()?Ns(e):a&&t.length?" ":""){var n;!s&&" "!==e&&(n=ur(e,ts))?t.push({type:2,expression:n,text:e}):" "===e&&t.length&&" "===t[t.length-1].text||t.push({type:3,text:e})}}}}),r}function fr(e){null!=rn(e,"v-pre")&&(e.pre=!0)}function pr(e){var t=e.attrsList.length;if(t)for(var n=e.attrs=new Array(t),r=0;r<t;r++)n[r]={name:e.attrsList[r].name,value:JSON.stringify(e.attrsList[r].value)};else e.pre||(e.plain=!0)}function dr(e){var t=nn(e,"key");t&&(e.key=t)}function vr(e){var t=nn(e,"ref");t&&(e.ref=t,e.refInFor=Cr(e))}function hr(e){var t;if(t=rn(e,"v-for")){var n=t.match(Os);if(!n)return;e.for=n[2].trim();var r=n[1].trim(),i=r.match(Ts);i?(e.alias=i[1].trim(),e.iterator1=i[2].trim(),i[3]&&(e.iterator2=i[3].trim())):e.alias=r}}function mr(e){var t=rn(e,"v-if");if(t)e.if=t,_r(e,{exp:t,block:e});else{null!=rn(e,"v-else")&&(e.else=!0);var n=rn(e,"v-else-if");n&&(e.elseif=n)}}function gr(e,t){var n=yr(t.children);n&&n.if&&_r(n,{exp:e.elseif,block:e})}function yr(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}function _r(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function br(e){null!=rn(e,"v-once")&&(e.once=!0)}function $r(e){if("slot"===e.tag)e.slotName=nn(e,"name");else{var t=nn(e,"slot");t&&(e.slotTarget='""'===t?'"default"':t),"template"===e.tag&&(e.slotScope=rn(e,"scope"))}}function wr(e){var t;(t=nn(e,"is"))&&(e.component=t),null!=rn(e,"inline-template")&&(e.inlineTemplate=!0)}function xr(e){var t,n,r,i,o,a,s,c=e.attrsList;for(t=0,n=c.length;t<n;t++)if(r=i=c[t].name,o=c[t].value,As.test(r))if(e.hasBindings=!0,a=kr(r),a&&(r=r.replace(js,"")),Es.test(r))r=r.replace(Es,""),o=Wt(o),s=!1,a&&(a.prop&&(s=!0,"innerHtml"===(r=wi(r))&&(r="innerHTML")),a.camel&&(r=wi(r))),s||as(e.tag,e.attrsMap.type,r)?Qt(e,r,o):Xt(e,r,o);else if(ks.test(r))r=r.replace(ks,""),tn(e,r,o,a);else{r=r.replace(As,"");var u=r.match(Ss),l=u&&u[1];l&&(r=r.slice(0,-(l.length+1))),en(e,r,i,o,l,a)}else Xt(e,r,JSON.stringify(o))}function Cr(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}function kr(e){var t=e.match(js);if(t){var n={};return t.forEach(function(e){n[e.slice(1)]=!0}),n}}function Ar(e){for(var t={},n=0,r=e.length;n<r;n++)t[e[n].name]=e[n].value;return t}function Or(e){return"style"===e.tag||"script"===e.tag&&(!e.attrsMap.type||"text/javascript"===e.attrsMap.type)}function Tr(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];Is.test(r.name)||(r.name=r.name.replace(Ls,""),t.push(r))}return t}function Sr(e,t){e&&(cs=Ds(t.staticKeys||""),us=t.isReservedTag||Oi,jr(e),Nr(e,!1))}function Er(e){return n("type,tag,attrsList,attrsMap,plain,parent,children,attrs"+(e?","+e:""))}function jr(e){if(e.static=Lr(e),1===e.type){if(!us(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var r=e.children[t];jr(r),r.static||(e.static=!1)}}}function Nr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,r=e.children.length;n<r;n++)Nr(e.children[n],t||!!e.for);e.ifConditions&&Ir(e.ifConditions,t)}}function Ir(e,t){for(var n=1,r=e.length;n<r;n++)Nr(e[n].block,t)}function Lr(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||bi(e.tag)||!us(e.tag)||Dr(e)||!Object.keys(e).every(cs))))}function Dr(e){for(;e.parent;){if(e=e.parent,"template"!==e.tag)return!1;if(e.for)return!0}return!1}function Mr(e,t){var n=t?"nativeOn:{":"on:{";for(var r in e)n+='"'+r+'":'+Pr(r,e[r])+",";return n.slice(0,-1)+"}"}function Pr(e,t){if(!t)return"function(){}";if(Array.isArray(t))return"["+t.map(function(t){return Pr(e,t)}).join(",")+"]";var n=Ps.test(t.value),r=Ms.test(t.value);if(t.modifiers){var i="",o="",a=[];for(var s in t.modifiers)Hs[s]?(o+=Hs[s],Rs[s]&&a.push(s)):a.push(s);a.length&&(i+=Rr(a)),o&&(i+=o);return"function($event){"+i+(n?t.value+"($event)":r?"("+t.value+")($event)":t.value)+"}"}return n||r?t.value:"function($event){"+t.value+"}"}function Rr(e){return"if(!('button' in $event)&&"+e.map(Fr).join("&&")+")return null;"}function Fr(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Rs[e];return"_k($event.keyCode,"+JSON.stringify(e)+(n?","+JSON.stringify(n):"")+")"}function Hr(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+(t.modifiers&&t.modifiers.prop?",true":"")+")"}}function Ur(e,t){var n=hs,r=hs=[],i=ms;ms=0,gs=t,ls=t.warn||Gt,fs=Yt(t.modules,"transformCode"),ps=Yt(t.modules,"genData"),ds=t.directives||{},vs=t.isReservedTag||Oi;var o=e?Br(e):'_c("div")';return hs=n,ms=i,{render:"with(this){return "+o+"}",staticRenderFns:r}}function Br(e){if(e.staticRoot&&!e.staticProcessed)return Vr(e);if(e.once&&!e.onceProcessed)return zr(e);if(e.for&&!e.forProcessed)return qr(e);if(e.if&&!e.ifProcessed)return Jr(e);if("template"!==e.tag||e.slotTarget){if("slot"===e.tag)return oi(e);var t;if(e.component)t=ai(e.component,e);else{var n=e.plain?void 0:Wr(e),r=e.inlineTemplate?null:Xr(e,!0);t="_c('"+e.tag+"'"+(n?","+n:"")+(r?","+r:"")+")"}for(var i=0;i<fs.length;i++)t=fs[i](e,t);return t}return Xr(e)||"void 0"}function Vr(e){return e.staticProcessed=!0,hs.push("with(this){return "+Br(e)+"}"),"_m("+(hs.length-1)+(e.staticInFor?",true":"")+")"}function zr(e){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Jr(e);if(e.staticInFor){for(var t="",n=e.parent;n;){if(n.for){t=n.key;break}n=n.parent}return t?"_o("+Br(e)+","+ms+++(t?","+t:"")+")":Br(e)}return Vr(e)}function Jr(e){return e.ifProcessed=!0,Kr(e.ifConditions.slice())}function Kr(e){function t(e){return e.once?zr(e):Br(e)}if(!e.length)return"_e()";var n=e.shift();return n.exp?"("+n.exp+")?"+t(n.block)+":"+Kr(e):""+t(n.block)}function qr(e){var t=e.for,n=e.alias,r=e.iterator1?","+e.iterator1:"",i=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,"_l(("+t+"),function("+n+r+i+"){return "+Br(e)+"})"}function Wr(e){var t="{",n=Zr(e);n&&(t+=n+","),e.key&&(t+="key:"+e.key+","),e.ref&&(t+="ref:"+e.ref+","),e.refInFor&&(t+="refInFor:true,"),e.pre&&(t+="pre:true,"),e.component&&(t+='tag:"'+e.tag+'",');for(var r=0;r<ps.length;r++)t+=ps[r](e);if(e.attrs&&(t+="attrs:{"+si(e.attrs)+"},"),e.props&&(t+="domProps:{"+si(e.props)+"},"),e.events&&(t+=Mr(e.events)+","),e.nativeEvents&&(t+=Mr(e.nativeEvents,!0)+","),e.slotTarget&&(t+="slot:"+e.slotTarget+","),e.scopedSlots&&(t+=Yr(e.scopedSlots)+","),e.model&&(t+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var i=Gr(e);i&&(t+=i+",")}return t=t.replace(/,$/,"")+"}",e.wrapData&&(t=e.wrapData(t)),t}function Zr(e){var t=e.directives;if(t){var n,r,i,o,a="directives:[",s=!1;for(n=0,r=t.length;n<r;n++){i=t[n],o=!0;var c=ds[i.name]||Us[i.name];c&&(o=!!c(e,i,ls)),o&&(s=!0,a+='{name:"'+i.name+'",rawName:"'+i.rawName+'"'+(i.value?",value:("+i.value+"),expression:"+JSON.stringify(i.value):"")+(i.arg?',arg:"'+i.arg+'"':"")+(i.modifiers?",modifiers:"+JSON.stringify(i.modifiers):"")+"},")}return s?a.slice(0,-1)+"]":void 0}}function Gr(e){var t=e.children[0];if(1===t.type){var n=Ur(t,gs);return"inlineTemplate:{render:function(){"+n.render+"},staticRenderFns:["+n.staticRenderFns.map(function(e){return"function(){"+e+"}"}).join(",")+"]}"}}function Yr(e){return"scopedSlots:_u(["+Object.keys(e).map(function(t){return Qr(t,e[t])}).join(",")+"])"}function Qr(e,t){return"["+e+",function("+String(t.attrsMap.scope)+"){return "+("template"===t.tag?Xr(t)||"void 0":Br(t))+"}]"}function Xr(e,t){var n=e.children;if(n.length){var r=n[0];if(1===n.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag)return Br(r);var i=t?ei(n):0;return"["+n.map(ri).join(",")+"]"+(i?","+i:"")}}function ei(e){for(var t=0,n=0;n<e.length;n++){var r=e[n];if(1===r.type){if(ti(r)||r.ifConditions&&r.ifConditions.some(function(e){return ti(e.block)})){t=2;break}(ni(r)||r.ifConditions&&r.ifConditions.some(function(e){return ni(e.block)}))&&(t=1)}}return t}function ti(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function ni(e){return!vs(e.tag)}function ri(e){return 1===e.type?Br(e):ii(e)}function ii(e){return"_v("+(2===e.type?e.expression:ci(JSON.stringify(e.text)))+")"}function oi(e){var t=e.slotName||'"default"',n=Xr(e),r="_t("+t+(n?","+n:""),i=e.attrs&&"{"+e.attrs.map(function(e){return wi(e.name)+":"+e.value}).join(",")+"}",o=e.attrsMap["v-bind"];return!i&&!o||n||(r+=",null"),i&&(r+=","+i),o&&(r+=(i?"":",null")+","+o),r+")"}function ai(e,t){var n=t.inlineTemplate?null:Xr(t,!0);return"_c("+e+","+Wr(t)+(n?","+n:"")+")"}function si(e){for(var t="",n=0;n<e.length;n++){var r=e[n];t+='"'+r.name+'":'+ci(r.value)+","}return t.slice(0,-1)}function ci(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function ui(e,t){var n=lr(e.trim(),t);Sr(n,t);var r=Ur(n,t);return{ast:n,render:r.render,staticRenderFns:r.staticRenderFns}}function li(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),d}}function fi(e,t){var n=(t.warn,rn(e,"class"));n&&(e.staticClass=JSON.stringify(n));var r=nn(e,"class",!1);r&&(e.classBinding=r)}function pi(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}function di(e,t){var n=(t.warn,rn(e,"style"));n&&(e.staticStyle=JSON.stringify(la(n)));var r=nn(e,"style",!1);r&&(e.styleBinding=r)}function vi(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}function hi(e,t){t.value&&Qt(e,"textContent","_s("+t.value+")")}function mi(e,t){t.value&&Qt(e,"innerHTML","_s("+t.value+")")}function gi(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}var yi,_i,bi=n("slot,component",!0),$i=Object.prototype.hasOwnProperty,wi=a(function(e){return e.replace(/-(\w)/g,function(e,t){return t?t.toUpperCase():""})}),xi=a(function(e){return e.charAt(0).toUpperCase()+e.slice(1)}),Ci=a(function(e){return e.replace(/([^-])([A-Z])/g,"$1-$2").replace(/([^-])([A-Z])/g,"$1-$2").toLowerCase()}),ki=Object.prototype.toString,Ai="[object Object]",Oi=function(){return!1},Ti=function(e){return e},Si={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:Oi,isUnknownElement:Oi,getTagNamespace:d,parsePlatformTagName:Ti,mustUseProp:Oi,_assetTypes:["component","directive","filter"],_lifecycleHooks:["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated"],_maxUpdateCount:100},Ei=Object.freeze({}),ji=/[^\w.$]/,Ni="__proto__"in{},Ii="undefined"!=typeof window,Li=Ii&&window.navigator.userAgent.toLowerCase(),Di=Li&&/msie|trident/.test(Li),Mi=Li&&Li.indexOf("msie 9.0")>0,Pi=Li&&Li.indexOf("edge/")>0,Ri=Li&&Li.indexOf("android")>0,Fi=Li&&/iphone|ipad|ipod|ios/.test(Li),Hi=Li&&/chrome\/\d+/.test(Li)&&!Pi,Ui=function(){return void 0===yi&&(yi=!Ii&&"undefined"!=typeof global&&"server"===global.process.env.VUE_ENV),yi},Bi=Ii&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,Vi="undefined"!=typeof Symbol&&b(Symbol)&&"undefined"!=typeof Reflect&&b(Reflect.ownKeys),zi=function(){function e(){r=!1;var e=n.slice(0);n.length=0;for(var t=0;t<e.length;t++)e[t]()}var t,n=[],r=!1;if("undefined"!=typeof Promise&&b(Promise)){var i=Promise.resolve(),o=function(e){console.error(e)};t=function(){i.then(e).catch(o),Fi&&setTimeout(d)}}else if("undefined"==typeof MutationObserver||!b(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())t=function(){setTimeout(e,0)};else{var a=1,s=new MutationObserver(e),c=document.createTextNode(String(a));s.observe(c,{characterData:!0}),t=function(){a=(a+1)%2,c.data=String(a)}}return function(e,i){var o;if(n.push(function(){e&&e.call(i),o&&o(i)}),r||(r=!0,t()),!e&&"undefined"!=typeof Promise)return new Promise(function(e){o=e})}}();_i="undefined"!=typeof Set&&b(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return this.set[e]===!0},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var Ji=d,Ki=0,qi=function(){this.id=Ki++,this.subs=[]};qi.prototype.addSub=function(e){this.subs.push(e)},qi.prototype.removeSub=function(e){r(this.subs,e)},qi.prototype.depend=function(){qi.target&&qi.target.addDep(this)},qi.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},qi.target=null;var Wi=[],Zi=Array.prototype,Gi=Object.create(Zi);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(e){var t=Zi[e];y(Gi,e,function(){for(var n=arguments,r=arguments.length,i=new Array(r);r--;)i[r]=n[r];var o,a=t.apply(this,i),s=this.__ob__;switch(e){case"push":o=i;break;case"unshift":o=i;break;case"splice":o=i.slice(2)}return o&&s.observeArray(o),s.dep.notify(),a})});var Yi=Object.getOwnPropertyNames(Gi),Qi={shouldConvert:!0,isSettingProps:!1},Xi=function(e){if(this.value=e,this.dep=new qi,this.vmCount=0,y(e,"__ob__",this),Array.isArray(e)){(Ni?x:C)(e,Gi,Yi),this.observeArray(e)}else this.walk(e)};Xi.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)A(e,t[n],e[t[n]])},Xi.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)k(e[t])};var eo=Si.optionMergeStrategies;eo.data=function(e,t,n){return n?e||t?function(){var r="function"==typeof t?t.call(n):t,i="function"==typeof e?e.call(n):void 0;return r?E(r,i):i}:void 0:t?"function"!=typeof t?e:e?function(){return E(t.call(this),e.call(this))}:t:e},Si._lifecycleHooks.forEach(function(e){eo[e]=j}),Si._assetTypes.forEach(function(e){eo[e+"s"]=N}),eo.watch=function(e,t){if(!t)return Object.create(e||null);if(!e)return t;var n={};u(n,e);for(var r in t){var i=n[r],o=t[r];i&&!Array.isArray(i)&&(i=[i]),n[r]=i?i.concat(o):[o]}return n},eo.props=eo.methods=eo.computed=function(e,t){if(!t)return Object.create(e||null);if(!e)return t;var n=Object.create(null);return u(n,e),u(n,t),n};var to=function(e,t){return void 0===t?e:t},no=function(e,t,n,r,i,o,a){this.tag=e,this.data=t,this.children=n,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.functionalContext=void 0,this.key=t&&t.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1},ro={child:{}};ro.child.get=function(){return this.componentInstance},Object.defineProperties(no.prototype,ro);var io,oo=function(){var e=new no;return e.text="",e.isComment=!0,e},ao=a(function(e){var t="~"===e.charAt(0);e=t?e.slice(1):e;var n="!"===e.charAt(0);return e=n?e.slice(1):e,{name:e,once:t,capture:n}}),so=null,co=[],uo={},lo=!1,fo=!1,po=0,vo=0,ho=function(e,t,n,r){this.vm=e,e._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++vo,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new _i,this.newDepIds=new _i,this.expression="","function"==typeof t?this.getter=t:(this.getter=_(t),this.getter||(this.getter=function(){})),this.value=this.lazy?void 0:this.get()};ho.prototype.get=function(){$(this);var e,t=this.vm;if(this.user)try{e=this.getter.call(t,t)}catch(e){U(e,t,'getter for watcher "'+this.expression+'"')}else e=this.getter.call(t,t);return this.deep&&he(e),w(),this.cleanupDeps(),e},ho.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},ho.prototype.cleanupDeps=function(){for(var e=this,t=this.deps.length;t--;){var n=e.deps[t];e.newDepIds.has(n.id)||n.removeSub(e)}var r=this.depIds;this.depIds=this.newDepIds,this.newDepIds=r,this.newDepIds.clear(),r=this.deps,this.deps=this.newDeps,this.newDeps=r,this.newDeps.length=0},ho.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ve(this)},ho.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||l(e)||this.deep){var t=this.value;if(this.value=e,this.user)try{this.cb.call(this.vm,e,t)}catch(e){U(e,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,e,t)}}},ho.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ho.prototype.depend=function(){for(var e=this,t=this.deps.length;t--;)e.deps[t].depend()},ho.prototype.teardown=function(){var e=this;if(this.active){this.vm._isBeingDestroyed||r(this.vm._watchers,this);for(var t=this.deps.length;t--;)e.deps[t].removeSub(e);this.active=!1}};var mo=new _i,go={enumerable:!0,configurable:!0,get:d,set:d},yo={lazy:!0},_o={init:function(e,t,n,r){if(!e.componentInstance||e.componentInstance._isDestroyed){(e.componentInstance=Ee(e,so,n,r)).$mount(t?e.elm:void 0,t)}else if(e.data.keepAlive){var i=e;_o.prepatch(i,i)}},prepatch:function(e,t){var n=t.componentOptions;se(t.componentInstance=e.componentInstance,n.propsData,n.listeners,t,n.children)},insert:function(e){e.componentInstance._isMounted||(e.componentInstance._isMounted=!0,fe(e.componentInstance,"mounted")),e.data.keepAlive&&ue(e.componentInstance,!0)},destroy:function(e){e.componentInstance._isDestroyed||(e.data.keepAlive?le(e.componentInstance,!0):e.componentInstance.$destroy())}},bo=Object.keys(_o),$o=1,wo=2,xo=0;!function(e){e.prototype._init=function(e){var t=this;t._uid=xo++,t._isVue=!0,e&&e._isComponent?Qe(t,e):t.$options=D(Xe(t.constructor),e||{},t),t._renderProxy=t,t._self=t,oe(t),Q(t),Ze(t),fe(t,"beforeCreate"),Ye(t),ye(t),Ge(t),fe(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}(nt),function(e){var t={};t.get=function(){return this._data};var n={};n.get=function(){return this._props},Object.defineProperty(e.prototype,"$data",t),Object.defineProperty(e.prototype,"$props",n),e.prototype.$set=O,e.prototype.$delete=T,e.prototype.$watch=function(e,t,n){var r=this;n=n||{},n.user=!0;var i=new ho(r,e,t,n);return n.immediate&&t.call(r,i.value),function(){i.teardown()}}}(nt),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var r=this,i=this;if(Array.isArray(e))for(var o=0,a=e.length;o<a;o++)r.$on(e[o],n);else(i._events[e]||(i._events[e]=[])).push(n),t.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){function n(){r.$off(e,n),t.apply(r,arguments)}var r=this;return n.fn=t,r.$on(e,n),r},e.prototype.$off=function(e,t){var n=this,r=this;if(!arguments.length)return r._events=Object.create(null),r;if(Array.isArray(e)){for(var i=0,o=e.length;i<o;i++)n.$off(e[i],t);return r}var a=r._events[e];if(!a)return r;if(1===arguments.length)return r._events[e]=null,r;for(var s,c=a.length;c--;)if((s=a[c])===t||s.fn===t){a.splice(c,1);break}return r},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?c(n):n;for(var r=c(arguments,1),i=0,o=n.length;i<o;i++)n[i].apply(t,r)}return t}}(nt),function(e){e.prototype._update=function(e,t){var n=this;n._isMounted&&fe(n,"beforeUpdate");var r=n.$el,i=n._vnode,o=so;so=n,n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1,n.$options._parentElm,n.$options._refElm),so=o,r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){var e=this;e._watcher&&e._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){fe(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||r(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),fe(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$options._parentElm=e.$options._refElm=null}}}(nt),function(n){n.prototype.$nextTick=function(e){return zi(e,this)},n.prototype._render=function(){var e=this,t=e.$options,n=t.render,r=t.staticRenderFns,i=t._parentVnode;if(e._isMounted)for(var o in e.$slots)e.$slots[o]=z(e.$slots[o]);e.$scopedSlots=i&&i.data.scopedSlots||Ei,r&&!e._staticTrees&&(e._staticTrees=[]),e.$vnode=i;var a;try{a=n.call(e._renderProxy,e.$createElement)}catch(t){U(t,e,"render function"),a=e._vnode}return a instanceof no||(a=oo()),a.parent=i,a},n.prototype._o=Ke,n.prototype._n=t,n.prototype._s=e,n.prototype._l=He,n.prototype._t=Ue,n.prototype._q=v,n.prototype._i=h,n.prototype._m=Je,n.prototype._f=Be,n.prototype._k=Ve,n.prototype._b=ze,n.prototype._v=B,n.prototype._e=oo,n.prototype._u=ie}(nt);var Co=[String,RegExp],ko={name:"keep-alive",abstract:!0,props:{include:Co,exclude:Co},created:function(){this.cache=Object.create(null)},destroyed:function(){var e=this;for(var t in e.cache)pt(e.cache[t])},watch:{include:function(e){ft(this.cache,function(t){return lt(e,t)})},exclude:function(e){ft(this.cache,function(t){return!lt(e,t)})}},render:function(){var e=Y(this.$slots.default),t=e&&e.componentOptions;if(t){var n=ut(t);if(n&&(this.include&&!lt(this.include,n)||this.exclude&&lt(this.exclude,n)))return e;var r=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;this.cache[r]?e.componentInstance=this.cache[r].componentInstance:this.cache[r]=e,e.data.keepAlive=!0}return e}},Ao={KeepAlive:ko};!function(e){var t={};t.get=function(){return Si},Object.defineProperty(e,"config",t),e.util={warn:Ji,extend:u,mergeOptions:D,defineReactive:A},e.set=O,e.delete=T,e.nextTick=zi,e.options=Object.create(null),Si._assetTypes.forEach(function(t){e.options[t+"s"]=Object.create(null)}),e.options._base=e,u(e.options.components,Ao),rt(e),it(e),ot(e),ct(e)}(nt),Object.defineProperty(nt.prototype,"$isServer",{get:Ui}),nt.version="2.2.6";var Oo,To,So,Eo,jo,No,Io,Lo,Do,Mo=n("input,textarea,option,select"),Po=function(e,t,n){return"value"===n&&Mo(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Ro=n("contenteditable,draggable,spellcheck"),Fo=n("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Ho="http://www.w3.org/1999/xlink",Uo=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},Bo=function(e){return Uo(e)?e.slice(6,e.length):""},Vo=function(e){return null==e||e===!1},zo={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Jo=n("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template"),Ko=n("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),qo=function(e){return"pre"===e},Wo=function(e){return Jo(e)||Ko(e)},Zo=Object.create(null),Go=Object.freeze({createElement:$t,createElementNS:wt,createTextNode:xt,createComment:Ct,insertBefore:kt,removeChild:At,appendChild:Ot,parentNode:Tt,nextSibling:St,tagName:Et,setTextContent:jt,setAttribute:Nt}),Yo={create:function(e,t){It(t)},update:function(e,t){e.data.ref!==t.data.ref&&(It(e,!0),It(t))},destroy:function(e){It(e,!0)}},Qo=new no("",{},[]),Xo=["create","activate","update","remove","destroy"],ea={create:Ht,update:Ht,destroy:function(e){Ht(e,Qo)}},ta=Object.create(null),na=[Yo,ea],ra={create:Jt,update:Jt},ia={create:qt,update:qt},oa=/[\w).+\-_$\]]/,aa="__r",sa="__c",ca={create:$n,update:$n},ua={create:wn,update:wn},la=a(function(e){var t={};return e.split(/;(?![^(]*\))/g).forEach(function(e){if(e){var n=e.split(/:(.+)/);n.length>1&&(t[n[0].trim()]=n[1].trim())}}),t}),fa=/^--/,pa=/\s*!important$/,da=function(e,t,n){fa.test(t)?e.style.setProperty(t,n):pa.test(n)?e.style.setProperty(t,n.replace(pa,""),"important"):e.style[ha(t)]=n},va=["Webkit","Moz","ms"],ha=a(function(e){if(Do=Do||document.createElement("div"),"filter"!==(e=wi(e))&&e in Do.style)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<va.length;n++){var r=va[n]+t;if(r in Do.style)return r}}),ma={create:Sn,update:Sn},ga=a(function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}}),ya=Ii&&!Mi,_a="transition",ba="animation",$a="transition",wa="transitionend",xa="animation",Ca="animationend";ya&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&($a="WebkitTransition",wa="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(xa="WebkitAnimation",Ca="webkitAnimationEnd"));var ka=Ii&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout,Aa=/\b(transform|all)(,|$)/,Oa=Ii?{create:zn,activate:zn,remove:function(e,t){e.data.show?t():Un(e,t)}}:{},Ta=[ra,ia,ca,ua,ma,Oa],Sa=Ta.concat(na),Ea=function(e){function t(e){return new no(O.tagName(e).toLowerCase(),{},[],void 0,e)}function r(e,t){function n(){0==--n.listeners&&i(e)}return n.listeners=t,n}function i(e){var t=O.parentNode(e);Dt(t)&&O.removeChild(t,e)}function a(e,t,n,r,i){if(e.isRootInsert=!i,!s(e,t,n,r)){var o=e.data,a=e.children,c=e.tag;Dt(c)?(e.elm=e.ns?O.createElementNS(e.ns,c):O.createElement(c,e),v(e),f(e,a,t),Dt(o)&&d(e,t),l(n,e.elm,r)):Mt(e.isComment)?(e.elm=O.createComment(e.text),
	l(n,e.elm,r)):(e.elm=O.createTextNode(e.text),l(n,e.elm,r))}}function s(e,t,n,r){var i=e.data;if(Dt(i)){var o=Dt(e.componentInstance)&&i.keepAlive;if(Dt(i=i.hook)&&Dt(i=i.init)&&i(e,!1,n,r),Dt(e.componentInstance))return c(e,t),Mt(o)&&u(e,t,n,r),!0}}function c(e,t){Dt(e.data.pendingInsert)&&t.push.apply(t,e.data.pendingInsert),e.elm=e.componentInstance.$el,p(e)?(d(e,t),v(e)):(It(e),t.push(e))}function u(e,t,n,r){for(var i,o=e;o.componentInstance;)if(o=o.componentInstance._vnode,Dt(i=o.data)&&Dt(i=i.transition)){for(i=0;i<k.activate.length;++i)k.activate[i](Qo,o);t.push(o);break}l(n,e.elm,r)}function l(e,t,n){Dt(e)&&(Dt(n)?O.insertBefore(e,t,n):O.appendChild(e,t))}function f(e,t,n){if(Array.isArray(t))for(var r=0;r<t.length;++r)a(t[r],n,e.elm,null,!0);else o(e.text)&&O.appendChild(e.elm,O.createTextNode(e.text))}function p(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return Dt(e.tag)}function d(e,t){for(var n=0;n<k.create.length;++n)k.create[n](Qo,e);x=e.data.hook,Dt(x)&&(Dt(x.create)&&x.create(Qo,e),Dt(x.insert)&&t.push(e))}function v(e){for(var t,n=e;n;)Dt(t=n.context)&&Dt(t=t.$options._scopeId)&&O.setAttribute(e.elm,t,""),n=n.parent;Dt(t=so)&&t!==e.context&&Dt(t=t.$options._scopeId)&&O.setAttribute(e.elm,t,"")}function h(e,t,n,r,i,o){for(;r<=i;++r)a(n[r],o,e,t)}function m(e){var t,n,r=e.data;if(Dt(r))for(Dt(t=r.hook)&&Dt(t=t.destroy)&&t(e),t=0;t<k.destroy.length;++t)k.destroy[t](e);if(Dt(t=e.children))for(n=0;n<e.children.length;++n)m(e.children[n])}function g(e,t,n,r){for(;n<=r;++n){var o=t[n];Dt(o)&&(Dt(o.tag)?(y(o),m(o)):i(o.elm))}}function y(e,t){if(Dt(t)||Dt(e.data)){var n=k.remove.length+1;for(Dt(t)?t.listeners+=n:t=r(e.elm,n),Dt(x=e.componentInstance)&&Dt(x=x._vnode)&&Dt(x.data)&&y(x,t),x=0;x<k.remove.length;++x)k.remove[x](e,t);Dt(x=e.data.hook)&&Dt(x=x.remove)?x(e,t):t()}else i(e.elm)}function _(e,t,n,r,i){for(var o,s,c,u,l=0,f=0,p=t.length-1,d=t[0],v=t[p],m=n.length-1,y=n[0],_=n[m],$=!i;l<=p&&f<=m;)Lt(d)?d=t[++l]:Lt(v)?v=t[--p]:Pt(d,y)?(b(d,y,r),d=t[++l],y=n[++f]):Pt(v,_)?(b(v,_,r),v=t[--p],_=n[--m]):Pt(d,_)?(b(d,_,r),$&&O.insertBefore(e,d.elm,O.nextSibling(v.elm)),d=t[++l],_=n[--m]):Pt(v,y)?(b(v,y,r),$&&O.insertBefore(e,v.elm,d.elm),v=t[--p],y=n[++f]):(Lt(o)&&(o=Ft(t,l,p)),s=Dt(y.key)?o[y.key]:null,Lt(s)?(a(y,r,e,d.elm),y=n[++f]):(c=t[s],Pt(c,y)?(b(c,y,r),t[s]=void 0,$&&O.insertBefore(e,y.elm,d.elm),y=n[++f]):(a(y,r,e,d.elm),y=n[++f])));l>p?(u=Lt(n[m+1])?null:n[m+1].elm,h(e,u,n,f,m,r)):f>m&&g(e,t,l,p)}function b(e,t,n,r){if(e!==t){if(Mt(t.isStatic)&&Mt(e.isStatic)&&t.key===e.key&&(Mt(t.isCloned)||Mt(t.isOnce)))return t.elm=e.elm,void(t.componentInstance=e.componentInstance);var i,o=t.data;Dt(o)&&Dt(i=o.hook)&&Dt(i=i.prepatch)&&i(e,t);var a=t.elm=e.elm,s=e.children,c=t.children;if(Dt(o)&&p(t)){for(i=0;i<k.update.length;++i)k.update[i](e,t);Dt(i=o.hook)&&Dt(i=i.update)&&i(e,t)}Lt(t.text)?Dt(s)&&Dt(c)?s!==c&&_(a,s,c,n,r):Dt(c)?(Dt(e.text)&&O.setTextContent(a,""),h(a,null,c,0,c.length-1,n)):Dt(s)?g(a,s,0,s.length-1):Dt(e.text)&&O.setTextContent(a,""):e.text!==t.text&&O.setTextContent(a,t.text),Dt(o)&&Dt(i=o.hook)&&Dt(i=i.postpatch)&&i(e,t)}}function $(e,t,n){if(Mt(n)&&Dt(e.parent))e.parent.data.pendingInsert=t;else for(var r=0;r<t.length;++r)t[r].data.hook.insert(t[r])}function w(e,t,n){t.elm=e;var r=t.tag,i=t.data,o=t.children;if(Dt(i)&&(Dt(x=i.hook)&&Dt(x=x.init)&&x(t,!0),Dt(x=t.componentInstance)))return c(t,n),!0;if(Dt(r)){if(Dt(o))if(e.hasChildNodes()){for(var a=!0,s=e.firstChild,u=0;u<o.length;u++){if(!s||!w(s,o[u],n)){a=!1;break}s=s.nextSibling}if(!a||s)return!1}else f(t,o,n);if(Dt(i))for(var l in i)if(!T(l)){d(t,n);break}}else e.data!==t.text&&(e.data=t.text);return!0}var x,C,k={},A=e.modules,O=e.nodeOps;for(x=0;x<Xo.length;++x)for(k[Xo[x]]=[],C=0;C<A.length;++C)Dt(A[C][Xo[x]])&&k[Xo[x]].push(A[C][Xo[x]]);var T=n("attrs,style,class,staticClass,staticStyle,key");return function(e,n,r,i,o,s){if(Lt(n))return void(Dt(e)&&m(e));var c=!1,u=[];if(Lt(e))c=!0,a(n,u,o,s);else{var l=Dt(e.nodeType);if(!l&&Pt(e,n))b(e,n,u,i);else{if(l){if(1===e.nodeType&&e.hasAttribute("server-rendered")&&(e.removeAttribute("server-rendered"),r=!0),Mt(r)&&w(e,n,u))return $(n,u,!0),e;e=t(e)}var f=e.elm,d=O.parentNode(f);if(a(n,u,f._leaveCb?null:d,O.nextSibling(f)),Dt(n.parent)){for(var v=n.parent;v;)v.elm=n.elm,v=v.parent;if(p(n))for(var h=0;h<k.create.length;++h)k.create[h](Qo,n.parent)}Dt(d)?g(d,[e],0,0):Dt(e.tag)&&m(e)}}return $(n,u,c),n.elm}}({nodeOps:Go,modules:Sa});Mi&&document.addEventListener("selectionchange",function(){var e=document.activeElement;e&&e.vmodel&&Gn(e,"input")});var ja={inserted:function(e,t,n){if("select"===n.tag){var r=function(){Jn(e,t,n.context)};r(),(Di||Pi)&&setTimeout(r,0)}else"textarea"!==n.tag&&"text"!==e.type&&"password"!==e.type||(e._vModifiers=t.modifiers,t.modifiers.lazy||(Ri||(e.addEventListener("compositionstart",Wn),e.addEventListener("compositionend",Zn)),Mi&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Jn(e,t,n.context);(e.multiple?t.value.some(function(t){return Kn(t,e.options)}):t.value!==t.oldValue&&Kn(t.value,e.options))&&Gn(e,"change")}}},Na={bind:function(e,t,n){var r=t.value;n=Yn(n);var i=n.data&&n.data.transition,o=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;r&&i&&!Mi?(n.data.show=!0,Hn(n,function(){e.style.display=o})):e.style.display=r?o:"none"},update:function(e,t,n){var r=t.value;r!==t.oldValue&&(n=Yn(n),n.data&&n.data.transition&&!Mi?(n.data.show=!0,r?Hn(n,function(){e.style.display=e.__vOriginalDisplay}):Un(n,function(){e.style.display="none"})):e.style.display=r?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,r,i){i||(e.style.display=e.__vOriginalDisplay)}},Ia={model:ja,show:Na},La={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]},Da={name:"transition",props:La,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(function(e){return e.tag}),n.length)){var r=this.mode,i=n[0];if(tr(this.$vnode))return i;var a=Qn(i);if(!a)return i;if(this._leaving)return er(e,i);var s="__transition-"+this._uid+"-";a.key=null==a.key?s+a.tag:o(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=Xn(this),l=this._vnode,f=Qn(l);if(a.data.directives&&a.data.directives.some(function(e){return"show"===e.name})&&(a.data.show=!0),f&&f.data&&!nr(a,f)){var p=f&&(f.data.transition=u({},c));if("out-in"===r)return this._leaving=!0,q(p,"afterLeave",function(){t._leaving=!1,t.$forceUpdate()}),er(e,i);if("in-out"===r){var d,v=function(){d()};q(c,"afterEnter",v),q(c,"enterCancelled",v),q(p,"delayLeave",function(e){d=e})}}return i}}},Ma=u({tag:String,moveClass:String},La);delete Ma.mode;var Pa={props:Ma,render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=Xn(this),s=0;s<i.length;s++){var c=i[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(o.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var p=r[f];p.data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):l.push(p)}this.kept=e(t,null,u),this.removed=l}return e(t,null,o)},beforeUpdate:function(){this.__patch__(this._vnode,this.kept,!1,!0),this._vnode=this.kept},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";if(e.length&&this.hasMove(e[0].elm,t)){e.forEach(rr),e.forEach(ir),e.forEach(or);var n=document.body;n.offsetHeight;e.forEach(function(e){if(e.data.moved){var n=e.elm,r=n.style;Ln(n,t),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(wa,n._moveCb=function e(r){r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(wa,e),n._moveCb=null,Dn(n,t))})}})}},methods:{hasMove:function(e,t){if(!ya)return!1;if(null!=this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach(function(e){jn(n,e)}),En(n,t),n.style.display="none",this.$el.appendChild(n);var r=Pn(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}},Ra={Transition:Da,TransitionGroup:Pa};nt.config.mustUseProp=Po,nt.config.isReservedTag=Wo,nt.config.getTagNamespace=yt,nt.config.isUnknownElement=_t,u(nt.options.directives,Ia),u(nt.options.components,Ra),nt.prototype.__patch__=Ii?Ea:d,nt.prototype.$mount=function(e,t){return e=e&&Ii?bt(e):void 0,ae(this,e,t)},setTimeout(function(){Si.devtools&&Bi&&Bi.emit("init",nt)},0);var Fa,Ha=!!Ii&&function(e,t){var n=document.createElement("div");return n.innerHTML='<div a="'+e+'">',n.innerHTML.indexOf(t)>0}("\n","&#10;"),Ua=n("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Ba=n("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Va=n("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),za=[/"([^"]*)"+/.source,/'([^']*)'+/.source,/([^\s"'=<>`]+)/.source],Ja=new RegExp("^\\s*"+/([^\s"'<>\/=]+)/.source+"(?:\\s*("+/(?:=)/.source+")\\s*(?:"+za.join("|")+"))?"),Ka="[a-zA-Z_][\\w\\-\\.]*",qa=new RegExp("^<((?:"+Ka+"\\:)?"+Ka+")"),Wa=/^\s*(\/?)>/,Za=new RegExp("^<\\/((?:"+Ka+"\\:)?"+Ka+")[^>]*>"),Ga=/^<!DOCTYPE [^>]+>/i,Ya=/^<!--/,Qa=/^<!\[/,Xa=!1;"x".replace(/x(.)?/g,function(e,t){Xa=""===t});var es,ts,ns,rs,is,os,as,ss,cs,us,ls,fs,ps,ds,vs,hs,ms,gs,ys=n("script,style,textarea",!0),_s={},bs={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n"},$s=/&(?:lt|gt|quot|amp);/g,ws=/&(?:lt|gt|quot|amp|#10);/g,xs=/\{\{((?:.|\n)+?)\}\}/g,Cs=a(function(e){var t=e[0].replace(/[-.*+?^${}()|[\]\/\\]/g,"\\$&"),n=e[1].replace(/[-.*+?^${}()|[\]\/\\]/g,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")}),ks=/^@|^v-on:/,As=/^v-|^@|^:/,Os=/(.*?)\s+(?:in|of)\s+(.*)/,Ts=/\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/,Ss=/:(.*)$/,Es=/^:|^v-bind:/,js=/\.[^.]+/g,Ns=a(ar),Is=/^xmlns:NS\d+/,Ls=/^NS\d+:/,Ds=a(Er),Ms=/^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/,Ps=/^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/,Rs={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Fs=function(e){return"if("+e+")return null;"},Hs={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:Fs("$event.target !== $event.currentTarget"),ctrl:Fs("!$event.ctrlKey"),shift:Fs("!$event.shiftKey"),alt:Fs("!$event.altKey"),meta:Fs("!$event.metaKey"),left:Fs("'button' in $event && $event.button !== 0"),middle:Fs("'button' in $event && $event.button !== 1"),right:Fs("'button' in $event && $event.button !== 2")},Us={bind:Hr,cloak:d},Bs={staticKeys:["staticClass"],transformNode:fi,genData:pi},Vs={staticKeys:["staticStyle"],transformNode:di,genData:vi},zs=[Bs,Vs],Js={model:dn,text:hi,html:mi},Ks={expectHTML:!0,modules:zs,directives:Js,isPreTag:qo,isUnaryTag:Ua,mustUseProp:Po,canBeLeftOpenTag:Ba,isReservedTag:Wo,getTagNamespace:yt,staticKeys:function(e){return e.reduce(function(e,t){return e.concat(t.staticKeys||[])},[]).join(",")}(zs)},qs=function(e){function t(t,n){var r=Object.create(e),i=[],o=[];if(r.warn=function(e,t){(t?o:i).push(e)},n){n.modules&&(r.modules=(e.modules||[]).concat(n.modules)),n.directives&&(r.directives=u(Object.create(e.directives),n.directives));for(var a in n)"modules"!==a&&"directives"!==a&&(r[a]=n[a])}var s=ui(t,r);return s.errors=i,s.tips=o,s}function n(e,n,i){n=n||{};var o=n.delimiters?String(n.delimiters)+e:e;if(r[o])return r[o];var a=t(e,n),s={},c=[];s.render=li(a.render,c);var u=a.staticRenderFns.length;s.staticRenderFns=new Array(u);for(var l=0;l<u;l++)s.staticRenderFns[l]=li(a.staticRenderFns[l],c);return r[o]=s}var r=Object.create(null);return{compile:t,compileToFunctions:n}}(Ks),Ws=qs.compileToFunctions,Zs=a(function(e){var t=bt(e);return t&&t.innerHTML}),Gs=nt.prototype.$mount;return nt.prototype.$mount=function(e,t){if((e=e&&bt(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var r=n.template;if(r)if("string"==typeof r)"#"===r.charAt(0)&&(r=Zs(r));else{if(!r.nodeType)return this;r=r.innerHTML}else e&&(r=gi(e));if(r){var i=Ws(r,{shouldDecodeNewlines:Ha,delimiters:n.delimiters},this),o=i.render,a=i.staticRenderFns;n.render=o,n.staticRenderFns=a}}return Gs.call(this,e,t)},nt.compile=Ws,nt});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(4)

	/* script */
	__vue_exports__ = __webpack_require__(9)

	/* template */
	var __vue_template__ = __webpack_require__(21)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\App.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-25341117", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-25341117", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] App.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(5);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../node_modules/.0.25.0@css-loader/index.js!../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-25341117!../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./App.vue", function() {
				var newContent = require("!!../../node_modules/.0.25.0@css-loader/index.js!../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-25341117!../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./App.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports
	exports.i(__webpack_require__(7), "");

	// module
	exports.push([module.id, "\n.active{\n\t\tcolor: orange;\n}\n.highcharts-tooltip {\n\t  \tbackground: #f1375e;\n}\n.highcharts-tooltip p {\n\t    font-size: 0.5rem;\n\t    color: #fff;\n}\n.highcharts-axis path{\n\t\tstroke: #4b425a;\n}\n.highcharts-series-group {\n\t\t-webkit-transform: translateZ(0);\n\t\ttransform: translateZ(0);\n}\n\t\n\n\t/*\n\t*   过渡动画\n\t*/\n\t\n\t/*#app{\n\t\tposition: relative;\n\t}\n\t#app>div{\n\t\t\twidth: 100%; \n\t\t\tposition: absolute;\n\t}\n\t.slide-enter-active {\n \t\ttransition: all .3s cubic-bezier(0,0,0.25,1);\n \t\ttransform: translateX(0);\n\t}\n \n\t.slide-leave-active {\n \t\ttransition: all .3s cubic-bezier(0,0,0.25,1);\n \t\ttransform: translateX(-100%);\n\t}\n \n\t.slide-enter {\n \t\ttransform: translateX(100%);\n\t}\n \n\t.slide-leave {\n \t\ttransform: translateX(100%);\n\t}*/\n\t\n", ""]);

	// exports


/***/ }),
/* 6 */
/***/ (function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function() {
		var list = [];

		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for(var i = 0; i < this.length; i++) {
				var item = this[i];
				if(item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};

		// import a list of modules into the list
		list.i = function(modules, mediaQuery) {
			if(typeof modules === "string")
				modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for(var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if(typeof id === "number")
					alreadyImportedModules[id] = true;
			}
			for(i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if(mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if(mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "@charset 'UTF-8';html{color:#000;background:#fff;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}article,aside,blockquote,body,button,code,dd,details,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,hr,input,legend,li,menu,nav,ol,p,pre,section,td,textarea,th,ul{margin:0;padding:0}input,select,textarea{font-size:100%}input{-webkit-appearance:none}table{border-collapse:collapse;border-spacing:0}fieldset,img{border:0}abbr,acronym{border:0;font-variant:normal}del{text-decoration:line-through}address,caption,cite,code,dfn,em,th,var{font-style:normal;font-weight:500}ol,ul{list-style:none}caption,th{text-align:left}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:400}q:after,q:before{content:''}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}a,ins{text-decoration:none}html{-webkit-tap-highlight-color:transparent}body,html{font-family:sans-serif}body{font-size:.6rem}.clearfix:after,.clearfix:before{content:' ';display:table}.clearfix:after{clear:both}*{-webkit-box-sizing:border-box;box-sizing:border-box}", ""]);

	// exports


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];

	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}

		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();

		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

		var styles = listToStyles(list);
		addStylesToDom(styles, options);

		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}

	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}

	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}

	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}

	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}

	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}

	function addStyle(obj, options) {
		var styleElement, update, remove;

		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}

		update(obj);

		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}

	var replaceText = (function () {
		var textStore = [];

		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();

	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}

	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
		var sourceMap = obj.sourceMap;

		if (media) {
			styleElement.setAttribute("media", media);
		}

		if (sourceMap) {
			// https://developer.chrome.com/devtools/docs/javascript-debugging
			// this makes source maps inside style tags work properly in Chrome
			css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */';
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}

		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _footer = __webpack_require__(10);

	var _footer2 = _interopRequireDefault(_footer);

	var _header = __webpack_require__(15);

	var _header2 = _interopRequireDefault(_header);

	var _vuex = __webpack_require__(20);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		name: 'app',
		data: function data() {
			return {
				msg: 'ys',
				Stomp: '',
				body: '',
				symbolPrice: ''
			};
		},

		methods: {
			zeptoAjax: function zeptoAjax() {
				$.ajax({
					url: 'http://newapi.invhero.com/v1/user/hongbao?access_token=d4ea901c-66d4-404f-ae2b-ed5220bbdd32&_f=0.4152040680259623',
					success: function success(data) {
						// console.log(data)
					}
				});
			}
		},
		mounted: function mounted() {
			console.log('App挂在完毕！');
		},
		created: function created() {
			this.$store.dispatch('getStompCurrentPrice');
			this.$store.dispatch('getAccount');
		},

		components: {
			myFooter: _footer2.default,
			myHeader: _header2.default
		}
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(11)

	/* template */
	var __vue_template__ = __webpack_require__(14)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\footer.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-96323892", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-96323892", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] footer.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(12);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-96323892!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./footer.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-96323892!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./footer.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\nfooter {\n  display: flex;\n  display: -webkit-flex;\n  position: fixed;\n  width: 16rem;\n  height: 2.25rem;\n  bottom: -0.025rem;\n  right: 0rem;\n  left: 0rem;\n  font-size: 0.65rem;\n  background-color: #160E23;\n  justify-content: space-around;\n  align-items: center;\n}\nfooter a {\n  position: relative;\n  color: #fff;\n  padding-top: 1rem;\n}\nfooter a .name {\n  font-size: 0.45rem;\n  color: #807691;\n  padding-left: 0.075rem;\n}\nfooter a .icon {\n  position: absolute;\n  width: 1.25rem;\n  height: 1.25rem;\n  background: url(" + __webpack_require__(13) + ") 0 0 no-repeat;\n  background-position: 0rem -24.05rem;\n  background-size: 10rem 37.5rem;\n  top: 0rem;\n  left: 0rem;\n}\nfooter a:nth-child(2) .icon {\n  background-position: 0rem -24.05rem;\n}\nfooter a:last-child .icon {\n  background-position: 0rem -20.4rem;\n  left: -0.25rem;\n}\n", ""]);

	// exports


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "../img/bg-icon.png?f6fb06e";

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('footer', {
	    staticClass: "footer"
	  }, [_c('router-link', {
	    attrs: {
	      "to": "/option"
	    }
	  }, [_c('span', {
	    staticClass: "icon"
	  }), _vm._v(" "), _c('span', {
	    staticClass: "name"
	  }, [_vm._v("主页")])]), _vm._v(" "), _c('router-link', {
	    attrs: {
	      "to": "/discover"
	    }
	  }, [_c('span', {
	    staticClass: "icon"
	  }), _vm._v(" "), _c('span', {
	    staticClass: "name"
	  }, [_vm._v("发现")])]), _vm._v(" "), _c('router-link', {
	    attrs: {
	      "to": "/my"
	    }
	  }, [_c('span', {
	    staticClass: "icon"
	  }), _vm._v(" "), _c('span', {
	    staticClass: "name"
	  }, [_vm._v("我")])])], 1)
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-96323892", module.exports)
	  }
	}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(16)

	/* script */
	__vue_exports__ = __webpack_require__(18)

	/* template */
	var __vue_template__ = __webpack_require__(19)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\header.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-53cd70ae"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-53cd70ae", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-53cd70ae", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] header.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(17);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-53cd70ae&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./header.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-53cd70ae&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./header.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\nheader[data-v-53cd70ae] {\n  position: absolute;\n  top: 0rem;\n  width: 16rem;\n  height: 2rem;\n  background: #967BDC;\n  text-align: center;\n  line-height: 2rem;\n  margin-bottom: 2rem;\n  z-index: 5;\n}\nheader .header-inner[data-v-53cd70ae] {\n  position: relative;\n  padding: 0rem 0.5rem;\n}\nheader .page-title[data-v-53cd70ae] {\n  width: 100%;\n  color: #fff;\n  font-size: 0.8rem;\n  font-weight: 400;\n  display: inline-block;\n}\nheader .go-back[data-v-53cd70ae] {\n  position: absolute;\n  float: left;\n}\nheader .right-icon[data-v-53cd70ae] {\n  position: absolute;\n  top: 0rem;\n  right: 0.5rem;\n  display: inline-block;\n  float: right;\n  text-decoration: none;\n}\n", ""]);

	// exports


/***/ }),
/* 18 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		data: function data() {
			return {};
		},
		mounted: function mounted() {},


		props: ['pageTitle']
	};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('header', [_c('div', {
	    staticClass: "header-inner"
	  }, [_vm._t("icon-logo"), _vm._v(" "), _c('div', {
	    staticClass: "page-title",
	    attrs: {
	      "if": _vm.pageTitle
	    }
	  }, [_vm._v(_vm._s(_vm.pageTitle))]), _vm._v(" "), _vm._t("right-icon")], 2)])
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-53cd70ae", module.exports)
	  }
	}

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	/**
	 * vuex v2.3.0
	 * (c) 2017 Evan You
	 * @license MIT
	 */
	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.Vuex = factory());
	}(this, (function () { 'use strict';

	var applyMixin = function (Vue) {
	  var version = Number(Vue.version.split('.')[0]);

	  if (version >= 2) {
	    var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1;
	    Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit });
	  } else {
	    // override init and inject vuex init procedure
	    // for 1.x backwards compatibility.
	    var _init = Vue.prototype._init;
	    Vue.prototype._init = function (options) {
	      if ( options === void 0 ) options = {};

	      options.init = options.init
	        ? [vuexInit].concat(options.init)
	        : vuexInit;
	      _init.call(this, options);
	    };
	  }

	  /**
	   * Vuex init hook, injected into each instances init hooks list.
	   */

	  function vuexInit () {
	    var options = this.$options;
	    // store injection
	    if (options.store) {
	      this.$store = options.store;
	    } else if (options.parent && options.parent.$store) {
	      this.$store = options.parent.$store;
	    }
	  }
	};

	var devtoolHook =
	  typeof window !== 'undefined' &&
	  window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

	function devtoolPlugin (store) {
	  if (!devtoolHook) { return }

	  store._devtoolHook = devtoolHook;

	  devtoolHook.emit('vuex:init', store);

	  devtoolHook.on('vuex:travel-to-state', function (targetState) {
	    store.replaceState(targetState);
	  });

	  store.subscribe(function (mutation, state) {
	    devtoolHook.emit('vuex:mutation', mutation, state);
	  });
	}

	/**
	 * Get the first item that pass the test
	 * by second argument function
	 *
	 * @param {Array} list
	 * @param {Function} f
	 * @return {*}
	 */
	/**
	 * Deep copy the given object considering circular structure.
	 * This function caches all nested objects and its copies.
	 * If it detects circular structure, use cached copy to avoid infinite loop.
	 *
	 * @param {*} obj
	 * @param {Array<Object>} cache
	 * @return {*}
	 */


	/**
	 * forEach for object
	 */
	function forEachValue (obj, fn) {
	  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
	}

	function isObject (obj) {
	  return obj !== null && typeof obj === 'object'
	}

	function isPromise (val) {
	  return val && typeof val.then === 'function'
	}

	function assert (condition, msg) {
	  if (!condition) { throw new Error(("[vuex] " + msg)) }
	}

	var Module = function Module (rawModule, runtime) {
	  this.runtime = runtime;
	  this._children = Object.create(null);
	  this._rawModule = rawModule;
	  var rawState = rawModule.state;
	  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
	};

	var prototypeAccessors$1 = { namespaced: {} };

	prototypeAccessors$1.namespaced.get = function () {
	  return !!this._rawModule.namespaced
	};

	Module.prototype.addChild = function addChild (key, module) {
	  this._children[key] = module;
	};

	Module.prototype.removeChild = function removeChild (key) {
	  delete this._children[key];
	};

	Module.prototype.getChild = function getChild (key) {
	  return this._children[key]
	};

	Module.prototype.update = function update (rawModule) {
	  this._rawModule.namespaced = rawModule.namespaced;
	  if (rawModule.actions) {
	    this._rawModule.actions = rawModule.actions;
	  }
	  if (rawModule.mutations) {
	    this._rawModule.mutations = rawModule.mutations;
	  }
	  if (rawModule.getters) {
	    this._rawModule.getters = rawModule.getters;
	  }
	};

	Module.prototype.forEachChild = function forEachChild (fn) {
	  forEachValue(this._children, fn);
	};

	Module.prototype.forEachGetter = function forEachGetter (fn) {
	  if (this._rawModule.getters) {
	    forEachValue(this._rawModule.getters, fn);
	  }
	};

	Module.prototype.forEachAction = function forEachAction (fn) {
	  if (this._rawModule.actions) {
	    forEachValue(this._rawModule.actions, fn);
	  }
	};

	Module.prototype.forEachMutation = function forEachMutation (fn) {
	  if (this._rawModule.mutations) {
	    forEachValue(this._rawModule.mutations, fn);
	  }
	};

	Object.defineProperties( Module.prototype, prototypeAccessors$1 );

	var ModuleCollection = function ModuleCollection (rawRootModule) {
	  var this$1 = this;

	  // register root module (Vuex.Store options)
	  this.root = new Module(rawRootModule, false);

	  // register all nested modules
	  if (rawRootModule.modules) {
	    forEachValue(rawRootModule.modules, function (rawModule, key) {
	      this$1.register([key], rawModule, false);
	    });
	  }
	};

	ModuleCollection.prototype.get = function get (path) {
	  return path.reduce(function (module, key) {
	    return module.getChild(key)
	  }, this.root)
	};

	ModuleCollection.prototype.getNamespace = function getNamespace (path) {
	  var module = this.root;
	  return path.reduce(function (namespace, key) {
	    module = module.getChild(key);
	    return namespace + (module.namespaced ? key + '/' : '')
	  }, '')
	};

	ModuleCollection.prototype.update = function update$1 (rawRootModule) {
	  update(this.root, rawRootModule);
	};

	ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
	    var this$1 = this;
	    if ( runtime === void 0 ) runtime = true;

	  var parent = this.get(path.slice(0, -1));
	  var newModule = new Module(rawModule, runtime);
	  parent.addChild(path[path.length - 1], newModule);

	  // register nested modules
	  if (rawModule.modules) {
	    forEachValue(rawModule.modules, function (rawChildModule, key) {
	      this$1.register(path.concat(key), rawChildModule, runtime);
	    });
	  }
	};

	ModuleCollection.prototype.unregister = function unregister (path) {
	  var parent = this.get(path.slice(0, -1));
	  var key = path[path.length - 1];
	  if (!parent.getChild(key).runtime) { return }

	  parent.removeChild(key);
	};

	function update (targetModule, newModule) {
	  // update target module
	  targetModule.update(newModule);

	  // update nested modules
	  if (newModule.modules) {
	    for (var key in newModule.modules) {
	      if (!targetModule.getChild(key)) {
	        console.warn(
	          "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
	          'manual reload is needed'
	        );
	        return
	      }
	      update(targetModule.getChild(key), newModule.modules[key]);
	    }
	  }
	}

	var Vue; // bind on install

	var Store = function Store (options) {
	  var this$1 = this;
	  if ( options === void 0 ) options = {};

	  assert(Vue, "must call Vue.use(Vuex) before creating a store instance.");
	  assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");

	  var state = options.state; if ( state === void 0 ) state = {};
	  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
	  var strict = options.strict; if ( strict === void 0 ) strict = false;

	  // store internal state
	  this._committing = false;
	  this._actions = Object.create(null);
	  this._mutations = Object.create(null);
	  this._wrappedGetters = Object.create(null);
	  this._modules = new ModuleCollection(options);
	  this._modulesNamespaceMap = Object.create(null);
	  this._subscribers = [];
	  this._watcherVM = new Vue();

	  // bind commit and dispatch to self
	  var store = this;
	  var ref = this;
	  var dispatch = ref.dispatch;
	  var commit = ref.commit;
	  this.dispatch = function boundDispatch (type, payload) {
	    return dispatch.call(store, type, payload)
	  };
	  this.commit = function boundCommit (type, payload, options) {
	    return commit.call(store, type, payload, options)
	  };

	  // strict mode
	  this.strict = strict;

	  // init root module.
	  // this also recursively registers all sub-modules
	  // and collects all module getters inside this._wrappedGetters
	  installModule(this, state, [], this._modules.root);

	  // initialize the store vm, which is responsible for the reactivity
	  // (also registers _wrappedGetters as computed properties)
	  resetStoreVM(this, state);

	  // apply plugins
	  plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); });
	};

	var prototypeAccessors = { state: {} };

	prototypeAccessors.state.get = function () {
	  return this._vm._data.$$state
	};

	prototypeAccessors.state.set = function (v) {
	  assert(false, "Use store.replaceState() to explicit replace store state.");
	};

	Store.prototype.commit = function commit (_type, _payload, _options) {
	    var this$1 = this;

	  // check object-style commit
	  var ref = unifyObjectStyle(_type, _payload, _options);
	    var type = ref.type;
	    var payload = ref.payload;
	    var options = ref.options;

	  var mutation = { type: type, payload: payload };
	  var entry = this._mutations[type];
	  if (!entry) {
	    console.error(("[vuex] unknown mutation type: " + type));
	    return
	  }
	  this._withCommit(function () {
	    entry.forEach(function commitIterator (handler) {
	      handler(payload);
	    });
	  });
	  this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); });

	  if (options && options.silent) {
	    console.warn(
	      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
	      'Use the filter functionality in the vue-devtools'
	    );
	  }
	};

	Store.prototype.dispatch = function dispatch (_type, _payload) {
	  // check object-style dispatch
	  var ref = unifyObjectStyle(_type, _payload);
	    var type = ref.type;
	    var payload = ref.payload;

	  var entry = this._actions[type];
	  if (!entry) {
	    console.error(("[vuex] unknown action type: " + type));
	    return
	  }
	  return entry.length > 1
	    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
	    : entry[0](payload)
	};

	Store.prototype.subscribe = function subscribe (fn) {
	  var subs = this._subscribers;
	  if (subs.indexOf(fn) < 0) {
	    subs.push(fn);
	  }
	  return function () {
	    var i = subs.indexOf(fn);
	    if (i > -1) {
	      subs.splice(i, 1);
	    }
	  }
	};

	Store.prototype.watch = function watch (getter, cb, options) {
	    var this$1 = this;

	  assert(typeof getter === 'function', "store.watch only accepts a function.");
	  return this._watcherVM.$watch(function () { return getter(this$1.state, this$1.getters); }, cb, options)
	};

	Store.prototype.replaceState = function replaceState (state) {
	    var this$1 = this;

	  this._withCommit(function () {
	    this$1._vm._data.$$state = state;
	  });
	};

	Store.prototype.registerModule = function registerModule (path, rawModule) {
	  if (typeof path === 'string') { path = [path]; }
	  assert(Array.isArray(path), "module path must be a string or an Array.");
	  this._modules.register(path, rawModule);
	  installModule(this, this.state, path, this._modules.get(path));
	  // reset store to update getters...
	  resetStoreVM(this, this.state);
	};

	Store.prototype.unregisterModule = function unregisterModule (path) {
	    var this$1 = this;

	  if (typeof path === 'string') { path = [path]; }
	  assert(Array.isArray(path), "module path must be a string or an Array.");
	  this._modules.unregister(path);
	  this._withCommit(function () {
	    var parentState = getNestedState(this$1.state, path.slice(0, -1));
	    Vue.delete(parentState, path[path.length - 1]);
	  });
	  resetStore(this);
	};

	Store.prototype.hotUpdate = function hotUpdate (newOptions) {
	  this._modules.update(newOptions);
	  resetStore(this, true);
	};

	Store.prototype._withCommit = function _withCommit (fn) {
	  var committing = this._committing;
	  this._committing = true;
	  fn();
	  this._committing = committing;
	};

	Object.defineProperties( Store.prototype, prototypeAccessors );

	function resetStore (store, hot) {
	  store._actions = Object.create(null);
	  store._mutations = Object.create(null);
	  store._wrappedGetters = Object.create(null);
	  store._modulesNamespaceMap = Object.create(null);
	  var state = store.state;
	  // init all modules
	  installModule(store, state, [], store._modules.root, true);
	  // reset vm
	  resetStoreVM(store, state, hot);
	}

	function resetStoreVM (store, state, hot) {
	  var oldVm = store._vm;

	  // bind store public getters
	  store.getters = {};
	  var wrappedGetters = store._wrappedGetters;
	  var computed = {};
	  forEachValue(wrappedGetters, function (fn, key) {
	    // use computed to leverage its lazy-caching mechanism
	    computed[key] = function () { return fn(store); };
	    Object.defineProperty(store.getters, key, {
	      get: function () { return store._vm[key]; },
	      enumerable: true // for local getters
	    });
	  });

	  // use a Vue instance to store the state tree
	  // suppress warnings just in case the user has added
	  // some funky global mixins
	  var silent = Vue.config.silent;
	  Vue.config.silent = true;
	  store._vm = new Vue({
	    data: {
	      $$state: state
	    },
	    computed: computed
	  });
	  Vue.config.silent = silent;

	  // enable strict mode for new vm
	  if (store.strict) {
	    enableStrictMode(store);
	  }

	  if (oldVm) {
	    if (hot) {
	      // dispatch changes in all subscribed watchers
	      // to force getter re-evaluation for hot reloading.
	      store._withCommit(function () {
	        oldVm._data.$$state = null;
	      });
	    }
	    Vue.nextTick(function () { return oldVm.$destroy(); });
	  }
	}

	function installModule (store, rootState, path, module, hot) {
	  var isRoot = !path.length;
	  var namespace = store._modules.getNamespace(path);

	  // register in namespace map
	  if (module.namespaced) {
	    store._modulesNamespaceMap[namespace] = module;
	  }

	  // set state
	  if (!isRoot && !hot) {
	    var parentState = getNestedState(rootState, path.slice(0, -1));
	    var moduleName = path[path.length - 1];
	    store._withCommit(function () {
	      Vue.set(parentState, moduleName, module.state);
	    });
	  }

	  var local = module.context = makeLocalContext(store, namespace, path);

	  module.forEachMutation(function (mutation, key) {
	    var namespacedType = namespace + key;
	    registerMutation(store, namespacedType, mutation, local);
	  });

	  module.forEachAction(function (action, key) {
	    var namespacedType = namespace + key;
	    registerAction(store, namespacedType, action, local);
	  });

	  module.forEachGetter(function (getter, key) {
	    var namespacedType = namespace + key;
	    registerGetter(store, namespacedType, getter, local);
	  });

	  module.forEachChild(function (child, key) {
	    installModule(store, rootState, path.concat(key), child, hot);
	  });
	}

	/**
	 * make localized dispatch, commit, getters and state
	 * if there is no namespace, just use root ones
	 */
	function makeLocalContext (store, namespace, path) {
	  var noNamespace = namespace === '';

	  var local = {
	    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
	      var args = unifyObjectStyle(_type, _payload, _options);
	      var payload = args.payload;
	      var options = args.options;
	      var type = args.type;

	      if (!options || !options.root) {
	        type = namespace + type;
	        if (!store._actions[type]) {
	          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
	          return
	        }
	      }

	      return store.dispatch(type, payload)
	    },

	    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
	      var args = unifyObjectStyle(_type, _payload, _options);
	      var payload = args.payload;
	      var options = args.options;
	      var type = args.type;

	      if (!options || !options.root) {
	        type = namespace + type;
	        if (!store._mutations[type]) {
	          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
	          return
	        }
	      }

	      store.commit(type, payload, options);
	    }
	  };

	  // getters and state object must be gotten lazily
	  // because they will be changed by vm update
	  Object.defineProperties(local, {
	    getters: {
	      get: noNamespace
	        ? function () { return store.getters; }
	        : function () { return makeLocalGetters(store, namespace); }
	    },
	    state: {
	      get: function () { return getNestedState(store.state, path); }
	    }
	  });

	  return local
	}

	function makeLocalGetters (store, namespace) {
	  var gettersProxy = {};

	  var splitPos = namespace.length;
	  Object.keys(store.getters).forEach(function (type) {
	    // skip if the target getter is not match this namespace
	    if (type.slice(0, splitPos) !== namespace) { return }

	    // extract local getter type
	    var localType = type.slice(splitPos);

	    // Add a port to the getters proxy.
	    // Define as getter property because
	    // we do not want to evaluate the getters in this time.
	    Object.defineProperty(gettersProxy, localType, {
	      get: function () { return store.getters[type]; },
	      enumerable: true
	    });
	  });

	  return gettersProxy
	}

	function registerMutation (store, type, handler, local) {
	  var entry = store._mutations[type] || (store._mutations[type] = []);
	  entry.push(function wrappedMutationHandler (payload) {
	    handler(local.state, payload);
	  });
	}

	function registerAction (store, type, handler, local) {
	  var entry = store._actions[type] || (store._actions[type] = []);
	  entry.push(function wrappedActionHandler (payload, cb) {
	    var res = handler({
	      dispatch: local.dispatch,
	      commit: local.commit,
	      getters: local.getters,
	      state: local.state,
	      rootGetters: store.getters,
	      rootState: store.state
	    }, payload, cb);
	    if (!isPromise(res)) {
	      res = Promise.resolve(res);
	    }
	    if (store._devtoolHook) {
	      return res.catch(function (err) {
	        store._devtoolHook.emit('vuex:error', err);
	        throw err
	      })
	    } else {
	      return res
	    }
	  });
	}

	function registerGetter (store, type, rawGetter, local) {
	  if (store._wrappedGetters[type]) {
	    console.error(("[vuex] duplicate getter key: " + type));
	    return
	  }
	  store._wrappedGetters[type] = function wrappedGetter (store) {
	    return rawGetter(
	      local.state, // local state
	      local.getters, // local getters
	      store.state, // root state
	      store.getters // root getters
	    )
	  };
	}

	function enableStrictMode (store) {
	  store._vm.$watch(function () { return this._data.$$state }, function () {
	    assert(store._committing, "Do not mutate vuex store state outside mutation handlers.");
	  }, { deep: true, sync: true });
	}

	function getNestedState (state, path) {
	  return path.length
	    ? path.reduce(function (state, key) { return state[key]; }, state)
	    : state
	}

	function unifyObjectStyle (type, payload, options) {
	  if (isObject(type) && type.type) {
	    options = payload;
	    payload = type;
	    type = type.type;
	  }

	  assert(typeof type === 'string', ("Expects string as the type, but found " + (typeof type) + "."));

	  return { type: type, payload: payload, options: options }
	}

	function install (_Vue) {
	  if (Vue) {
	    console.error(
	      '[vuex] already installed. Vue.use(Vuex) should be called only once.'
	    );
	    return
	  }
	  Vue = _Vue;
	  applyMixin(Vue);
	}

	// auto install in dist mode
	if (typeof window !== 'undefined' && window.Vue) {
	  install(window.Vue);
	}

	var mapState = normalizeNamespace(function (namespace, states) {
	  var res = {};
	  normalizeMap(states).forEach(function (ref) {
	    var key = ref.key;
	    var val = ref.val;

	    res[key] = function mappedState () {
	      var state = this.$store.state;
	      var getters = this.$store.getters;
	      if (namespace) {
	        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
	        if (!module) {
	          return
	        }
	        state = module.context.state;
	        getters = module.context.getters;
	      }
	      return typeof val === 'function'
	        ? val.call(this, state, getters)
	        : state[val]
	    };
	    // mark vuex getter for devtools
	    res[key].vuex = true;
	  });
	  return res
	});

	var mapMutations = normalizeNamespace(function (namespace, mutations) {
	  var res = {};
	  normalizeMap(mutations).forEach(function (ref) {
	    var key = ref.key;
	    var val = ref.val;

	    val = namespace + val;
	    res[key] = function mappedMutation () {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	      if (namespace && !getModuleByNamespace(this.$store, 'mapMutations', namespace)) {
	        return
	      }
	      return this.$store.commit.apply(this.$store, [val].concat(args))
	    };
	  });
	  return res
	});

	var mapGetters = normalizeNamespace(function (namespace, getters) {
	  var res = {};
	  normalizeMap(getters).forEach(function (ref) {
	    var key = ref.key;
	    var val = ref.val;

	    val = namespace + val;
	    res[key] = function mappedGetter () {
	      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
	        return
	      }
	      if (!(val in this.$store.getters)) {
	        console.error(("[vuex] unknown getter: " + val));
	        return
	      }
	      return this.$store.getters[val]
	    };
	    // mark vuex getter for devtools
	    res[key].vuex = true;
	  });
	  return res
	});

	var mapActions = normalizeNamespace(function (namespace, actions) {
	  var res = {};
	  normalizeMap(actions).forEach(function (ref) {
	    var key = ref.key;
	    var val = ref.val;

	    val = namespace + val;
	    res[key] = function mappedAction () {
	      var args = [], len = arguments.length;
	      while ( len-- ) args[ len ] = arguments[ len ];

	      if (namespace && !getModuleByNamespace(this.$store, 'mapActions', namespace)) {
	        return
	      }
	      return this.$store.dispatch.apply(this.$store, [val].concat(args))
	    };
	  });
	  return res
	});

	function normalizeMap (map) {
	  return Array.isArray(map)
	    ? map.map(function (key) { return ({ key: key, val: key }); })
	    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
	}

	function normalizeNamespace (fn) {
	  return function (namespace, map) {
	    if (typeof namespace !== 'string') {
	      map = namespace;
	      namespace = '';
	    } else if (namespace.charAt(namespace.length - 1) !== '/') {
	      namespace += '/';
	    }
	    return fn(namespace, map)
	  }
	}

	function getModuleByNamespace (store, helper, namespace) {
	  var module = store._modulesNamespaceMap[namespace];
	  if (!module) {
	    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
	  }
	  return module
	}

	var index = {
	  Store: Store,
	  install: install,
	  version: '2.3.0',
	  mapState: mapState,
	  mapMutations: mapMutations,
	  mapGetters: mapGetters,
	  mapActions: mapActions
	};

	return index;

	})));


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    attrs: {
	      "id": "app"
	    }
	  }, [_c('transition', {
	    attrs: {
	      "name": "slide"
	    }
	  }, [_c('router-view')], 1)], 1)
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-25341117", module.exports)
	  }
	}

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _vue = __webpack_require__(2);

	var _vue2 = _interopRequireDefault(_vue);

	var _App = __webpack_require__(3);

	var _App2 = _interopRequireDefault(_App);

	var _vueRouter = __webpack_require__(23);

	var _vueRouter2 = _interopRequireDefault(_vueRouter);

	var _index = __webpack_require__(25);

	var _index2 = _interopRequireDefault(_index);

	var _home = __webpack_require__(30);

	var _home2 = _interopRequireDefault(_home);

	var _page = __webpack_require__(46);

	var _page2 = _interopRequireDefault(_page);

	var _optionList = __webpack_require__(50);

	var _optionList2 = _interopRequireDefault(_optionList);

	var _proTrading = __webpack_require__(55);

	var _proTrading2 = _interopRequireDefault(_proTrading);

	var _login = __webpack_require__(203);

	var _login2 = _interopRequireDefault(_login);

	var _curretOrder = __webpack_require__(210);

	var _curretOrder2 = _interopRequireDefault(_curretOrder);

	var _orderHistory = __webpack_require__(215);

	var _orderHistory2 = _interopRequireDefault(_orderHistory);

	var _discover = __webpack_require__(226);

	var _discover2 = _interopRequireDefault(_discover);

	var _my = __webpack_require__(237);

	var _my2 = _interopRequireDefault(_my);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//vue组件
	_vue2.default.use(_vueRouter2.default); /**
	                                         * Created by linhaifeng.
	                                         */

	var routes = [{
	    path: '', component: _login2.default
	}, {
	    path: '/login', component: _login2.default
	}, { path: '/my', component: _my2.default,
	    children: [{ path: '/my', name: 'my', component: _my2.default }

	    // { path: '/page1', name:'page1', component: Page1 },

	    // { path: '/home', name:'home', component: Home},

	    // { path: '/HomeUserInfo/:uid', name:'homeUserInfo', component: HomeUserInfo },

	    // { path:'/article/:id', name:'article', component : Article},

	    // { path:'/home/mypet', name:'myPet', component : MyPet},

	    // { path:'/home/mypet/addpet', name:'addPet', component : AddPet},

	    ]
	}, { path: '/home', component: _home2.default,
	    children: [{ path: '/option',
	        name: 'option',
	        component: _optionList2.default,
	        meta: {
	            requireAuth: true }
	    }, {
	        path: '/curretOrder',
	        name: 'curretOrder',
	        component: _curretOrder2.default
	    }, {
	        path: '/historyOrder',
	        name: 'historyOrder',
	        component: _orderHistory2.default
	    }]
	}, { path: '/discover', component: _discover2.default,
	    children: []
	}, { path: '/proTrading', component: _proTrading2.default,
	    children: []
	}];

	var router = new _vueRouter2.default({
	    //mode:'history', //这样url就没有/#/XXX,而是常见的url形式
	    routes: routes, // short for routes: routes
	    linkActiveClass: 'active', //router-link的选中状态的class，也有一个默认的值
	    history: true
	});

	exports.default = router;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	  * vue-router v2.4.0
	  * (c) 2017 Evan You
	  * @license MIT
	  */
	'use strict';

	/*  */

	function assert (condition, message) {
	  if (!condition) {
	    throw new Error(("[vue-router] " + message))
	  }
	}

	function warn (condition, message) {
	  if (process.env.NODE_ENV !== 'production' && !condition) {
	    typeof console !== 'undefined' && console.warn(("[vue-router] " + message));
	  }
	}

	var View = {
	  name: 'router-view',
	  functional: true,
	  props: {
	    name: {
	      type: String,
	      default: 'default'
	    }
	  },
	  render: function render (h, ref) {
	    var props = ref.props;
	    var children = ref.children;
	    var parent = ref.parent;
	    var data = ref.data;

	    data.routerView = true;

	    var name = props.name;
	    var route = parent.$route;
	    var cache = parent._routerViewCache || (parent._routerViewCache = {});

	    // determine current view depth, also check to see if the tree
	    // has been toggled inactive but kept-alive.
	    var depth = 0;
	    var inactive = false;
	    while (parent) {
	      if (parent.$vnode && parent.$vnode.data.routerView) {
	        depth++;
	      }
	      if (parent._inactive) {
	        inactive = true;
	      }
	      parent = parent.$parent;
	    }
	    data.routerViewDepth = depth;

	    // render previous view if the tree is inactive and kept-alive
	    if (inactive) {
	      return h(cache[name], data, children)
	    }

	    var matched = route.matched[depth];
	    // render empty node if no matched route
	    if (!matched) {
	      cache[name] = null;
	      return h()
	    }

	    var component = cache[name] = matched.components[name];

	    // attach instance registration hook
	    // this will be called in the instance's injected lifecycle hooks
	    data.registerRouteInstance = function (vm, val) {
	      // val could be undefined for unregistration
	      if (matched.instances[name] !== vm) {
	        matched.instances[name] = val;
	      }
	    };

	    // resolve props
	    data.props = resolveProps(route, matched.props && matched.props[name]);

	    return h(component, data, children)
	  }
	};

	function resolveProps (route, config) {
	  switch (typeof config) {
	    case 'undefined':
	      return
	    case 'object':
	      return config
	    case 'function':
	      return config(route)
	    case 'boolean':
	      return config ? route.params : undefined
	    default:
	      if (process.env.NODE_ENV !== 'production') {
	        warn(
	          false,
	          "props in \"" + (route.path) + "\" is a " + (typeof config) + ", " +
	          "expecting an object, function or boolean."
	        );
	      }
	  }
	}

	/*  */

	var encodeReserveRE = /[!'()*]/g;
	var encodeReserveReplacer = function (c) { return '%' + c.charCodeAt(0).toString(16); };
	var commaRE = /%2C/g;

	// fixed encodeURIComponent which is more conformant to RFC3986:
	// - escapes [!'()*]
	// - preserve commas
	var encode = function (str) { return encodeURIComponent(str)
	  .replace(encodeReserveRE, encodeReserveReplacer)
	  .replace(commaRE, ','); };

	var decode = decodeURIComponent;

	function resolveQuery (
	  query,
	  extraQuery,
	  _parseQuery
	) {
	  if ( extraQuery === void 0 ) extraQuery = {};

	  var parse = _parseQuery || parseQuery;
	  var parsedQuery;
	  try {
	    parsedQuery = parse(query || '');
	  } catch (e) {
	    process.env.NODE_ENV !== 'production' && warn(false, e.message);
	    parsedQuery = {};
	  }
	  for (var key in extraQuery) {
	    var val = extraQuery[key];
	    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;
	  }
	  return parsedQuery
	}

	function parseQuery (query) {
	  var res = {};

	  query = query.trim().replace(/^(\?|#|&)/, '');

	  if (!query) {
	    return res
	  }

	  query.split('&').forEach(function (param) {
	    var parts = param.replace(/\+/g, ' ').split('=');
	    var key = decode(parts.shift());
	    var val = parts.length > 0
	      ? decode(parts.join('='))
	      : null;

	    if (res[key] === undefined) {
	      res[key] = val;
	    } else if (Array.isArray(res[key])) {
	      res[key].push(val);
	    } else {
	      res[key] = [res[key], val];
	    }
	  });

	  return res
	}

	function stringifyQuery (obj) {
	  var res = obj ? Object.keys(obj).map(function (key) {
	    var val = obj[key];

	    if (val === undefined) {
	      return ''
	    }

	    if (val === null) {
	      return encode(key)
	    }

	    if (Array.isArray(val)) {
	      var result = [];
	      val.slice().forEach(function (val2) {
	        if (val2 === undefined) {
	          return
	        }
	        if (val2 === null) {
	          result.push(encode(key));
	        } else {
	          result.push(encode(key) + '=' + encode(val2));
	        }
	      });
	      return result.join('&')
	    }

	    return encode(key) + '=' + encode(val)
	  }).filter(function (x) { return x.length > 0; }).join('&') : null;
	  return res ? ("?" + res) : ''
	}

	/*  */


	var trailingSlashRE = /\/?$/;

	function createRoute (
	  record,
	  location,
	  redirectedFrom,
	  router
	) {
	  var stringifyQuery$$1 = router && router.options.stringifyQuery;
	  var route = {
	    name: location.name || (record && record.name),
	    meta: (record && record.meta) || {},
	    path: location.path || '/',
	    hash: location.hash || '',
	    query: location.query || {},
	    params: location.params || {},
	    fullPath: getFullPath(location, stringifyQuery$$1),
	    matched: record ? formatMatch(record) : []
	  };
	  if (redirectedFrom) {
	    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
	  }
	  return Object.freeze(route)
	}

	// the starting route that represents the initial state
	var START = createRoute(null, {
	  path: '/'
	});

	function formatMatch (record) {
	  var res = [];
	  while (record) {
	    res.unshift(record);
	    record = record.parent;
	  }
	  return res
	}

	function getFullPath (
	  ref,
	  _stringifyQuery
	) {
	  var path = ref.path;
	  var query = ref.query; if ( query === void 0 ) query = {};
	  var hash = ref.hash; if ( hash === void 0 ) hash = '';

	  var stringify = _stringifyQuery || stringifyQuery;
	  return (path || '/') + stringify(query) + hash
	}

	function isSameRoute (a, b) {
	  if (b === START) {
	    return a === b
	  } else if (!b) {
	    return false
	  } else if (a.path && b.path) {
	    return (
	      a.path.replace(trailingSlashRE, '') === b.path.replace(trailingSlashRE, '') &&
	      a.hash === b.hash &&
	      isObjectEqual(a.query, b.query)
	    )
	  } else if (a.name && b.name) {
	    return (
	      a.name === b.name &&
	      a.hash === b.hash &&
	      isObjectEqual(a.query, b.query) &&
	      isObjectEqual(a.params, b.params)
	    )
	  } else {
	    return false
	  }
	}

	function isObjectEqual (a, b) {
	  if ( a === void 0 ) a = {};
	  if ( b === void 0 ) b = {};

	  var aKeys = Object.keys(a);
	  var bKeys = Object.keys(b);
	  if (aKeys.length !== bKeys.length) {
	    return false
	  }
	  return aKeys.every(function (key) { return String(a[key]) === String(b[key]); })
	}

	function isIncludedRoute (current, target) {
	  return (
	    current.path.replace(trailingSlashRE, '/').indexOf(
	      target.path.replace(trailingSlashRE, '/')
	    ) === 0 &&
	    (!target.hash || current.hash === target.hash) &&
	    queryIncludes(current.query, target.query)
	  )
	}

	function queryIncludes (current, target) {
	  for (var key in target) {
	    if (!(key in current)) {
	      return false
	    }
	  }
	  return true
	}

	/*  */

	// work around weird flow bug
	var toTypes = [String, Object];
	var eventTypes = [String, Array];

	var Link = {
	  name: 'router-link',
	  props: {
	    to: {
	      type: toTypes,
	      required: true
	    },
	    tag: {
	      type: String,
	      default: 'a'
	    },
	    exact: Boolean,
	    append: Boolean,
	    replace: Boolean,
	    activeClass: {
	      type: String,
	      default: 'router-link-active'
	    },
	    event: {
	      type: eventTypes,
	      default: 'click'
	    }
	  },
	  render: function render (h) {
	    var this$1 = this;

	    var router = this.$router;
	    var current = this.$route;
	    var ref = router.resolve(this.to, current, this.append);
	    var location = ref.location;
	    var route = ref.route;
	    var href = ref.href;

	    var classes = {};
	    var globalActiveClass = router.options.linkActiveClass;
	    var activeClass = globalActiveClass == null
	      ? this.activeClass
	      : globalActiveClass;
	    var compareTarget = location.path
	      ? createRoute(null, location, null, router)
	      : route;

	    classes[activeClass] = this.exact
	      ? isSameRoute(current, compareTarget)
	      : isIncludedRoute(current, compareTarget);

	    var handler = function (e) {
	      if (guardEvent(e)) {
	        if (this$1.replace) {
	          router.replace(location);
	        } else {
	          router.push(location);
	        }
	      }
	    };

	    var on = { click: guardEvent };
	    if (Array.isArray(this.event)) {
	      this.event.forEach(function (e) { on[e] = handler; });
	    } else {
	      on[this.event] = handler;
	    }

	    var data = {
	      class: classes
	    };

	    if (this.tag === 'a') {
	      data.on = on;
	      data.attrs = { href: href };
	    } else {
	      // find the first <a> child and apply listener and href
	      var a = findAnchor(this.$slots.default);
	      if (a) {
	        // in case the <a> is a static node
	        a.isStatic = false;
	        var extend = _Vue.util.extend;
	        var aData = a.data = extend({}, a.data);
	        aData.on = on;
	        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
	        aAttrs.href = href;
	      } else {
	        // doesn't have <a> child, apply listener to self
	        data.on = on;
	      }
	    }

	    return h(this.tag, data, this.$slots.default)
	  }
	};

	function guardEvent (e) {
	  // don't redirect with control keys
	  if (e.metaKey || e.ctrlKey || e.shiftKey) { return }
	  // don't redirect when preventDefault called
	  if (e.defaultPrevented) { return }
	  // don't redirect on right click
	  if (e.button !== undefined && e.button !== 0) { return }
	  // don't redirect if `target="_blank"`
	  if (e.currentTarget && e.currentTarget.getAttribute) {
	    var target = e.currentTarget.getAttribute('target');
	    if (/\b_blank\b/i.test(target)) { return }
	  }
	  // this may be a Weex event which doesn't have this method
	  if (e.preventDefault) {
	    e.preventDefault();
	  }
	  return true
	}

	function findAnchor (children) {
	  if (children) {
	    var child;
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      if (child.tag === 'a') {
	        return child
	      }
	      if (child.children && (child = findAnchor(child.children))) {
	        return child
	      }
	    }
	  }
	}

	var _Vue;

	function install (Vue) {
	  if (install.installed) { return }
	  install.installed = true;

	  _Vue = Vue;

	  Object.defineProperty(Vue.prototype, '$router', {
	    get: function get () { return this.$root._router }
	  });

	  Object.defineProperty(Vue.prototype, '$route', {
	    get: function get () { return this.$root._route }
	  });

	  var isDef = function (v) { return v !== undefined; };

	  var registerInstance = function (vm, callVal) {
	    var i = vm.$options._parentVnode;
	    if (isDef(i) && isDef(i = i.data) && isDef(i = i.registerRouteInstance)) {
	      i(vm, callVal);
	    }
	  };

	  Vue.mixin({
	    beforeCreate: function beforeCreate () {
	      if (isDef(this.$options.router)) {
	        this._router = this.$options.router;
	        this._router.init(this);
	        Vue.util.defineReactive(this, '_route', this._router.history.current);
	      }
	      registerInstance(this, this);
	    },
	    destroyed: function destroyed () {
	      registerInstance(this);
	    }
	  });

	  Vue.component('router-view', View);
	  Vue.component('router-link', Link);

	  var strats = Vue.config.optionMergeStrategies;
	  // use the same hook merging strategy for route hooks
	  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
	}

	/*  */

	var inBrowser = typeof window !== 'undefined';

	/*  */

	function resolvePath (
	  relative,
	  base,
	  append
	) {
	  var firstChar = relative.charAt(0);
	  if (firstChar === '/') {
	    return relative
	  }

	  if (firstChar === '?' || firstChar === '#') {
	    return base + relative
	  }

	  var stack = base.split('/');

	  // remove trailing segment if:
	  // - not appending
	  // - appending to trailing slash (last segment is empty)
	  if (!append || !stack[stack.length - 1]) {
	    stack.pop();
	  }

	  // resolve relative path
	  var segments = relative.replace(/^\//, '').split('/');
	  for (var i = 0; i < segments.length; i++) {
	    var segment = segments[i];
	    if (segment === '..') {
	      stack.pop();
	    } else if (segment !== '.') {
	      stack.push(segment);
	    }
	  }

	  // ensure leading slash
	  if (stack[0] !== '') {
	    stack.unshift('');
	  }

	  return stack.join('/')
	}

	function parsePath (path) {
	  var hash = '';
	  var query = '';

	  var hashIndex = path.indexOf('#');
	  if (hashIndex >= 0) {
	    hash = path.slice(hashIndex);
	    path = path.slice(0, hashIndex);
	  }

	  var queryIndex = path.indexOf('?');
	  if (queryIndex >= 0) {
	    query = path.slice(queryIndex + 1);
	    path = path.slice(0, queryIndex);
	  }

	  return {
	    path: path,
	    query: query,
	    hash: hash
	  }
	}

	function cleanPath (path) {
	  return path.replace(/\/\//g, '/')
	}

	/*  */

	function createRouteMap (
	  routes,
	  oldPathMap,
	  oldNameMap
	) {
	  var pathMap = oldPathMap || Object.create(null);
	  var nameMap = oldNameMap || Object.create(null);

	  routes.forEach(function (route) {
	    addRouteRecord(pathMap, nameMap, route);
	  });

	  return {
	    pathMap: pathMap,
	    nameMap: nameMap
	  }
	}

	function addRouteRecord (
	  pathMap,
	  nameMap,
	  route,
	  parent,
	  matchAs
	) {
	  var path = route.path;
	  var name = route.name;
	  if (process.env.NODE_ENV !== 'production') {
	    assert(path != null, "\"path\" is required in a route configuration.");
	    assert(
	      typeof route.component !== 'string',
	      "route config \"component\" for path: " + (String(path || name)) + " cannot be a " +
	      "string id. Use an actual component instead."
	    );
	  }

	  var record = {
	    path: normalizePath(path, parent),
	    components: route.components || { default: route.component },
	    instances: {},
	    name: name,
	    parent: parent,
	    matchAs: matchAs,
	    redirect: route.redirect,
	    beforeEnter: route.beforeEnter,
	    meta: route.meta || {},
	    props: route.props == null
	      ? {}
	      : route.components
	        ? route.props
	        : { default: route.props }
	  };

	  if (route.children) {
	    // Warn if route is named and has a default child route.
	    // If users navigate to this route by name, the default child will
	    // not be rendered (GH Issue #629)
	    if (process.env.NODE_ENV !== 'production') {
	      if (route.name && route.children.some(function (child) { return /^\/?$/.test(child.path); })) {
	        warn(
	          false,
	          "Named Route '" + (route.name) + "' has a default child route. " +
	          "When navigating to this named route (:to=\"{name: '" + (route.name) + "'\"), " +
	          "the default child route will not be rendered. Remove the name from " +
	          "this route and use the name of the default child route for named " +
	          "links instead."
	        );
	      }
	    }
	    route.children.forEach(function (child) {
	      var childMatchAs = matchAs
	        ? cleanPath((matchAs + "/" + (child.path)))
	        : undefined;
	      addRouteRecord(pathMap, nameMap, child, record, childMatchAs);
	    });
	  }

	  if (route.alias !== undefined) {
	    if (Array.isArray(route.alias)) {
	      route.alias.forEach(function (alias) {
	        var aliasRoute = {
	          path: alias,
	          children: route.children
	        };
	        addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
	      });
	    } else {
	      var aliasRoute = {
	        path: route.alias,
	        children: route.children
	      };
	      addRouteRecord(pathMap, nameMap, aliasRoute, parent, record.path);
	    }
	  }

	  if (!pathMap[record.path]) {
	    pathMap[record.path] = record;
	  }

	  if (name) {
	    if (!nameMap[name]) {
	      nameMap[name] = record;
	    } else if (process.env.NODE_ENV !== 'production' && !matchAs) {
	      warn(
	        false,
	        "Duplicate named routes definition: " +
	        "{ name: \"" + name + "\", path: \"" + (record.path) + "\" }"
	      );
	    }
	  }
	}

	function normalizePath (path, parent) {
	  path = path.replace(/\/$/, '');
	  if (path[0] === '/') { return path }
	  if (parent == null) { return path }
	  return cleanPath(((parent.path) + "/" + path))
	}

	var index$1 = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};

	var isarray = index$1;

	/**
	 * Expose `pathToRegexp`.
	 */
	var index = pathToRegexp;
	var parse_1 = parse;
	var compile_1 = compile;
	var tokensToFunction_1 = tokensToFunction;
	var tokensToRegExp_1 = tokensToRegExp;

	/**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
	var PATH_REGEXP = new RegExp([
	  // Match escaped characters that would otherwise appear in future matches.
	  // This allows the user to escape special characters that won't transform.
	  '(\\\\.)',
	  // Match Express-style parameters and un-named parameters with a prefix
	  // and optional suffixes. Matches appear as:
	  //
	  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
	  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
	  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
	  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
	].join('|'), 'g');

	/**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {string}  str
	 * @param  {Object=} options
	 * @return {!Array}
	 */
	function parse (str, options) {
	  var tokens = [];
	  var key = 0;
	  var index = 0;
	  var path = '';
	  var defaultDelimiter = options && options.delimiter || '/';
	  var res;

	  while ((res = PATH_REGEXP.exec(str)) != null) {
	    var m = res[0];
	    var escaped = res[1];
	    var offset = res.index;
	    path += str.slice(index, offset);
	    index = offset + m.length;

	    // Ignore already escaped sequences.
	    if (escaped) {
	      path += escaped[1];
	      continue
	    }

	    var next = str[index];
	    var prefix = res[2];
	    var name = res[3];
	    var capture = res[4];
	    var group = res[5];
	    var modifier = res[6];
	    var asterisk = res[7];

	    // Push the current path onto the tokens.
	    if (path) {
	      tokens.push(path);
	      path = '';
	    }

	    var partial = prefix != null && next != null && next !== prefix;
	    var repeat = modifier === '+' || modifier === '*';
	    var optional = modifier === '?' || modifier === '*';
	    var delimiter = res[2] || defaultDelimiter;
	    var pattern = capture || group;

	    tokens.push({
	      name: name || key++,
	      prefix: prefix || '',
	      delimiter: delimiter,
	      optional: optional,
	      repeat: repeat,
	      partial: partial,
	      asterisk: !!asterisk,
	      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
	    });
	  }

	  // Match any characters still remaining.
	  if (index < str.length) {
	    path += str.substr(index);
	  }

	  // If the path exists, push it onto the end.
	  if (path) {
	    tokens.push(path);
	  }

	  return tokens
	}

	/**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {string}             str
	 * @param  {Object=}            options
	 * @return {!function(Object=, Object=)}
	 */
	function compile (str, options) {
	  return tokensToFunction(parse(str, options))
	}

	/**
	 * Prettier encoding of URI path segments.
	 *
	 * @param  {string}
	 * @return {string}
	 */
	function encodeURIComponentPretty (str) {
	  return encodeURI(str).replace(/[\/?#]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}

	/**
	 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
	 *
	 * @param  {string}
	 * @return {string}
	 */
	function encodeAsterisk (str) {
	  return encodeURI(str).replace(/[?#]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}

	/**
	 * Expose a method for transforming tokens into the path function.
	 */
	function tokensToFunction (tokens) {
	  // Compile all the tokens into regexps.
	  var matches = new Array(tokens.length);

	  // Compile all the patterns before compilation.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] === 'object') {
	      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');
	    }
	  }

	  return function (obj, opts) {
	    var path = '';
	    var data = obj || {};
	    var options = opts || {};
	    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i];

	      if (typeof token === 'string') {
	        path += token;

	        continue
	      }

	      var value = data[token.name];
	      var segment;

	      if (value == null) {
	        if (token.optional) {
	          // Prepend partial segment prefixes.
	          if (token.partial) {
	            path += token.prefix;
	          }

	          continue
	        } else {
	          throw new TypeError('Expected "' + token.name + '" to be defined')
	        }
	      }

	      if (isarray(value)) {
	        if (!token.repeat) {
	          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
	        }

	        if (value.length === 0) {
	          if (token.optional) {
	            continue
	          } else {
	            throw new TypeError('Expected "' + token.name + '" to not be empty')
	          }
	        }

	        for (var j = 0; j < value.length; j++) {
	          segment = encode(value[j]);

	          if (!matches[i].test(segment)) {
	            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
	          }

	          path += (j === 0 ? token.prefix : token.delimiter) + segment;
	        }

	        continue
	      }

	      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

	      if (!matches[i].test(segment)) {
	        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	      }

	      path += token.prefix + segment;
	    }

	    return path
	  }
	}

	/**
	 * Escape a regular expression string.
	 *
	 * @param  {string} str
	 * @return {string}
	 */
	function escapeString (str) {
	  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
	}

	/**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {string} group
	 * @return {string}
	 */
	function escapeGroup (group) {
	  return group.replace(/([=!:$\/()])/g, '\\$1')
	}

	/**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {!RegExp} re
	 * @param  {Array}   keys
	 * @return {!RegExp}
	 */
	function attachKeys (re, keys) {
	  re.keys = keys;
	  return re
	}

	/**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {string}
	 */
	function flags (options) {
	  return options.sensitive ? '' : 'i'
	}

	/**
	 * Pull out keys from a regexp.
	 *
	 * @param  {!RegExp} path
	 * @param  {!Array}  keys
	 * @return {!RegExp}
	 */
	function regexpToRegexp (path, keys) {
	  // Use a negative lookahead to match only capturing groups.
	  var groups = path.source.match(/\((?!\?)/g);

	  if (groups) {
	    for (var i = 0; i < groups.length; i++) {
	      keys.push({
	        name: i,
	        prefix: null,
	        delimiter: null,
	        optional: false,
	        repeat: false,
	        partial: false,
	        asterisk: false,
	        pattern: null
	      });
	    }
	  }

	  return attachKeys(path, keys)
	}

	/**
	 * Transform an array into a regexp.
	 *
	 * @param  {!Array}  path
	 * @param  {Array}   keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
	function arrayToRegexp (path, keys, options) {
	  var parts = [];

	  for (var i = 0; i < path.length; i++) {
	    parts.push(pathToRegexp(path[i], keys, options).source);
	  }

	  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

	  return attachKeys(regexp, keys)
	}

	/**
	 * Create a path regexp from string input.
	 *
	 * @param  {string}  path
	 * @param  {!Array}  keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
	function stringToRegexp (path, keys, options) {
	  return tokensToRegExp(parse(path, options), keys, options)
	}

	/**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {!Array}          tokens
	 * @param  {(Array|Object)=} keys
	 * @param  {Object=}         options
	 * @return {!RegExp}
	 */
	function tokensToRegExp (tokens, keys, options) {
	  if (!isarray(keys)) {
	    options = /** @type {!Object} */ (keys || options);
	    keys = [];
	  }

	  options = options || {};

	  var strict = options.strict;
	  var end = options.end !== false;
	  var route = '';

	  // Iterate over the tokens and create our regexp string.
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i];

	    if (typeof token === 'string') {
	      route += escapeString(token);
	    } else {
	      var prefix = escapeString(token.prefix);
	      var capture = '(?:' + token.pattern + ')';

	      keys.push(token);

	      if (token.repeat) {
	        capture += '(?:' + prefix + capture + ')*';
	      }

	      if (token.optional) {
	        if (!token.partial) {
	          capture = '(?:' + prefix + '(' + capture + '))?';
	        } else {
	          capture = prefix + '(' + capture + ')?';
	        }
	      } else {
	        capture = prefix + '(' + capture + ')';
	      }

	      route += capture;
	    }
	  }

	  var delimiter = escapeString(options.delimiter || '/');
	  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

	  // In non-strict mode we allow a slash at the end of match. If the path to
	  // match already ends with a slash, we remove it for consistency. The slash
	  // is valid at the end of a path match, not in the middle. This is important
	  // in non-ending mode, where "/test/" shouldn't match "/test//route".
	  if (!strict) {
	    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';
	  }

	  if (end) {
	    route += '$';
	  } else {
	    // In non-ending mode, we need the capturing groups to match as much as
	    // possible by using a positive lookahead to the end or next path segment.
	    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';
	  }

	  return attachKeys(new RegExp('^' + route, flags(options)), keys)
	}

	/**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(string|RegExp|Array)} path
	 * @param  {(Array|Object)=}       keys
	 * @param  {Object=}               options
	 * @return {!RegExp}
	 */
	function pathToRegexp (path, keys, options) {
	  if (!isarray(keys)) {
	    options = /** @type {!Object} */ (keys || options);
	    keys = [];
	  }

	  options = options || {};

	  if (path instanceof RegExp) {
	    return regexpToRegexp(path, /** @type {!Array} */ (keys))
	  }

	  if (isarray(path)) {
	    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
	  }

	  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
	}

	index.parse = parse_1;
	index.compile = compile_1;
	index.tokensToFunction = tokensToFunction_1;
	index.tokensToRegExp = tokensToRegExp_1;

	/*  */

	var regexpCache = Object.create(null);

	function getRouteRegex (path) {
	  var hit = regexpCache[path];
	  var keys, regexp;

	  if (hit) {
	    keys = hit.keys;
	    regexp = hit.regexp;
	  } else {
	    keys = [];
	    regexp = index(path, keys);
	    regexpCache[path] = { keys: keys, regexp: regexp };
	  }

	  return { keys: keys, regexp: regexp }
	}

	var regexpCompileCache = Object.create(null);

	function fillParams (
	  path,
	  params,
	  routeMsg
	) {
	  try {
	    var filler =
	      regexpCompileCache[path] ||
	      (regexpCompileCache[path] = index.compile(path));
	    return filler(params || {}, { pretty: true })
	  } catch (e) {
	    if (process.env.NODE_ENV !== 'production') {
	      warn(false, ("missing param for " + routeMsg + ": " + (e.message)));
	    }
	    return ''
	  }
	}

	/*  */


	function normalizeLocation (
	  raw,
	  current,
	  append,
	  router
	) {
	  var next = typeof raw === 'string' ? { path: raw } : raw;
	  // named target
	  if (next.name || next._normalized) {
	    return next
	  }

	  // relative params
	  if (!next.path && next.params && current) {
	    next = assign({}, next);
	    next._normalized = true;
	    var params = assign(assign({}, current.params), next.params);
	    if (current.name) {
	      next.name = current.name;
	      next.params = params;
	    } else if (current.matched) {
	      var rawPath = current.matched[current.matched.length - 1].path;
	      next.path = fillParams(rawPath, params, ("path " + (current.path)));
	    } else if (process.env.NODE_ENV !== 'production') {
	      warn(false, "relative params navigation requires a current route.");
	    }
	    return next
	  }

	  var parsedPath = parsePath(next.path || '');
	  var basePath = (current && current.path) || '/';
	  var path = parsedPath.path
	    ? resolvePath(parsedPath.path, basePath, append || next.append)
	    : (current && current.path) || '/';

	  var query = resolveQuery(
	    parsedPath.query,
	    next.query,
	    router && router.options.parseQuery
	  );

	  var hash = next.hash || parsedPath.hash;
	  if (hash && hash.charAt(0) !== '#') {
	    hash = "#" + hash;
	  }

	  return {
	    _normalized: true,
	    path: path,
	    query: query,
	    hash: hash
	  }
	}

	function assign (a, b) {
	  for (var key in b) {
	    a[key] = b[key];
	  }
	  return a
	}

	/*  */


	function createMatcher (
	  routes,
	  router
	) {
	  var ref = createRouteMap(routes);
	  var pathMap = ref.pathMap;
	  var nameMap = ref.nameMap;

	  function addRoutes (routes) {
	    createRouteMap(routes, pathMap, nameMap);
	  }

	  function match (
	    raw,
	    currentRoute,
	    redirectedFrom
	  ) {
	    var location = normalizeLocation(raw, currentRoute, false, router);
	    var name = location.name;

	    if (name) {
	      var record = nameMap[name];
	      if (process.env.NODE_ENV !== 'production') {
	        warn(record, ("Route with name '" + name + "' does not exist"));
	      }
	      var paramNames = getRouteRegex(record.path).keys
	        .filter(function (key) { return !key.optional; })
	        .map(function (key) { return key.name; });

	      if (typeof location.params !== 'object') {
	        location.params = {};
	      }

	      if (currentRoute && typeof currentRoute.params === 'object') {
	        for (var key in currentRoute.params) {
	          if (!(key in location.params) && paramNames.indexOf(key) > -1) {
	            location.params[key] = currentRoute.params[key];
	          }
	        }
	      }

	      if (record) {
	        location.path = fillParams(record.path, location.params, ("named route \"" + name + "\""));
	        return _createRoute(record, location, redirectedFrom)
	      }
	    } else if (location.path) {
	      location.params = {};
	      for (var path in pathMap) {
	        if (matchRoute(path, location.params, location.path)) {
	          return _createRoute(pathMap[path], location, redirectedFrom)
	        }
	      }
	    }
	    // no match
	    return _createRoute(null, location)
	  }

	  function redirect (
	    record,
	    location
	  ) {
	    var originalRedirect = record.redirect;
	    var redirect = typeof originalRedirect === 'function'
	        ? originalRedirect(createRoute(record, location, null, router))
	        : originalRedirect;

	    if (typeof redirect === 'string') {
	      redirect = { path: redirect };
	    }

	    if (!redirect || typeof redirect !== 'object') {
	      if (process.env.NODE_ENV !== 'production') {
	        warn(
	          false, ("invalid redirect option: " + (JSON.stringify(redirect)))
	        );
	      }
	      return _createRoute(null, location)
	    }

	    var re = redirect;
	    var name = re.name;
	    var path = re.path;
	    var query = location.query;
	    var hash = location.hash;
	    var params = location.params;
	    query = re.hasOwnProperty('query') ? re.query : query;
	    hash = re.hasOwnProperty('hash') ? re.hash : hash;
	    params = re.hasOwnProperty('params') ? re.params : params;

	    if (name) {
	      // resolved named direct
	      var targetRecord = nameMap[name];
	      if (process.env.NODE_ENV !== 'production') {
	        assert(targetRecord, ("redirect failed: named route \"" + name + "\" not found."));
	      }
	      return match({
	        _normalized: true,
	        name: name,
	        query: query,
	        hash: hash,
	        params: params
	      }, undefined, location)
	    } else if (path) {
	      // 1. resolve relative redirect
	      var rawPath = resolveRecordPath(path, record);
	      // 2. resolve params
	      var resolvedPath = fillParams(rawPath, params, ("redirect route with path \"" + rawPath + "\""));
	      // 3. rematch with existing query and hash
	      return match({
	        _normalized: true,
	        path: resolvedPath,
	        query: query,
	        hash: hash
	      }, undefined, location)
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        warn(false, ("invalid redirect option: " + (JSON.stringify(redirect))));
	      }
	      return _createRoute(null, location)
	    }
	  }

	  function alias (
	    record,
	    location,
	    matchAs
	  ) {
	    var aliasedPath = fillParams(matchAs, location.params, ("aliased route with path \"" + matchAs + "\""));
	    var aliasedMatch = match({
	      _normalized: true,
	      path: aliasedPath
	    });
	    if (aliasedMatch) {
	      var matched = aliasedMatch.matched;
	      var aliasedRecord = matched[matched.length - 1];
	      location.params = aliasedMatch.params;
	      return _createRoute(aliasedRecord, location)
	    }
	    return _createRoute(null, location)
	  }

	  function _createRoute (
	    record,
	    location,
	    redirectedFrom
	  ) {
	    if (record && record.redirect) {
	      return redirect(record, redirectedFrom || location)
	    }
	    if (record && record.matchAs) {
	      return alias(record, location, record.matchAs)
	    }
	    return createRoute(record, location, redirectedFrom, router)
	  }

	  return {
	    match: match,
	    addRoutes: addRoutes
	  }
	}

	function matchRoute (
	  path,
	  params,
	  pathname
	) {
	  var ref = getRouteRegex(path);
	  var regexp = ref.regexp;
	  var keys = ref.keys;
	  var m = pathname.match(regexp);

	  if (!m) {
	    return false
	  } else if (!params) {
	    return true
	  }

	  for (var i = 1, len = m.length; i < len; ++i) {
	    var key = keys[i - 1];
	    var val = typeof m[i] === 'string' ? decodeURIComponent(m[i]) : m[i];
	    if (key) { params[key.name] = val; }
	  }

	  return true
	}

	function resolveRecordPath (path, record) {
	  return resolvePath(path, record.parent ? record.parent.path : '/', true)
	}

	/*  */


	var positionStore = Object.create(null);

	function setupScroll () {
	  window.addEventListener('popstate', function (e) {
	    saveScrollPosition();
	    if (e.state && e.state.key) {
	      setStateKey(e.state.key);
	    }
	  });
	}

	function handleScroll (
	  router,
	  to,
	  from,
	  isPop
	) {
	  if (!router.app) {
	    return
	  }

	  var behavior = router.options.scrollBehavior;
	  if (!behavior) {
	    return
	  }

	  if (process.env.NODE_ENV !== 'production') {
	    assert(typeof behavior === 'function', "scrollBehavior must be a function");
	  }

	  // wait until re-render finishes before scrolling
	  router.app.$nextTick(function () {
	    var position = getScrollPosition();
	    var shouldScroll = behavior(to, from, isPop ? position : null);
	    if (!shouldScroll) {
	      return
	    }
	    var isObject = typeof shouldScroll === 'object';
	    if (isObject && typeof shouldScroll.selector === 'string') {
	      var el = document.querySelector(shouldScroll.selector);
	      if (el) {
	        position = getElementPosition(el);
	      } else if (isValidPosition(shouldScroll)) {
	        position = normalizePosition(shouldScroll);
	      }
	    } else if (isObject && isValidPosition(shouldScroll)) {
	      position = normalizePosition(shouldScroll);
	    }

	    if (position) {
	      window.scrollTo(position.x, position.y);
	    }
	  });
	}

	function saveScrollPosition () {
	  var key = getStateKey();
	  if (key) {
	    positionStore[key] = {
	      x: window.pageXOffset,
	      y: window.pageYOffset
	    };
	  }
	}

	function getScrollPosition () {
	  var key = getStateKey();
	  if (key) {
	    return positionStore[key]
	  }
	}

	function getElementPosition (el) {
	  var docEl = document.documentElement;
	  var docRect = docEl.getBoundingClientRect();
	  var elRect = el.getBoundingClientRect();
	  return {
	    x: elRect.left - docRect.left,
	    y: elRect.top - docRect.top
	  }
	}

	function isValidPosition (obj) {
	  return isNumber(obj.x) || isNumber(obj.y)
	}

	function normalizePosition (obj) {
	  return {
	    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
	    y: isNumber(obj.y) ? obj.y : window.pageYOffset
	  }
	}

	function isNumber (v) {
	  return typeof v === 'number'
	}

	/*  */

	var supportsPushState = inBrowser && (function () {
	  var ua = window.navigator.userAgent;

	  if (
	    (ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) &&
	    ua.indexOf('Mobile Safari') !== -1 &&
	    ua.indexOf('Chrome') === -1 &&
	    ua.indexOf('Windows Phone') === -1
	  ) {
	    return false
	  }

	  return window.history && 'pushState' in window.history
	})();

	// use User Timing api (if present) for more accurate key precision
	var Time = inBrowser && window.performance && window.performance.now
	  ? window.performance
	  : Date;

	var _key = genKey();

	function genKey () {
	  return Time.now().toFixed(3)
	}

	function getStateKey () {
	  return _key
	}

	function setStateKey (key) {
	  _key = key;
	}

	function pushState (url, replace) {
	  saveScrollPosition();
	  // try...catch the pushState call to get around Safari
	  // DOM Exception 18 where it limits to 100 pushState calls
	  var history = window.history;
	  try {
	    if (replace) {
	      history.replaceState({ key: _key }, '', url);
	    } else {
	      _key = genKey();
	      history.pushState({ key: _key }, '', url);
	    }
	  } catch (e) {
	    window.location[replace ? 'replace' : 'assign'](url);
	  }
	}

	function replaceState (url) {
	  pushState(url, true);
	}

	/*  */

	function runQueue (queue, fn, cb) {
	  var step = function (index) {
	    if (index >= queue.length) {
	      cb();
	    } else {
	      if (queue[index]) {
	        fn(queue[index], function () {
	          step(index + 1);
	        });
	      } else {
	        step(index + 1);
	      }
	    }
	  };
	  step(0);
	}

	/*  */

	var History = function History (router, base) {
	  this.router = router;
	  this.base = normalizeBase(base);
	  // start with a route object that stands for "nowhere"
	  this.current = START;
	  this.pending = null;
	  this.ready = false;
	  this.readyCbs = [];
	  this.readyErrorCbs = [];
	  this.errorCbs = [];
	};

	History.prototype.listen = function listen (cb) {
	  this.cb = cb;
	};

	History.prototype.onReady = function onReady (cb, errorCb) {
	  if (this.ready) {
	    cb();
	  } else {
	    this.readyCbs.push(cb);
	    if (errorCb) {
	      this.readyErrorCbs.push(errorCb);
	    }
	  }
	};

	History.prototype.onError = function onError (errorCb) {
	  this.errorCbs.push(errorCb);
	};

	History.prototype.transitionTo = function transitionTo (location, onComplete, onAbort) {
	    var this$1 = this;

	  var route = this.router.match(location, this.current);
	  this.confirmTransition(route, function () {
	    this$1.updateRoute(route);
	    onComplete && onComplete(route);
	    this$1.ensureURL();

	    // fire ready cbs once
	    if (!this$1.ready) {
	      this$1.ready = true;
	      this$1.readyCbs.forEach(function (cb) { cb(route); });
	    }
	  }, function (err) {
	    if (onAbort) {
	      onAbort(err);
	    }
	    if (err && !this$1.ready) {
	      this$1.ready = true;
	      this$1.readyErrorCbs.forEach(function (cb) { cb(err); });
	    }
	  });
	};

	History.prototype.confirmTransition = function confirmTransition (route, onComplete, onAbort) {
	    var this$1 = this;

	  var current = this.current;
	  var abort = function (err) {
	    if (err instanceof Error) {
	      this$1.errorCbs.forEach(function (cb) { cb(err); });
	    }
	    onAbort && onAbort(err);
	  };
	  if (
	    isSameRoute(route, current) &&
	    // in the case the route map has been dynamically appended to
	    route.matched.length === current.matched.length
	  ) {
	    this.ensureURL();
	    return abort()
	  }

	  var ref = resolveQueue(this.current.matched, route.matched);
	    var updated = ref.updated;
	    var deactivated = ref.deactivated;
	    var activated = ref.activated;

	  var queue = [].concat(
	    // in-component leave guards
	    extractLeaveGuards(deactivated),
	    // global before hooks
	    this.router.beforeHooks,
	    // in-component update hooks
	    extractUpdateHooks(updated),
	    // in-config enter guards
	    activated.map(function (m) { return m.beforeEnter; }),
	    // async components
	    resolveAsyncComponents(activated)
	  );

	  this.pending = route;
	  var iterator = function (hook, next) {
	    if (this$1.pending !== route) {
	      return abort()
	    }
	    try {
	      hook(route, current, function (to) {
	        if (to === false || to instanceof Error) {
	          // next(false) -> abort navigation, ensure current URL
	          this$1.ensureURL(true);
	          abort(to);
	        } else if (typeof to === 'string' || typeof to === 'object') {
	          // next('/') or next({ path: '/' }) -> redirect
	          abort();
	          if (typeof to === 'object' && to.replace) {
	            this$1.replace(to);
	          } else {
	            this$1.push(to);
	          }
	        } else {
	          // confirm transition and pass on the value
	          next(to);
	        }
	      });
	    } catch (e) {
	      abort(e);
	    }
	  };

	  runQueue(queue, iterator, function () {
	    var postEnterCbs = [];
	    var isValid = function () { return this$1.current === route; };
	    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
	    // wait until async components are resolved before
	    // extracting in-component enter guards
	    runQueue(enterGuards, iterator, function () {
	      if (this$1.pending !== route) {
	        return abort()
	      }
	      this$1.pending = null;
	      onComplete(route);
	      if (this$1.router.app) {
	        this$1.router.app.$nextTick(function () {
	          postEnterCbs.forEach(function (cb) { cb(); });
	        });
	      }
	    });
	  });
	};

	History.prototype.updateRoute = function updateRoute (route) {
	  var prev = this.current;
	  this.current = route;
	  this.cb && this.cb(route);
	  this.router.afterHooks.forEach(function (hook) {
	    hook && hook(route, prev);
	  });
	};

	function normalizeBase (base) {
	  if (!base) {
	    if (inBrowser) {
	      // respect <base> tag
	      var baseEl = document.querySelector('base');
	      base = (baseEl && baseEl.getAttribute('href')) || '/';
	    } else {
	      base = '/';
	    }
	  }
	  // make sure there's the starting slash
	  if (base.charAt(0) !== '/') {
	    base = '/' + base;
	  }
	  // remove trailing slash
	  return base.replace(/\/$/, '')
	}

	function resolveQueue (
	  current,
	  next
	) {
	  var i;
	  var max = Math.max(current.length, next.length);
	  for (i = 0; i < max; i++) {
	    if (current[i] !== next[i]) {
	      break
	    }
	  }
	  return {
	    updated: next.slice(0, i),
	    activated: next.slice(i),
	    deactivated: current.slice(i)
	  }
	}

	function extractGuards (
	  records,
	  name,
	  bind,
	  reverse
	) {
	  var guards = flatMapComponents(records, function (def, instance, match, key) {
	    var guard = extractGuard(def, name);
	    if (guard) {
	      return Array.isArray(guard)
	        ? guard.map(function (guard) { return bind(guard, instance, match, key); })
	        : bind(guard, instance, match, key)
	    }
	  });
	  return flatten(reverse ? guards.reverse() : guards)
	}

	function extractGuard (
	  def,
	  key
	) {
	  if (typeof def !== 'function') {
	    // extend now so that global mixins are applied.
	    def = _Vue.extend(def);
	  }
	  return def.options[key]
	}

	function extractLeaveGuards (deactivated) {
	  return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true)
	}

	function extractUpdateHooks (updated) {
	  return extractGuards(updated, 'beforeRouteUpdate', bindGuard)
	}

	function bindGuard (guard, instance) {
	  return function boundRouteGuard () {
	    return guard.apply(instance, arguments)
	  }
	}

	function extractEnterGuards (
	  activated,
	  cbs,
	  isValid
	) {
	  return extractGuards(activated, 'beforeRouteEnter', function (guard, _, match, key) {
	    return bindEnterGuard(guard, match, key, cbs, isValid)
	  })
	}

	function bindEnterGuard (
	  guard,
	  match,
	  key,
	  cbs,
	  isValid
	) {
	  return function routeEnterGuard (to, from, next) {
	    return guard(to, from, function (cb) {
	      next(cb);
	      if (typeof cb === 'function') {
	        cbs.push(function () {
	          // #750
	          // if a router-view is wrapped with an out-in transition,
	          // the instance may not have been registered at this time.
	          // we will need to poll for registration until current route
	          // is no longer valid.
	          poll(cb, match.instances, key, isValid);
	        });
	      }
	    })
	  }
	}

	function poll (
	  cb, // somehow flow cannot infer this is a function
	  instances,
	  key,
	  isValid
	) {
	  if (instances[key]) {
	    cb(instances[key]);
	  } else if (isValid()) {
	    setTimeout(function () {
	      poll(cb, instances, key, isValid);
	    }, 16);
	  }
	}

	function resolveAsyncComponents (matched) {
	  var _next;
	  var pending = 0;
	  var error = null;

	  flatMapComponents(matched, function (def, _, match, key) {
	    // if it's a function and doesn't have cid attached,
	    // assume it's an async component resolve function.
	    // we are not using Vue's default async resolving mechanism because
	    // we want to halt the navigation until the incoming component has been
	    // resolved.
	    if (typeof def === 'function' && def.cid === undefined) {
	      pending++;

	      var resolve = once(function (resolvedDef) {
	        // save resolved on async factory in case it's used elsewhere
	        def.resolved = typeof resolvedDef === 'function'
	          ? resolvedDef
	          : _Vue.extend(resolvedDef);
	        match.components[key] = resolvedDef;
	        pending--;
	        if (pending <= 0 && _next) {
	          _next();
	        }
	      });

	      var reject = once(function (reason) {
	        var msg = "Failed to resolve async component " + key + ": " + reason;
	        process.env.NODE_ENV !== 'production' && warn(false, msg);
	        if (!error) {
	          error = reason instanceof Error
	            ? reason
	            : new Error(msg);
	          if (_next) { _next(error); }
	        }
	      });

	      var res;
	      try {
	        res = def(resolve, reject);
	      } catch (e) {
	        reject(e);
	      }
	      if (res) {
	        if (typeof res.then === 'function') {
	          res.then(resolve, reject);
	        } else {
	          // new syntax in Vue 2.3
	          var comp = res.component;
	          if (comp && typeof comp.then === 'function') {
	            comp.then(resolve, reject);
	          }
	        }
	      }
	    }
	  });

	  return function (to, from, next) {
	    if (error) {
	      next(error);
	    } else if (pending <= 0) {
	      next();
	    } else {
	      _next = next;
	    }
	  }
	}

	function flatMapComponents (
	  matched,
	  fn
	) {
	  return flatten(matched.map(function (m) {
	    return Object.keys(m.components).map(function (key) { return fn(
	      m.components[key],
	      m.instances[key],
	      m, key
	    ); })
	  }))
	}

	function flatten (arr) {
	  return Array.prototype.concat.apply([], arr)
	}

	// in Webpack 2, require.ensure now also returns a Promise
	// so the resolve/reject functions may get called an extra time
	// if the user uses an arrow function shorthand that happens to
	// return that Promise.
	function once (fn) {
	  var called = false;
	  return function () {
	    if (called) { return }
	    called = true;
	    return fn.apply(this, arguments)
	  }
	}

	/*  */


	var HTML5History = (function (History$$1) {
	  function HTML5History (router, base) {
	    var this$1 = this;

	    History$$1.call(this, router, base);

	    var expectScroll = router.options.scrollBehavior;

	    if (expectScroll) {
	      setupScroll();
	    }

	    window.addEventListener('popstate', function (e) {
	      this$1.transitionTo(getLocation(this$1.base), function (route) {
	        if (expectScroll) {
	          handleScroll(router, route, this$1.current, true);
	        }
	      });
	    });
	  }

	  if ( History$$1 ) HTML5History.__proto__ = History$$1;
	  HTML5History.prototype = Object.create( History$$1 && History$$1.prototype );
	  HTML5History.prototype.constructor = HTML5History;

	  HTML5History.prototype.go = function go (n) {
	    window.history.go(n);
	  };

	  HTML5History.prototype.push = function push (location, onComplete, onAbort) {
	    var this$1 = this;

	    var ref = this;
	    var fromRoute = ref.current;
	    this.transitionTo(location, function (route) {
	      pushState(cleanPath(this$1.base + route.fullPath));
	      handleScroll(this$1.router, route, fromRoute, false);
	      onComplete && onComplete(route);
	    }, onAbort);
	  };

	  HTML5History.prototype.replace = function replace (location, onComplete, onAbort) {
	    var this$1 = this;

	    var ref = this;
	    var fromRoute = ref.current;
	    this.transitionTo(location, function (route) {
	      replaceState(cleanPath(this$1.base + route.fullPath));
	      handleScroll(this$1.router, route, fromRoute, false);
	      onComplete && onComplete(route);
	    }, onAbort);
	  };

	  HTML5History.prototype.ensureURL = function ensureURL (push) {
	    if (getLocation(this.base) !== this.current.fullPath) {
	      var current = cleanPath(this.base + this.current.fullPath);
	      push ? pushState(current) : replaceState(current);
	    }
	  };

	  HTML5History.prototype.getCurrentLocation = function getCurrentLocation () {
	    return getLocation(this.base)
	  };

	  return HTML5History;
	}(History));

	function getLocation (base) {
	  var path = window.location.pathname;
	  if (base && path.indexOf(base) === 0) {
	    path = path.slice(base.length);
	  }
	  return (path || '/') + window.location.search + window.location.hash
	}

	/*  */


	var HashHistory = (function (History$$1) {
	  function HashHistory (router, base, fallback) {
	    History$$1.call(this, router, base);
	    // check history fallback deeplinking
	    if (fallback && checkFallback(this.base)) {
	      return
	    }
	    ensureSlash();
	  }

	  if ( History$$1 ) HashHistory.__proto__ = History$$1;
	  HashHistory.prototype = Object.create( History$$1 && History$$1.prototype );
	  HashHistory.prototype.constructor = HashHistory;

	  // this is delayed until the app mounts
	  // to avoid the hashchange listener being fired too early
	  HashHistory.prototype.setupListeners = function setupListeners () {
	    var this$1 = this;

	    window.addEventListener('hashchange', function () {
	      if (!ensureSlash()) {
	        return
	      }
	      this$1.transitionTo(getHash(), function (route) {
	        replaceHash(route.fullPath);
	      });
	    });
	  };

	  HashHistory.prototype.push = function push (location, onComplete, onAbort) {
	    this.transitionTo(location, function (route) {
	      pushHash(route.fullPath);
	      onComplete && onComplete(route);
	    }, onAbort);
	  };

	  HashHistory.prototype.replace = function replace (location, onComplete, onAbort) {
	    this.transitionTo(location, function (route) {
	      replaceHash(route.fullPath);
	      onComplete && onComplete(route);
	    }, onAbort);
	  };

	  HashHistory.prototype.go = function go (n) {
	    window.history.go(n);
	  };

	  HashHistory.prototype.ensureURL = function ensureURL (push) {
	    var current = this.current.fullPath;
	    if (getHash() !== current) {
	      push ? pushHash(current) : replaceHash(current);
	    }
	  };

	  HashHistory.prototype.getCurrentLocation = function getCurrentLocation () {
	    return getHash()
	  };

	  return HashHistory;
	}(History));

	function checkFallback (base) {
	  var location = getLocation(base);
	  if (!/^\/#/.test(location)) {
	    window.location.replace(
	      cleanPath(base + '/#' + location)
	    );
	    return true
	  }
	}

	function ensureSlash () {
	  var path = getHash();
	  if (path.charAt(0) === '/') {
	    return true
	  }
	  replaceHash('/' + path);
	  return false
	}

	function getHash () {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  var href = window.location.href;
	  var index = href.indexOf('#');
	  return index === -1 ? '' : href.slice(index + 1)
	}

	function pushHash (path) {
	  window.location.hash = path;
	}

	function replaceHash (path) {
	  var i = window.location.href.indexOf('#');
	  window.location.replace(
	    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path
	  );
	}

	/*  */


	var AbstractHistory = (function (History$$1) {
	  function AbstractHistory (router, base) {
	    History$$1.call(this, router, base);
	    this.stack = [];
	    this.index = -1;
	  }

	  if ( History$$1 ) AbstractHistory.__proto__ = History$$1;
	  AbstractHistory.prototype = Object.create( History$$1 && History$$1.prototype );
	  AbstractHistory.prototype.constructor = AbstractHistory;

	  AbstractHistory.prototype.push = function push (location, onComplete, onAbort) {
	    var this$1 = this;

	    this.transitionTo(location, function (route) {
	      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
	      this$1.index++;
	      onComplete && onComplete(route);
	    }, onAbort);
	  };

	  AbstractHistory.prototype.replace = function replace (location, onComplete, onAbort) {
	    var this$1 = this;

	    this.transitionTo(location, function (route) {
	      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
	      onComplete && onComplete(route);
	    }, onAbort);
	  };

	  AbstractHistory.prototype.go = function go (n) {
	    var this$1 = this;

	    var targetIndex = this.index + n;
	    if (targetIndex < 0 || targetIndex >= this.stack.length) {
	      return
	    }
	    var route = this.stack[targetIndex];
	    this.confirmTransition(route, function () {
	      this$1.index = targetIndex;
	      this$1.updateRoute(route);
	    });
	  };

	  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation () {
	    var current = this.stack[this.stack.length - 1];
	    return current ? current.fullPath : '/'
	  };

	  AbstractHistory.prototype.ensureURL = function ensureURL () {
	    // noop
	  };

	  return AbstractHistory;
	}(History));

	/*  */

	var VueRouter = function VueRouter (options) {
	  if ( options === void 0 ) options = {};

	  this.app = null;
	  this.apps = [];
	  this.options = options;
	  this.beforeHooks = [];
	  this.afterHooks = [];
	  this.matcher = createMatcher(options.routes || [], this);

	  var mode = options.mode || 'hash';
	  this.fallback = mode === 'history' && !supportsPushState;
	  if (this.fallback) {
	    mode = 'hash';
	  }
	  if (!inBrowser) {
	    mode = 'abstract';
	  }
	  this.mode = mode;

	  switch (mode) {
	    case 'history':
	      this.history = new HTML5History(this, options.base);
	      break
	    case 'hash':
	      this.history = new HashHistory(this, options.base, this.fallback);
	      break
	    case 'abstract':
	      this.history = new AbstractHistory(this, options.base);
	      break
	    default:
	      if (process.env.NODE_ENV !== 'production') {
	        assert(false, ("invalid mode: " + mode));
	      }
	  }
	};

	var prototypeAccessors = { currentRoute: {} };

	VueRouter.prototype.match = function match (
	  raw,
	  current,
	  redirectedFrom
	) {
	  return this.matcher.match(raw, current, redirectedFrom)
	};

	prototypeAccessors.currentRoute.get = function () {
	  return this.history && this.history.current
	};

	VueRouter.prototype.init = function init (app /* Vue component instance */) {
	    var this$1 = this;

	  process.env.NODE_ENV !== 'production' && assert(
	    install.installed,
	    "not installed. Make sure to call `Vue.use(VueRouter)` " +
	    "before creating root instance."
	  );

	  this.apps.push(app);

	  // main app already initialized.
	  if (this.app) {
	    return
	  }

	  this.app = app;

	  var history = this.history;

	  if (history instanceof HTML5History) {
	    history.transitionTo(history.getCurrentLocation());
	  } else if (history instanceof HashHistory) {
	    var setupHashListener = function () {
	      history.setupListeners();
	    };
	    history.transitionTo(
	      history.getCurrentLocation(),
	      setupHashListener,
	      setupHashListener
	    );
	  }

	  history.listen(function (route) {
	    this$1.apps.forEach(function (app) {
	      app._route = route;
	    });
	  });
	};

	VueRouter.prototype.beforeEach = function beforeEach (fn) {
	  this.beforeHooks.push(fn);
	};

	VueRouter.prototype.afterEach = function afterEach (fn) {
	  this.afterHooks.push(fn);
	};

	VueRouter.prototype.onReady = function onReady (cb, errorCb) {
	  this.history.onReady(cb, errorCb);
	};

	VueRouter.prototype.onError = function onError (errorCb) {
	  this.history.onError(errorCb);
	};

	VueRouter.prototype.push = function push (location, onComplete, onAbort) {
	  this.history.push(location, onComplete, onAbort);
	};

	VueRouter.prototype.replace = function replace (location, onComplete, onAbort) {
	  this.history.replace(location, onComplete, onAbort);
	};

	VueRouter.prototype.go = function go (n) {
	  this.history.go(n);
	};

	VueRouter.prototype.back = function back () {
	  this.go(-1);
	};

	VueRouter.prototype.forward = function forward () {
	  this.go(1);
	};

	VueRouter.prototype.getMatchedComponents = function getMatchedComponents (to) {
	  var route = to
	    ? this.resolve(to).route
	    : this.currentRoute;
	  if (!route) {
	    return []
	  }
	  return [].concat.apply([], route.matched.map(function (m) {
	    return Object.keys(m.components).map(function (key) {
	      return m.components[key]
	    })
	  }))
	};

	VueRouter.prototype.resolve = function resolve (
	  to,
	  current,
	  append
	) {
	  var location = normalizeLocation(
	    to,
	    current || this.history.current,
	    append,
	    this
	  );
	  var route = this.match(location, current);
	  var fullPath = route.redirectedFrom || route.fullPath;
	  var base = this.history.base;
	  var href = createHref(base, fullPath, this.mode);
	  return {
	    location: location,
	    route: route,
	    href: href,
	    // for backwards compat
	    normalizedTo: location,
	    resolved: route
	  }
	};

	VueRouter.prototype.addRoutes = function addRoutes (routes) {
	  this.matcher.addRoutes(routes);
	  if (this.history.current !== START) {
	    this.history.transitionTo(this.history.getCurrentLocation());
	  }
	};

	Object.defineProperties( VueRouter.prototype, prototypeAccessors );

	function createHref (base, fullPath, mode) {
	  var path = mode === 'hash' ? '#' + fullPath : fullPath;
	  return base ? cleanPath(base + '/' + path) : path
	}

	VueRouter.install = install;
	VueRouter.version = '2.4.0';

	if (inBrowser && window.Vue) {
	  window.Vue.use(VueRouter);
	}

	module.exports = VueRouter;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(26)

	/* script */
	__vue_exports__ = __webpack_require__(28)

	/* template */
	var __vue_template__ = __webpack_require__(29)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\index.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-18aa469f", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-18aa469f", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] index.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(27);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-18aa469f!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./index.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-18aa469f!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./index.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.index {\n  height: 100vh;\n  background-color: pink;\n  line-height: 100vh;\n  text-align: center;\n}\n", ""]);

	// exports


/***/ }),
/* 28 */
/***/ (function(module, exports) {

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	"use strict";

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "index"
	  }, [_vm._v("\n\t这是index页！\n")])
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-18aa469f", module.exports)
	  }
	}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(31)

	/* script */
	__vue_exports__ = __webpack_require__(33)

	/* template */
	var __vue_template__ = __webpack_require__(45)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\home.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-eb11bdbc"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-eb11bdbc", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-eb11bdbc", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] home.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(32);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-eb11bdbc&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./home.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-eb11bdbc&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./home.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.transactionPage[data-v-eb11bdbc] {\n  text-align: center;\n}\n.transactionPage header .go-back[data-v-eb11bdbc] {\n  width: 2.875rem;\n  height: 0.9rem;\n  line-height: 0.9rem;\n  margin-top: 0.575rem;\n  color: #fff;\n  font-size: 0.55rem;\n  border: 0.025rem solid #fff;\n}\n.transactionPage header .add-icon[data-v-eb11bdbc] {\n  font-size: 1.25rem;\n  color: #E6E0F7;\n}\n.transactionPage nav[data-v-eb11bdbc] {\n  background-color: #967BDC;\n}\n.transactionPage nav .nav-list[data-v-eb11bdbc] {\n  display: flex;\n  display: -webkit-flex;\n  height: 1.8rem;\n  line-height: 1.8rem;\n  margin-top: 2rem;\n  border-top: 0.025rem solid #fff;\n  list-style: none;\n  justify-content: space-around;\n  background-color: #967BDC;\n}\n.transactionPage nav .nav-list a[data-v-eb11bdbc] {\n  color: #68449f;\n}\n.transactionPage nav .nav-list .active[data-v-eb11bdbc] {\n  position: relative;\n  color: #fff;\n}\n.transactionPage nav .nav-list .active[data-v-eb11bdbc]:after {\n  position: absolute;\n  width: 2.625rem;\n  height: 0.05rem;\n  background: #68449f;\n  top: 0rem;\n  left: -0.125rem;\n}\n.transactionPage nav .nav-list .active.first[data-v-eb11bdbc]:after {\n  left: -0.75rem;\n}\n.transactionPage .account[data-v-eb11bdbc] {\n  position: fixed;\n  z-index: 10;\n  bottom: 2.25rem;\n}\n", ""]);

	// exports


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _footer = __webpack_require__(10);

	var _footer2 = _interopRequireDefault(_footer);

	var _header = __webpack_require__(15);

	var _header2 = _interopRequireDefault(_header);

	var _account = __webpack_require__(34);

	var _account2 = _interopRequireDefault(_account);

	var _marquee = __webpack_require__(39);

	var _marquee2 = _interopRequireDefault(_marquee);

	var _frame = __webpack_require__(44);

	var _frame2 = _interopRequireDefault(_frame);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		name: 'home',

		data: function data() {
			return {
				Client: '',
				stompBody: ''
			};
		},


		methods: {},

		mounted: function mounted() {
			console.log('Home加载完毕！');
			console.log(this);
			this.$nextTick(function () {
				new this.$sticky({ el: '.nav-list' });
			});
		},


		components: {
			myHeader: _header2.default,
			myFooter: _footer2.default,
			myAccount: _account2.default,
			myMarquee: _marquee2.default
		}

	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(35)

	/* script */
	__vue_exports__ = __webpack_require__(37)

	/* template */
	var __vue_template__ = __webpack_require__(38)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\account.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-4688847e"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-4688847e", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-4688847e", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] account.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(36);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-4688847e&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./account.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-4688847e&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./account.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.account[data-v-4688847e] {\n  position: relative;\n  width: 16rem;\n  height: 2.5rem;\n  background: #dadbdd;\n  padding-left: 3rem;\n}\n.account .switch-wrapper[data-v-4688847e] {\n  display: inline-block;\n  background: #7686bb;\n  position: absolute;\n  z-index: 10;\n  min-width: 4.125rem;\n  left: -2.175rem;\n  -webkit-transition: -webkit-transform 0.3s ease-in;\n  transition: transform 0.3s ease-in;\n}\n.account .switch-wrapper .J_Switch[data-v-4688847e] {\n  display: inline-block;\n  position: relative;\n  z-index: 5;\n  width: 2rem;\n  height: 2.5rem;\n  color: #fff;\n  font-size: 0.65rem;\n  line-height: 2.5rem;\n  text-align: center;\n}\n.account .switch-wrapper .J_Switch.real[data-v-4688847e] {\n  background: #6ca5c9;\n}\n.account .switch-wrapper .J_LSwitch[data-v-4688847e] {\n  display: inline-block;\n  position: absolute;\n  z-index: 7;\n  width: 2rem;\n  height: 2.5rem;\n  top: 0rem;\n  right: 0rem;\n  color: #fff;\n  font-size: 0.65rem;\n  line-height: 2.5rem;\n  text-align: center;\n  background: #6ca5c9;\n}\n.account .switch-wrapper .J_LSwitch.real[data-v-4688847e] {\n  background: #7686bb;\n}\n.account .switch-wrapper .switch[data-v-4688847e] {\n  display: inline-block;\n  position: absolute;\n  width: 1.25rem;\n  height: 1.25rem;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n  top: 0.625rem;\n  left: 3.625rem;\n  background: #6ca5c9;\n}\n.account .switch-wrapper .switch.real[data-v-4688847e] {\n  background: #7686bb;\n}\n.account .switch-wrapper .switch span[data-v-4688847e] {\n  position: absolute;\n  display: inline-block;\n  top: 0.375rem;\n  left: 0.7rem;\n  width: 0.25rem;\n  height: 0.25rem;\n  width: 0;\n  height: 0;\n  border-width: 0.25rem;\n  border-style: solid;\n  border-color: transparent transparent transparent #fff;\n  -webkit-transition: -webkit-all 0.3s ease;\n  transition: all .3s ease;\n}\n.account .switch-wrapper.unfold[data-v-4688847e] {\n  -webkit-transform: translateX(2rem);\n  transform: translateX(2rem);\n}\n.account .switch-wrapper.unfold .switch span[data-v-4688847e] {\n  transform: rotate(180deg);\n  -ms-transform: rotate(180deg);\n  /* IE 9 */\n  -moz-transform: rotate(180deg);\n  /* Firefox */\n  -webkit-transform: rotate(180deg);\n  /* Safari 和 Chrome */\n  -o-transform: rotate(180deg);\n  left: 0.375rem;\n}\n.account .transition-l[data-v-4688847e] {\n  display: inline-block;\n  position: absolute;\n  width: 1.25rem;\n  height: 2.5rem;\n  left: 3rem;\n}\n.account .item-wrapper[data-v-4688847e] {\n  width: 10.5rem;\n  overflow: hidden;\n  overflow-x: scroll;\n  overflow-y: hidden;\n  -webkit-overflow-scrolling: touch;\n  transform: translateZ(0);\n}\n.account .item-wrapper ul[data-v-4688847e] {\n  width: 27.5rem;\n  height: 2.5rem;\n  padding: 0.5rem 0.25rem;\n}\n.account .item-wrapper ul li[data-v-4688847e] {\n  display: inline-block;\n  width: 5.25rem;\n  color: #967cdf;\n  text-align: center;\n  border-right: 0.025rem solid #978587;\n}\n.account .item-wrapper ul li[data-v-4688847e]:last-child {\n  border: none;\n}\n.account .item-wrapper ul li .desc[data-v-4688847e] {\n  color: #807691;\n  font-size: 0.5rem;\n}\n.account .item-wrapper ul.pro li[data-v-4688847e] {\n  color: #ccc;\n}\n.account .recharge[data-v-4688847e] {\n  position: absolute;\n  display: inline-block;\n  width: 2.5rem;\n  padding: 0.125rem;\n  font-size: 0.75rem;\n  background: #967ddb;\n  top: 0.625rem;\n  right: 0.25rem;\n  border-bottom: 0.125rem solid #6a4eb5;\n}\n.account .recharge .charge[data-v-4688847e] {\n  color: #fff;\n}\n", ""]);

	// exports


/***/ }),
/* 37 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'account',
		data: function data() {
			return {
				unfold: false,
				isSwitch: true,
				cur_way: '模拟',
				curSwitch: true
			};
		},


		props: ['bg_color'],

		methods: {
			switchUnfold: function switchUnfold() {
				this.curSwitch = false;
				this.unfold = this.unfold ? false : true;
				this.isSwitch = this.isSwitch ? false : true;
			},
			switchEvent: function switchEvent(way) {
				if (way === 'demo') {
					this.cur_way = '模拟';
					this.curSwitch = true;
				} else {
					this.cur_way = '实盘';
					this.curSwitch = false;
				}
				this.isSwitch = true;
				this.unfold = this.unfold ? false : true;
			}
		}
	};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "account"
	  }, [_c('div', {
	    staticClass: "switch-wrapper clearfix",
	    class: {
	      unfold: _vm.unfold
	    }
	  }, [_c('span', {
	    staticClass: "J_Switch demo",
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.switchEvent("demo")
	      }
	    }
	  }, [_vm._v("模拟")]), _vm._v(" "), _c('span', {
	    staticClass: "J_Switch real",
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.switchEvent("real")
	      }
	    }
	  }, [_vm._v("实盘")]), _vm._v(" "), (_vm.isSwitch) ? _c('span', {
	    staticClass: "J_LSwitch",
	    class: {
	      real: _vm.curSwitch
	    },
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.switchUnfold()
	      }
	    }
	  }, [_vm._v("\n\t\t\t" + _vm._s(_vm.cur_way) + "\n\t\t")]) : _vm._e(), _vm._v(" "), _c('span', {
	    staticClass: "switch",
	    class: {
	      real: _vm.curSwitch
	    },
	    attrs: {
	      "id": "J_GetSwitch"
	    },
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.switchUnfold()
	      }
	    }
	  }, [_c('span')])]), _vm._v(" "), _c('span'), _vm._v(" "), _c('span', {
	    staticClass: "transition-l"
	  }), _vm._v(" "), _c('span'), _vm._v(" "), _c('div', {
	    staticClass: "item-wrapper"
	  }, [_c('ul', {
	    class: {
	      pro: _vm.bg_color
	    }
	  }, [_vm._m(0), _vm._v(" "), _vm._m(1), _vm._v(" "), _vm._m(2), _vm._v(" "), _vm._m(3), _vm._v(" "), _vm._m(4)])]), _vm._v(" "), _c('div', {
	    staticClass: "recharge"
	  }, [_c('router-link', {
	    staticClass: "charge",
	    attrs: {
	      "to": "/option"
	    }
	  }, [_vm._v("入金")])], 1)])
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', [_c('p', {
	    staticClass: "J_FreeMargin"
	  }, [_vm._v("402.13")]), _vm._v(" "), _c('p', {
	    staticClass: "desc"
	  }, [_vm._v("可用保证金($)")])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', [_c('p', {
	    staticClass: "J_NetDeposit"
	  }, [_vm._v("1184.04")]), _vm._v(" "), _c('p', {
	    staticClass: "desc"
	  }, [_vm._v("账户净值($)")])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', [_c('p', {
	    staticClass: "J_FloatProfit"
	  }, [_vm._v("-588.14")]), _vm._v(" "), _c('p', {
	    staticClass: "desc"
	  }, [_vm._v("浮动盈亏($)")])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', [_c('p', {
	    staticClass: "J_Rate"
	  }, [_vm._v("129.90")]), _vm._v(" "), _c('p', {
	    staticClass: "desc"
	  }, [_vm._v("保证金比例(%)")])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', [_c('p', {
	    staticClass: "J_Bonus"
	  }, [_vm._v("0.00")]), _vm._v(" "), _c('p', {
	    staticClass: "desc"
	  }, [_vm._v("保证金增金($)")])])
	}]}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-4688847e", module.exports)
	  }
	}

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(40)

	/* script */
	__vue_exports__ = __webpack_require__(42)

	/* template */
	var __vue_template__ = __webpack_require__(43)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\marquee.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-5e771936"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-5e771936", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-5e771936", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] marquee.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(41);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-5e771936&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./marquee.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-5e771936&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./marquee.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.marquee-wrapper-outer[data-v-5e771936] {\n  position: relative;\n  color: #fff;\n  background: #7862af;\n}\n.marquee-wrapper-outer ul[data-v-5e771936] {\n  height: 1.35rem;\n  line-height: 1.35rem;\n  font-size: 0.7rem;\n}\n.marquee-wrapper-outer ul marquee[data-v-5e771936] {\n  /*\n\t\t\t* 解决字体模糊问题\n\t\t\t*/\n  color: #dadbdd;\n  transform: translateZ(0);\n  -webkit-transform: translateZ(0);\n}\n.marquee-wrapper-outer .close-wrapper[data-v-5e771936] {\n  position: absolute;\n  top: 0.3rem;\n  right: 0.05rem;\n}\n.marquee-wrapper-outer .close-wrapper .close_icon[data-v-5e771936] {\n  display: inline-block;\n  width: 0.825rem;\n  height: 0.825rem;\n  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAhCAYAAABX5MJvAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA19JREFUeNq8mH1ozHEcx+9udzY3JbUYCY1NQ6LQIsM8/DF/TNmMUQyRaCJbHg+5bUok5uEP5akzj+cPD2F5nLAM5TG3GcJ/I66tbUa8P3pfXefu9/3e7e4+9Wpr+z68f9/f5+n7M3sa3pk0bQLIA1mgO0gECcAM/oBfoAO0gDvgHHijWjR9SJrJqrH5VFAKhoOX4Cp4DER9M/gJ7KA3GArGgulgKbgPdoLnRhsYiUgFe8BkPtUm8CTEWBHyHXjAJf5tEigB10A1KAO/g022hFh0PHjIp5sJVhsICGV3wWxQzJN5APrrisgBN8BpMA08M3XNroNx4CN4BAarRGTxONeDDaboWTuYQ3+qCTwRfxH9+O72gSpTbGwZeAWOhxKxC7yP8gkEs2K+ktJAERP5/ktMsTcJ63WMlr7+IhzgDPNAPOw8eMGw/ydiDMgEhxQTR4IlGhv0BKt8T2lge0FuQ2NTqoiYB15rpFgJsyPAqRh3DOwHaYpxEoVt4gZWptkrGk8oHj2IR9gJtgcZI7llFp2vTrGe1Jt6kG1l3q/XECEbb2bM72DBKvf7v4R3ITmr6RsiNM/K+tEYhlM5/X6KoN3gJJgLCuh0uvYW9PKJ+Bqmdzt5EpVgEchgnXBHEK5JForojCDMpER/BiOYjt0RrCH72iz8JSmCBVxM9RfojBsjWEP27bCwxvcJc/IpUEQfyGfElNNxwzHpWdqsfLcZbEhUZqGAQlZFXwNTAboxamxgq6YISZLfRMQPJqLLiglyWgfogAvYbfnbNop08JjlZLyKNaV1aJJJtewjzYoJBXz3C+kPwczBaizFabRiPTvH3PId70C2dEbmZrU9oRhXxr70qWLcfAbFTTNbfhdb+Pw4VdFEZulqtPwVvlJeye54SpxErGC1rfLvJ6SPOMrqZ4uxgHSwha/NG9jeOXh7csVQgJ3F7SIr7n89ZjvDTxz0cAwEJDO9t4KVRi3/F947ZjARpURJQCavhHJ3zeWd1fDy46GTJjPMirqwuY1NbS0vUTnBElioa+AnTjjIXrCGaVrXeoDlvDrK0a8Bi0NVa7PGpwFp6dbyGFv5RHU8sWYerZ3FaBjbxVGsSb7LlNfo04A5jO8TA5gxs3mNS+HmCXzCFor6AG6De1KcdL5P/BVgANRKxsP4LBrIAAAAAElFTkSuQmCC) 0 0 no-repeat;\n}\n", ""]);

	// exports


/***/ }),
/* 42 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'marque',
		data: function data() {
			return {
				isHasMarqu: true
			};
		},


		methods: {
			closeMarqu: function closeMarqu() {
				return this.isHasMarqu = false;
			}
		},

		created: function created() {}
	};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return (_vm.isHasMarqu) ? _c('div', {
	    staticClass: "marquee-wrapper-outer"
	  }, [_c('ul', [_c('li', {
	    staticClass: "marquee-wrapper"
	  }, [_c('marquee', {
	    attrs: {
	      "loop": "2",
	      "scrolldelay": "1",
	      "scrollamount": "",
	      "align": "center"
	    }
	  }, [_c('span', [_vm._v("哈哈， 我是最帅的！")])])], 1)]), _vm._v(" "), _c('div', {
	    staticClass: "close-wrapper",
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.closeMarqu()
	      }
	    }
	  }, [_c('span', {
	    staticClass: "close_icon"
	  })])]) : _vm._e()
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-5e771936", module.exports)
	  }
	}

/***/ }),
/* 44 */
/***/ (function(module, exports) {

	'use strict';

	// Generated by CoffeeScript 1.7.1

	/*
	   Stomp Over WebSocket http://www.jmesnil.net/stomp-websocket/doc/ | Apache License V2.0

	   Copyright (C) 2010-2013 [Jeff Mesnil](http://jmesnil.net/)
	   Copyright (C) 2012 [FuseSource, Inc.](http://fusesource.com)
	 */

	(function () {
	    var Byte,
	        Client,
	        Frame,
	        Stomp,
	        __hasProp = {}.hasOwnProperty,
	        __slice = [].slice;

	    Byte = {
	        LF: '\x0A',
	        NULL: '\x00'
	    };

	    Frame = function () {
	        var unmarshallSingle;

	        function Frame(command, headers, body) {
	            this.command = command;
	            this.headers = headers != null ? headers : {};
	            this.body = body != null ? body : '';
	        }

	        Frame.prototype.toString = function () {
	            var lines, name, skipContentLength, value, _ref;
	            lines = [this.command];
	            skipContentLength = this.headers['content-length'] === false ? true : false;
	            if (skipContentLength) {
	                delete this.headers['content-length'];
	            }
	            _ref = this.headers;
	            for (name in _ref) {
	                if (!__hasProp.call(_ref, name)) continue;
	                value = _ref[name];
	                lines.push("" + name + ":" + value);
	            }
	            if (this.body && !skipContentLength) {
	                lines.push("content-length:" + Frame.sizeOfUTF8(this.body));
	            }
	            lines.push(Byte.LF + this.body);
	            return lines.join(Byte.LF);
	        };

	        Frame.sizeOfUTF8 = function (s) {
	            if (s) {
	                return encodeURI(s).match(/%..|./g).length;
	            } else {
	                return 0;
	            }
	        };

	        unmarshallSingle = function unmarshallSingle(data) {
	            var body, chr, command, divider, headerLines, headers, i, idx, len, line, start, trim, _i, _j, _len, _ref, _ref1;
	            divider = data.search(RegExp("" + Byte.LF + Byte.LF));
	            headerLines = data.substring(0, divider).split(Byte.LF);
	            command = headerLines.shift();
	            headers = {};
	            trim = function trim(str) {
	                return str.replace(/^\s+|\s+$/g, '');
	            };
	            _ref = headerLines.reverse();
	            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	                line = _ref[_i];
	                idx = line.indexOf(':');
	                headers[trim(line.substring(0, idx))] = trim(line.substring(idx + 1));
	            }
	            body = '';
	            start = divider + 2;
	            if (headers['content-length']) {
	                len = parseInt(headers['content-length']);
	                body = ('' + data).substring(start, start + len);
	            } else {
	                chr = null;
	                for (i = _j = start, _ref1 = data.length; start <= _ref1 ? _j < _ref1 : _j > _ref1; i = start <= _ref1 ? ++_j : --_j) {
	                    chr = data.charAt(i);
	                    if (chr === Byte.NULL) {
	                        break;
	                    }
	                    body += chr;
	                }
	            }
	            return new Frame(command, headers, body);
	        };

	        Frame.unmarshall = function (datas) {
	            var frame, frames, last_frame, r;
	            frames = datas.split(RegExp("" + Byte.NULL + Byte.LF + "*"));
	            r = {
	                frames: [],
	                partial: ''
	            };
	            r.frames = function () {
	                var _i, _len, _ref, _results;
	                _ref = frames.slice(0, -1);
	                _results = [];
	                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	                    frame = _ref[_i];
	                    _results.push(unmarshallSingle(frame));
	                }
	                return _results;
	            }();
	            last_frame = frames.slice(-1)[0];
	            if (last_frame === Byte.LF || last_frame.search(RegExp("" + Byte.NULL + Byte.LF + "*$")) !== -1) {
	                r.frames.push(unmarshallSingle(last_frame));
	            } else {
	                r.partial = last_frame;
	            }
	            return r;
	        };

	        Frame.marshall = function (command, headers, body) {
	            var frame;
	            frame = new Frame(command, headers, body);
	            return frame.toString() + Byte.NULL;
	        };

	        return Frame;
	    }();

	    Client = function () {
	        var now;

	        function Client(ws) {
	            this.ws = ws;
	            this.ws.binaryType = "arraybuffer";
	            this.counter = 0;
	            this.connected = false;
	            this.heartbeat = {
	                outgoing: 10000,
	                incoming: 10000
	            };
	            this.maxWebSocketFrameSize = 16 * 1024;
	            this.subscriptions = {};
	            this.partialData = '';
	        }

	        Client.prototype.debug = function (message) {
	            var _ref;
	            return;

	            if (location.host.indexOf(getIndexOfUrl()) !== -1) {
	                return;
	            }
	            return typeof window !== "undefined" && window !== null ? (_ref = window.console) != null ? _ref.log(message) : void 0 : void 0;
	        };

	        now = function now() {
	            if (Date.now) {
	                return Date.now();
	            } else {
	                return new Date().valueOf;
	            }
	        };

	        Client.prototype._transmit = function (command, headers, body) {
	            var out;
	            out = Frame.marshall(command, headers, body);
	            if (typeof this.debug === "function") {
	                this.debug(">>> " + out);
	            }
	            while (true) {
	                if (out.length > this.maxWebSocketFrameSize) {
	                    this.ws.send(out.substring(0, this.maxWebSocketFrameSize));
	                    out = out.substring(this.maxWebSocketFrameSize);
	                    if (typeof this.debug === "function") {
	                        this.debug("remaining = " + out.length);
	                    }
	                } else {
	                    // if (this.ws.readyState !== 2 && this.ws.readyState !== 3) {
	                    return this.ws.send(out);
	                    // } else {
	                    //   return undefined;
	                    // }
	                }
	            }
	        };

	        Client.prototype._setupHeartbeat = function (headers) {
	            var serverIncoming, serverOutgoing, ttl, v, _ref, _ref1;
	            if ((_ref = headers.version) !== Stomp.VERSIONS.V1_1 && _ref !== Stomp.VERSIONS.V1_2) {
	                return;
	            }
	            _ref1 = function () {
	                var _i, _len, _ref1, _results;
	                _ref1 = headers['heart-beat'].split(",");
	                _results = [];
	                for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
	                    v = _ref1[_i];
	                    _results.push(parseInt(v));
	                }
	                return _results;
	            }(), serverOutgoing = _ref1[0], serverIncoming = _ref1[1];
	            if (!(this.heartbeat.outgoing === 0 || serverIncoming === 0)) {
	                ttl = Math.max(this.heartbeat.outgoing, serverIncoming);
	                if (typeof this.debug === "function") {
	                    this.debug("send PING every " + ttl + "ms");
	                }
	                this.pinger = Stomp.setInterval(ttl, function (_this) {
	                    return function () {
	                        _this.ws.send(Byte.LF);
	                        return typeof _this.debug === "function" ? _this.debug(">>> PING") : void 0;
	                    };
	                }(this));
	            }
	            if (!(this.heartbeat.incoming === 0 || serverOutgoing === 0)) {
	                ttl = Math.max(this.heartbeat.incoming, serverOutgoing);
	                if (typeof this.debug === "function") {
	                    this.debug("check PONG every " + ttl + "ms");
	                }
	                return this.ponger = Stomp.setInterval(ttl, function (_this) {
	                    return function () {
	                        var delta;
	                        delta = now() - _this.serverActivity;
	                        if (delta > ttl * 2) {
	                            if (typeof _this.debug === "function") {
	                                _this.debug("did not receive server activity for the last " + delta + "ms");
	                            }
	                            return _this.ws.close();
	                        }
	                    };
	                }(this));
	            }
	        };

	        Client.prototype._parseConnect = function () {
	            var args, connectCallback, errorCallback, headers;
	            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	            headers = {};
	            switch (args.length) {
	                case 2:
	                    headers = args[0], connectCallback = args[1];
	                    break;
	                case 3:
	                    if (args[1] instanceof Function) {
	                        headers = args[0], connectCallback = args[1], errorCallback = args[2];
	                    } else {
	                        headers.login = args[0], headers.passcode = args[1], connectCallback = args[2];
	                    }
	                    break;
	                case 4:
	                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3];
	                    break;
	                default:
	                    headers.login = args[0], headers.passcode = args[1], connectCallback = args[2], errorCallback = args[3], headers.host = args[4];
	            }
	            return [headers, connectCallback, errorCallback];
	        };

	        Client.prototype.connect = function () {
	            var args, errorCallback, headers, out;
	            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
	            out = this._parseConnect.apply(this, args);
	            headers = out[0], this.connectCallback = out[1], errorCallback = out[2];
	            if (typeof this.debug === "function") {
	                this.debug("Opening Web Socket...");
	            }
	            this.ws.onmessage = function (_this) {
	                console.log('evt');
	                return function (evt) {
	                    var arr, c, client, data, frame, messageID, onreceive, subscription, unmarshalledData, _i, _len, _ref, _results;
	                    data = typeof ArrayBuffer !== 'undefined' && evt.data instanceof ArrayBuffer ? (arr = new Uint8Array(evt.data), typeof _this.debug === "function" ? _this.debug("--- got data length: " + arr.length) : void 0, function () {
	                        var _i, _len, _results;
	                        _results = [];
	                        for (_i = 0, _len = arr.length; _i < _len; _i++) {
	                            c = arr[_i];
	                            _results.push(String.fromCharCode(c));
	                        }
	                        return _results;
	                    }().join('')) : evt.data;
	                    _this.serverActivity = now();
	                    if (data === Byte.LF) {
	                        if (typeof _this.debug === "function") {
	                            _this.debug("<<< PONG");
	                        }
	                        return;
	                    }
	                    if (typeof _this.debug === "function") {
	                        _this.debug("<<< " + data);
	                    }
	                    unmarshalledData = Frame.unmarshall(_this.partialData + data);
	                    _this.partialData = unmarshalledData.partial;
	                    _ref = unmarshalledData.frames;
	                    _results = [];
	                    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	                        frame = _ref[_i];
	                        switch (frame.command) {
	                            case "CONNECTED":
	                                if (typeof _this.debug === "function") {
	                                    _this.debug("connected to server " + frame.headers.server);
	                                }
	                                _this.connected = true;
	                                _this._setupHeartbeat(frame.headers);
	                                _results.push(typeof _this.connectCallback === "function" ? _this.connectCallback(frame) : void 0);
	                                break;
	                            case "MESSAGE":
	                                subscription = frame.headers.subscription;
	                                onreceive = _this.subscriptions[subscription] || _this.onreceive;
	                                if (onreceive) {
	                                    client = _this;
	                                    messageID = frame.headers["message-id"];
	                                    frame.ack = function (headers) {
	                                        if (headers == null) {
	                                            headers = {};
	                                        }
	                                        return client.ack(messageID, subscription, headers);
	                                    };
	                                    frame.nack = function (headers) {
	                                        if (headers == null) {
	                                            headers = {};
	                                        }
	                                        return client.nack(messageID, subscription, headers);
	                                    };
	                                    _results.push(onreceive(frame));
	                                } else {
	                                    _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled received MESSAGE: " + frame) : void 0);
	                                }
	                                break;
	                            case "RECEIPT":
	                                _results.push(typeof _this.onreceipt === "function" ? _this.onreceipt(frame) : void 0);
	                                break;
	                            case "ERROR":
	                                _results.push(typeof errorCallback === "function" ? errorCallback(frame) : void 0);
	                                break;
	                            default:
	                                _results.push(typeof _this.debug === "function" ? _this.debug("Unhandled frame: " + frame) : void 0);
	                        }
	                    }
	                    return _results;
	                };
	            }(this);
	            this.ws.onclose = function (_this) {
	                return function () {
	                    var msg;
	                    msg = "Whoops! Lost connection to " + _this.ws.url;
	                    if (typeof _this.debug === "function") {
	                        _this.debug(msg);
	                    }
	                    _this._cleanUp();
	                    return typeof errorCallback === "function" ? errorCallback(msg) : void 0;
	                };
	            }(this);
	            return this.ws.onopen = function (_this) {
	                return function () {
	                    if (typeof _this.debug === "function") {
	                        _this.debug('Web Socket Opened...');
	                    }
	                    headers["accept-version"] = Stomp.VERSIONS.supportedVersions();
	                    headers["heart-beat"] = [_this.heartbeat.outgoing, _this.heartbeat.incoming].join(',');
	                    return _this._transmit("CONNECT", headers);
	                };
	            }(this);
	        };

	        Client.prototype.disconnect = function (disconnectCallback, headers) {
	            if (headers == null) {
	                headers = {};
	            }
	            this._transmit("DISCONNECT", headers);
	            this.ws.onclose = null;
	            this.ws.close();
	            this._cleanUp();
	            return typeof disconnectCallback === "function" ? disconnectCallback() : void 0;
	        };

	        Client.prototype._cleanUp = function () {
	            this.connected = false;
	            if (this.pinger) {
	                Stomp.clearInterval(this.pinger);
	            }
	            if (this.ponger) {
	                return Stomp.clearInterval(this.ponger);
	            }
	        };

	        Client.prototype.send = function (destination, headers, body) {
	            if (headers == null) {
	                headers = {};
	            }
	            if (body == null) {
	                body = '';
	            }
	            headers.destination = destination;
	            return this._transmit("SEND", headers, body);
	        };

	        Client.prototype.subscribe = function (destination, callback, headers) {
	            var client;
	            if (headers == null) {
	                headers = {};
	            }
	            if (!headers.id) {
	                headers.id = "sub-" + this.counter++;
	            }
	            headers.destination = destination;
	            this.subscriptions[headers.id] = callback;
	            this._transmit("SUBSCRIBE", headers);
	            client = this;
	            return {
	                id: headers.id,
	                unsubscribe: function unsubscribe() {
	                    return client.unsubscribe(headers.id);
	                }
	            };
	        };

	        Client.prototype.unsubscribe = function (id) {
	            delete this.subscriptions[id];
	            return this._transmit("UNSUBSCRIBE", {
	                id: id
	            });
	        };

	        Client.prototype.begin = function (transaction) {
	            var client, txid;
	            txid = transaction || "tx-" + this.counter++;
	            this._transmit("BEGIN", {
	                transaction: txid
	            });
	            client = this;
	            return {
	                id: txid,
	                commit: function commit() {
	                    return client.commit(txid);
	                },
	                abort: function abort() {
	                    return client.abort(txid);
	                }
	            };
	        };

	        Client.prototype.commit = function (transaction) {
	            return this._transmit("COMMIT", {
	                transaction: transaction
	            });
	        };

	        Client.prototype.abort = function (transaction) {
	            return this._transmit("ABORT", {
	                transaction: transaction
	            });
	        };

	        Client.prototype.ack = function (messageID, subscription, headers) {
	            if (headers == null) {
	                headers = {};
	            }
	            headers["message-id"] = messageID;
	            headers.subscription = subscription;
	            return this._transmit("ACK", headers);
	        };

	        Client.prototype.nack = function (messageID, subscription, headers) {
	            if (headers == null) {
	                headers = {};
	            }
	            headers["message-id"] = messageID;
	            headers.subscription = subscription;
	            return this._transmit("NACK", headers);
	        };

	        return Client;
	    }();

	    Stomp = {
	        VERSIONS: {
	            V1_0: '1.0',
	            V1_1: '1.1',
	            V1_2: '1.2',
	            supportedVersions: function supportedVersions() {
	                return '1.1,1.0';
	            }
	        },
	        client: function client(url, protocols) {
	            var klass, ws;
	            if (protocols == null) {
	                protocols = ['v10.stomp', 'v11.stomp'];
	            }
	            klass = Stomp.WebSocketClass || WebSocket;
	            ws = new klass(url, protocols);
	            return new Client(ws);
	        },
	        over: function over(ws) {
	            return new Client(ws);
	        },
	        Frame: Frame
	    };

	    if (typeof exports !== "undefined" && exports !== null) {
	        exports.Stomp = Stomp;
	    }

	    if (typeof window !== "undefined" && window !== null) {
	        Stomp.setInterval = function (interval, f) {
	            return window.setInterval(f, interval);
	        };
	        Stomp.clearInterval = function (id) {
	            return window.clearInterval(id);
	        };
	        window.Stomp = Stomp;
	    } else if (!exports) {
	        self.Stomp = Stomp;
	    }
	}).call(undefined);

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "transactionPage"
	  }, [_c('my-header', {
	    attrs: {
	      "page-title": "交易"
	    }
	  }, [_c('span', {
	    staticClass: "go-back",
	    on: {
	      "click": function($event) {
	        _vm.$router.go(-1)
	      }
	    },
	    slot: "icon-logo"
	  }, [_vm._v(" 使用帮助 ")]), _vm._v(" "), _c('div', {
	    staticClass: "right-icon",
	    slot: "right-icon"
	  }, [_c('span', {
	    staticClass: "add-icon"
	  }, [_vm._v(" + ")])])]), _vm._v(" "), _c('nav', {
	    staticClass: "nav-wrapper"
	  }, [_c('ul', {
	    staticClass: "nav-list"
	  }, [_c('router-link', {
	    staticClass: "clearfix first",
	    attrs: {
	      "to": "/option"
	    }
	  }, [_vm._v("自选")]), _vm._v(" "), _c('router-link', {
	    staticClass: "clearfix",
	    attrs: {
	      "to": "/curretOrder"
	    }
	  }, [_vm._v("当前交易")]), _vm._v(" "), _c('router-link', {
	    staticClass: "clearfix",
	    attrs: {
	      "to": "/historyOrder"
	    }
	  }, [_vm._v("历史交易")])], 1)]), _vm._v(" "), _c('my-marquee'), _vm._v(" "), _c('router-view'), _vm._v(" "), _c('my-account'), _vm._v(" "), _c('my-footer')], 1)
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-eb11bdbc", module.exports)
	  }
	}

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(47)

	/* template */
	var __vue_template__ = __webpack_require__(49)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\page.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-4aa7925c", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-4aa7925c", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] page.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(48);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-4aa7925c!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./page.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-4aa7925c!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./page.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.page {\n  height: 100vh;\n  background-color: red;\n  line-height: 100vh;\n  text-align: center;\n}\n", ""]);

	// exports


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "page"
	  }, [_vm._v("\n\t这是Page页！\n")])
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-4aa7925c", module.exports)
	  }
	}

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(51)

	/* script */
	__vue_exports__ = __webpack_require__(53)

	/* template */
	var __vue_template__ = __webpack_require__(54)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\optionList.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-4e31c0b6"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-4e31c0b6", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-4e31c0b6", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] optionList.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(52);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-4e31c0b6&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./optionList.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-4e31c0b6&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./optionList.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.option-list[data-v-4e31c0b6] {\n  background: #f4f3fb;\n}\n.option-list #J_list li[data-v-4e31c0b6] {\n  position: relative;\n  width: 16rem;\n  height: 3rem;\n  overflow: hidden;\n  background-color: #fff;\n  padding: 0.25rem 1.5rem;\n  border-bottom: 0.25rem solid #f4f3fb;\n}\n.option-list #J_list li .symbol_wrapper[data-v-4e31c0b6] {\n  position: relative;\n  width: 20.5rem;\n  transform: translateX(0);\n  -webkit-transform: translateX(0);\n  transition: all 0.4s ease-in;\n  -webkit-transition: all 0.4s ease;\n}\n.option-list #J_list li .symbol_wrapper .symbol_status[data-v-4e31c0b6] {\n  position: absolute;\n  width: 0.6rem;\n  left: -1rem;\n  top: 0.5rem;\n  font-size: 0.4rem;\n  color: #68449f;\n  padding: 0.075rem 0.025rem;\n  border: 0.025rem solid #68449f;\n}\n.option-list #J_list li .symbol_wrapper .symbol-name[data-v-4e31c0b6] {\n  width: 4rem;\n  height: 2.25rem;\n  color: #807691;\n  line-height: 2.5rem;\n  padding-top: 0.25rem;\n  font-size: 0.675rem;\n  float: left;\n  margin-right: 0.5rem;\n  border-right: 0.025rem solid #807691;\n}\n.option-list #J_list li .symbol_wrapper .symbol-name p[data-v-4e31c0b6] {\n  width: 3rem;\n  height: 1rem;\n  line-height: 1rem;\n  text-align: left;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.option-list #J_list li .symbol_wrapper .symbol-name p[data-v-4e31c0b6]:last-child {\n  width: 100%;\n  font-size: 0.5rem;\n}\n.option-list #J_list li .symbol_wrapper .price[data-v-4e31c0b6] {\n  float: left;\n  width: 2.75rem;\n  height: 2.5rem;\n  font-size: 0.65rem;\n  line-height: 2.5rem;\n  text-align: left;\n}\n.option-list #J_list li .symbol_wrapper .price.up[data-v-4e31c0b6] {\n  color: #f9584a;\n}\n.option-list #J_list li .symbol_wrapper .price.down[data-v-4e31c0b6] {\n  color: #32d8a3;\n}\n.option-list #J_list li .symbol_wrapper .symbol-bidprice[data-v-4e31c0b6] {\n  margin-right: 0.75rem;\n}\n.option-list #J_list li .symbol_wrapper .symbol-range[data-v-4e31c0b6] {\n  position: absolute;\n  top: 0.8rem;\n  right: 6.5rem;\n  color: #fff;\n  background: #f9584a;\n  padding: 0.1rem 0.375rem;\n  -webkit-border-radius: 0.125rem;\n  -moz-border-radius: 0.125rem;\n  -ms-border-radius: 0.125rem;\n  -o-border-radius: 0.125rem;\n  border-radius: 0.125rem;\n}\n.option-list #J_list li .symbol_wrapper .symbol-range.up[data-v-4e31c0b6] {\n  background: #f9584a;\n}\n.option-list #J_list li .symbol_wrapper .symbol-range.down[data-v-4e31c0b6] {\n  background: #32d8a3;\n}\n.option-list #J_list li .symbol_wrapper[data-v-4e31c0b6]:last-child {\n  margin-bottom: 2rem;\n}\n.option-list #J_list li .symbol_wrapper[data-v-4e31c0b6]:nth-child(3) {\n  display: block;\n}\n.option-list #J_list li .symbol_wrapper .action-wrapper[data-v-4e31c0b6] {\n  position: absolute;\n  top: -0.25rem;\n  right: 0rem;\n  font-size: 0rem;\n}\n.option-list #J_list li .symbol_wrapper .action-wrapper span[data-v-4e31c0b6] {\n  display: inline-block;\n  width: 3rem;\n  height: 2.75rem;\n  font-size: 0.75rem;\n  color: #fff;\n  line-height: 2.75rem;\n  text-align: center;\n}\n.option-list #J_list li .symbol_wrapper .action-wrapper .J_UpSymbol[data-v-4e31c0b6] {\n  background: #7686BA;\n}\n.option-list #J_list li .symbol_wrapper .action-wrapper .J_DelSymbol[data-v-4e31c0b6] {\n  background: #F9584A;\n}\n.option-list #J_list li .symbol_wrapper.move[data-v-4e31c0b6] {\n  transform: translateX(-6rem);\n  -webkit-transform: translateX(-6rem);\n}\n.option-list #J_list li .swiperArea[data-v-4e31c0b6] {\n  position: absolute;\n  width: 4.25rem;\n  height: 2.5rem;\n  top: -0.9rem;\n  right: 0rem;\n}\n", ""]);

	// exports


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _vuex = __webpack_require__(20);

	exports.default = {
		name: 'option',

		data: function data() {
			return {
				startX: 0,
				startY: null,
				move: null,
				old_bidPrice: 0,
				old_askPrice: 0,
				symbol_list: []
			};
		},


		methods: {
			swipeStart: function swipeStart(e) {
				this.startX = e.targetTouches[0].pageX;
				this.startY = e.targetTouches[0].pageY;
			},
			swipeMove: function swipeMove(e, index) {

				var x = e.targetTouches[0].pageX;
				var y = e.targetTouches[0].pageY;
				if (x - this.startX < -100) {
					return this.move = index;
				} else {
					return this.move = null;
				}
			},
			swipeEnd: function swipeEnd(e) {},
			moveTop: function moveTop() {

				return this.move = null;
			},
			delSymbol: function delSymbol() {

				return this.move = null;
			}
		},

		mounted: function mounted() {},
		created: function created() {

			this.$store.dispatch('getOptionList', {
				access_token: this.cookie.get('token')
			});
		},


		computed: {
			symbolList: function symbolList() {
				// 做个练习  真的的数据处理交给vuex处理
				var symbolList = this.$store.state.symbolList;
				var symbolStompList = this.$store.state.symbolCurrentPrice;
				// 有个bug   在这里先解决一下
				for (var i = 0; i < symbolList.length && this.symbol_list.length <= symbolList.length - 1; i++) {
					var symbolParam = {
						name: symbolList[i].quote.name,
						symbol: symbolList[i].quote.symbol,
						ask_price: symbolList[i].quote.ask_price[0],
						bid_price: symbolList[i].quote.bid_price[0],
						close_price: symbolList[i].close_price,
						isUp: 1,
						isBgUp: 1
					};
					this.symbol_list.push(symbolParam);
				}

				if (this.symbol_list.length) {
					for (var _i = 0; _i < this.symbol_list.length; _i++) {
						if (this.symbol_list[_i].symbol === symbolStompList[0]) {

							//(新价格.bid >= 老价格.bid || 新价格.ask >= 老价格.ask) 两个报价颜色设置为红色
							var is_up = (symbolStompList[3] - this.symbol_list[_i].bid_price || symbolStompList[1] - this.symbol_list[_i].ask_price) > 0 ? true : false;

							// if (涨幅>0) {涨幅背景为红色}
							var is_bgUp = +symbolStompList[3] + +symbolStompList[1] - 2 * this.symbol_list[_i].close_price > 0 ? true : false;

							var newSymbolParam = {
								name: this.symbol_list[_i].name,
								symbol: this.symbol_list[_i].symbol,
								bid_price: symbolStompList[3],
								ask_price: symbolStompList[1],
								close_price: this.symbol_list[_i].close_price,
								isUp: is_up,
								isBgUp: is_bgUp
							};

							this.$set(this.symbol_list, _i, newSymbolParam);
						}
					}

					return this.symbol_list;
				}
			}
		},

		watch: {
			price: function price(info) {}
		}
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	/**
	**  在这里没用v-touch是因为:用了之后,如果拖动过程中出现水平方向倾向,则上下方向拖动失灵;
	**  用了js原生Touch事件,也有Bug(touchmove只执行一次), 解决方法为设置某个区域左右滑动；
	**/

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('section', {
	    staticClass: "option-list"
	  }, [_c('ul', {
	    staticClass: "list",
	    attrs: {
	      "id": "J_list"
	    }
	  }, _vm._l((_vm.symbolList), function(symbol, index) {
	    return _c('router-link', {
	      key: symbol.name,
	      ref: "symbolListNode",
	      refInFor: true,
	      attrs: {
	        "to": {
	          path: "/proTrading",
	          query: {
	            symbolName: symbol.name,
	            symbol: symbol.symbol
	          }
	        },
	        "tag": "li"
	      }
	    }, [_c('div', {
	      staticClass: "symbol_wrapper",
	      class: {
	        move: _vm.move == index
	      }
	    }, [_c('div', {
	      staticClass: "symbol_status"
	    }, [_c('span', [_vm._v("休市")])]), _vm._v(" "), _c('div', {
	      staticClass: "symbol-name clearfix"
	    }, [_c('p', {
	      staticClass: "name J_SymbolName"
	    }, [_vm._v(_vm._s(symbol.name))]), _vm._v(" "), _c('p', {
	      staticClass: "symbol"
	    }, [_vm._v(_vm._s(symbol.symbol))])]), _vm._v(" "), _c('span', {
	      staticClass: "symbol-bidprice price",
	      class: {
	        up: symbol.isUp, down: !symbol.isUp
	      }
	    }, [_vm._v("\n\t\t\t\t\t" + _vm._s(symbol.bid_price) + "\n\t\t\t\t")]), _vm._v(" "), _c('span', {
	      staticClass: "symbol-askprice price",
	      class: {
	        up: symbol.isUp, down: !symbol.isUp
	      }
	    }, [_vm._v("\n\t\t\t\t\t" + _vm._s(symbol.ask_price) + "\n\t\t\t\t")]), _vm._v(" "), _c('span', {
	      staticClass: "symbol-range bg-price",
	      class: {
	        up: symbol.isBgUp, down: !symbol.isBgUp
	      }
	    }, [_vm._v("\n\t\t\t\t\t0.125%\n\n\t\t\t\t\t"), _c('div', {
	      staticClass: "swiperArea",
	      on: {
	        "touchstart": function($event) {
	          _vm.swipeStart($event)
	        },
	        "touchmove": function($event) {
	          $event.preventDefault();
	          _vm.swipeMove($event, index)
	        },
	        "touchend": function($event) {
	          _vm.swipeEnd($event)
	        }
	      }
	    })]), _vm._v(" "), _c('div', {
	      staticClass: "action-wrapper clearfix"
	    }, [_c('span', {
	      staticClass: "up J_UpSymbol",
	      on: {
	        "click": function($event) {
	          $event.stopPropagation();
	          _vm.moveTop();
	        }
	      }
	    }, [_vm._v("置顶")]), _vm._v(" "), _c('span', {
	      staticClass: "del J_DelSymbol",
	      on: {
	        "click": function($event) {
	          $event.stopPropagation();
	          _vm.delSymbol();
	        }
	      }
	    }, [_vm._v("移除")])])])])
	  }))])
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-4e31c0b6", module.exports)
	  }
	}

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(56)

	/* script */
	__vue_exports__ = __webpack_require__(58)

	/* template */
	var __vue_template__ = __webpack_require__(202)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\proTrading.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-8dcba992"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-8dcba992", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-8dcba992", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] proTrading.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(57);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-8dcba992&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./proTrading.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-8dcba992&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./proTrading.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.pro-trading header[data-v-8dcba992] {\n  color: #fff;\n  font-size: 0.825rem;\n  background-color: #160E23;\n}\n", ""]);

	// exports


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _header = __webpack_require__(15);

	var _header2 = _interopRequireDefault(_header);

	var _highStock = __webpack_require__(59);

	var _highStock2 = _interopRequireDefault(_highStock);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'pro-trading',

		data: function data() {
			return {
				symbol: {
					name: '',
					sbl: ''
				},
				params: {
					id: '',
					tf: 'm30',
					group_name: 'b2b_real_0'
				}
			};
		},


		methods: {},

		mounted: function mounted() {
			// this.getSymbol();
		},
		created: function created() {

			this.symbol.name = this.$route.query.symbolName;
			this.symbol.sbl = this.params.id = this.$route.query.symbol;

			this.params.symbols = this.symbol.sbl;

			this.$store.dispatch('getCurSymbolInfo', this.params);

			//获取stockList
			// this.$store.dispatch('getStockSymbolList', this.params);
		},


		computed: {
			// stockList() {
			// 	const stockListPrice = this.$store.state.stockSymbolList.price;

			// 	// this.stockSymbolList.price = stockListPrice;
			// }
		},

		watch: {
			// curSymbolInfo() {

			// }
		},

		components: {
			myHeader: _header2.default,
			myStock: _highStock2.default
		}
	};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(60)

	/* script */
	__vue_exports__ = __webpack_require__(62)

	/* template */
	var __vue_template__ = __webpack_require__(201)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\highStock.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-057a17a8"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-057a17a8", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-057a17a8", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] highStock.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(61);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-057a17a8&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./highStock.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-057a17a8&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./highStock.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.Stock[data-v-057a17a8] {\n  margin-top: 2rem;\n}\n.Stock #stockWrap[data-v-057a17a8] {\n  height: 10rem;\n  background-color: #150D22;\n}\n.Stock .rang-seclect[data-v-057a17a8] {\n  background: #1E2132;\n}\n.Stock .rang-seclect .btn-wrap[data-v-057a17a8] {\n  font-size: 0;\n  color: #656d78;\n  border-bottom: 0.025rem solid #484357;\n}\n.Stock .rang-seclect .btn-wrap li[data-v-057a17a8] {\n  display: inline-block;\n  width: 2.65rem;\n  height: 1rem;\n  line-height: 1rem;\n  font-size: 0.65rem;\n  text-align: center;\n}\n.Stock .rang-seclect .btn-wrap li[data-v-057a17a8]:first-child {\n  width: 2.75rem;\n}\n.Stock .rang-seclect .btn-wrap li.active[data-v-057a17a8] {\n  background: #1C5E5D;\n  color: #fff;\n}\n.Stock .account[data-v-057a17a8] {\n  background: #1F1B2C;\n}\n", ""]);

	// exports


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _regenerator = __webpack_require__(63);

	var _regenerator2 = _interopRequireDefault(_regenerator);

	var _asyncToGenerator2 = __webpack_require__(66);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _util = __webpack_require__(132);

	var _util2 = _interopRequireDefault(_util);

	var _pageBase = __webpack_require__(140);

	var _pageBase2 = _interopRequireDefault(_pageBase);

	var _initCharts = __webpack_require__(188);

	var _initCharts2 = _interopRequireDefault(_initCharts);

	var _selectValue = __webpack_require__(191);

	var _selectValue2 = _interopRequireDefault(_selectValue);

	var _infoBar = __webpack_require__(196);

	var _infoBar2 = _interopRequireDefault(_infoBar);

	var _account = __webpack_require__(34);

	var _account2 = _interopRequireDefault(_account);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'highStock',

		data: function data() {
			return {
				up: false,
				unit: '',
				price: {
					todayPrice: '',
					yesterdayPrice: ''
				},
				instance: '',
				selectData: '',
				chartLastData: '',
				//这一步稍后优化
				pitchActive: [false, false, false, true, false, false],
				stockSymbolList: []
			};
		},


		props: ['params'],

		methods: {
			getStockList: function getStockList() {
				var _this = this;

				var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;
				return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
					var list;
					return _regenerator2.default.wrap(function _callee$(_context) {
						while (1) {
							switch (_context.prev = _context.next) {
								case 0:
									_this.stockSymbolList.splice(0);
									_context.next = 3;
									return _pageBase2.default.getStockSymbolList(params).then(function (data) {
										data = data.data.data.price;
										var count = 0,
										    listArr = [];

										for (var i = data.length - 1; i > 0; i--) {
											var item = data[i];
											++count;
											_this.stockSymbolList.push([_util2.default.getTime(item.beijing_time), item.open, item.high, item.low, item.close]);

											if (count > 50) {
												break;
											}
										}

										_this.stockSymbolList.sort(function (a, b) {
											return a[0] > b[0] ? 1 : -1;
										});

										_this.chartLastData = _this.stockSymbolList[_this.stockSymbolList.length - 1];
										_this.getInfoData();
										return _this.stockSymbolList;
									}, function () {});

								case 3:
									list = _context.sent;
									return _context.abrupt('return', list);

								case 5:
								case 'end':
									return _context.stop();
							}
						}
					}, _callee, _this);
				}))();
			},
			initChart: function initChart(index) {
				var _this2 = this;

				var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'm30';

				// this.pitchActive = true;
				var oldIndex = this.pitchActive.indexOf(true);

				if (index !== undefined) {
					this.pitchActive.splice(oldIndex, 1, false);
					this.pitchActive.splice(index, 1, true);
				}

				this.params.tf = param;

				this.getStockList(this.params).then(function (data) {
					//create Chart
					if (_this2.instance) {
						_initCharts2.default.setChartData(data);
					}
					_this2.instance = _initCharts2.default.initChart(data);
				}, function (data) {
					console.log(data);
				});
			},
			getInfoData: function getInfoData() {
				var _this3 = this;

				var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params;

				_pageBase2.default.getInfoData(params).then(function (data) {

					data = data.data.data.price;

					var priceData = data.slice(data.length - 2);

					//后续优化方向
					_this3.price.todayPrice = priceData[1], _this3.price.yesterdayPrice = priceData[0];

					//不清楚unit什么意思，暂时给2

					if (_this3.price.todayPrice) {
						_this3.price.todayPrice.unit = _this3.unit ? _this3.unit : 2;
						_this3.price.todayPrice.close = _this3.price.yesterdayPrice.close;
						_this3.price.todayPrice.price = _this3.chartLastData[4] && _this3.chartLastData[4];
					}

					_this3.up = _this3.price.todayPrice.price - _this3.price.todayPrice.close > 0 ? true : false;
				});

				setTimeout(function () {
					_this3.getInfoData();
				}, 5000);
			},


			/**
	     * 获取交易品种的交易杠杆 (实际上这段代码就是calMarginWithOpenPrice方法中的一部分)
	     * symbol: 从2.2.2.4 接口获取的symbol对象
	     * account: 从2.2.2.5 接口获取的account对象
	     **/
			getLeverage: function getLeverage(symbol, account) {
				var type = 'demo'; //this.isDemo() ? 'demo' : 'real';
				var max_leverage = symbol.policy.demo_max_leverage; //this.isDemo() ? symbol.policy.demo_max_leverage : symbol.policy.real_max_leverage;

				var trading_leverage = account[type].leverage * symbol.policy.leverage_multiplier;
				max_leverage = parseFloat(max_leverage);
				trading_leverage = parseFloat(trading_leverage);

				trading_leverage = trading_leverage < max_leverage ? trading_leverage : max_leverage;

				// this.selectData.lever = trading_leverage;

				return trading_leverage;
			}
		},

		mounted: function mounted() {},
		created: function created() {
			this.initChart();
		},


		computed: {
			curPrice: function curPrice() {
				var subscribe_price = this.$store.state.symbolCurrentPrice,
				    cur_symbol = this.params.symbols,
				    subscribe_symbol = subscribe_price[0];

				if (cur_symbol === subscribe_symbol) {
					return subscribe_price;
				}
				return;
			},
			curSymbol_userAccount: function curSymbol_userAccount() {
				var userAccount = this.$store.state.userAccount;
				var curSymbol = this.$store.state.curSymbolInfoData[0];

				if (curSymbol) {
					this.unit = curSymbol.policy.min_quote_unit;
				}

				return {
					userAccount: userAccount,
					curSymbol: curSymbol
				};
			}
		},

		watch: {
			curPrice: function curPrice(price) {
				if (price) {

					var cur_symbol = this.params.symbols,
					    subscribe_symbol = price[0];

					var bidPrice = parseFloat(price[3]);

					if (this.chartLastData) {

						var curData1 = _util2.default.getTime(price[7]),
						    curData2 = this.chartLastData[2] && this.chartLastData[2] < bidPrice ? bidPrice : this.chartLastData[2],
						    curData3 = this.chartLastData[3] && this.chartLastData[3] < bidPrice ? bidPrice : this.chartLastData[3],
						    curData4 = bidPrice;

						this.chartLastData.splice(0, 1, curData1);
						this.chartLastData.splice(2, 1, curData2);
						this.chartLastData.splice(3, 1, curData3);
						this.chartLastData.splice(4, 1, curData4);

						//updata the chart lastData
						_initCharts2.default.addChartPoint(this.chartLastData);
					}
				} else {
					// console.log('else: ' + price)
				}
			},
			curSymbol_userAccount: function curSymbol_userAccount(param) {
				var curSymbol = param.curSymbol,
				    userAccount = param.userAccount;
				if (curSymbol && userAccount) {
					var leverage = this.getLeverage(curSymbol, userAccount.account);
					curSymbol.leverage = leverage;

					return this.selectData = curSymbol;
				}
			}
		},

		components: {
			mySeclect: _selectValue2.default,
			myInfoBar: _infoBar2.default,
			myAccount: _account2.default
		}

	};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(64);


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be
	// kept identical to the way it is obtained in runtime.js
	var g =
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this;

	// Use `getOwnPropertyNames` because not all browsers support calling
	// `hasOwnProperty` on the global `self` object in a worker. See #183.
	var hadRuntime = g.regeneratorRuntime &&
	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

	// Save the old regeneratorRuntime in case it needs to be restored later.
	var oldRuntime = hadRuntime && g.regeneratorRuntime;

	// Force reevalutation of runtime.js.
	g.regeneratorRuntime = undefined;

	module.exports = __webpack_require__(65);

	if (hadRuntime) {
	  // Restore the original runtime.
	  g.regeneratorRuntime = oldRuntime;
	} else {
	  // Remove the global property added by runtime.js.
	  try {
	    delete g.regeneratorRuntime;
	  } catch(e) {
	    g.regeneratorRuntime = undefined;
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {/**
	 * Copyright (c) 2014, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
	 * additional grant of patent rights can be found in the PATENTS file in
	 * the same directory.
	 */

	!(function(global) {
	  "use strict";

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  var inModule = typeof module === "object";
	  var runtime = global.regeneratorRuntime;
	  if (runtime) {
	    if (inModule) {
	      // If regeneratorRuntime is defined globally and we're in a module,
	      // make the exports object identical to regeneratorRuntime.
	      module.exports = runtime;
	    }
	    // Don't bother evaluating the rest of this file if the runtime was
	    // already defined globally.
	    return;
	  }

	  // Define the runtime globally (as expected by generated code) as either
	  // module.exports (if we're in a module) or a new, empty object.
	  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  runtime.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  runtime.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  runtime.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  runtime.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration. If the Promise is rejected, however, the
	          // result for this iteration will be rejected with the same
	          // reason. Note that rejections of yielded Promises are not
	          // thrown back into the generator function, as is the case
	          // when an awaited Promise is rejected. This difference in
	          // behavior between yield and await is important, because it
	          // allows the consumer to decide what to do with the yielded
	          // rejection (swallow it and continue, manually .throw it back
	          // into the generator, abandon iteration, whatever). With
	          // await, by contrast, there is no opportunity to examine the
	          // rejection reason outside the generator function, so the
	          // only option is to throw it from the await expression, and
	          // let the generator function handle the exception.
	          result.value = unwrapped;
	          resolve(result);
	        }, reject);
	      }
	    }

	    if (typeof process === "object" && process.domain) {
	      invoke = process.domain.bind(invoke);
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  runtime.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return runtime.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        if (delegate.iterator.return) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  runtime.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  runtime.values = values;

	  function doneResult() {
	    return { value: undefined, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined;
	      }

	      return ContinueSentinel;
	    }
	  };
	})(
	  // Among the various tricks for obtaining a reference to the global
	  // object, this seems to be the most reliable technique that does not
	  // use indirect eval (which violates Content Security Policy).
	  typeof global === "object" ? global :
	  typeof window === "object" ? window :
	  typeof self === "object" ? self : this
	);

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(24)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _promise = __webpack_require__(67);

	var _promise2 = _interopRequireDefault(_promise);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (fn) {
	  return function () {
	    var gen = fn.apply(this, arguments);
	    return new _promise2.default(function (resolve, reject) {
	      function step(key, arg) {
	        try {
	          var info = gen[key](arg);
	          var value = info.value;
	        } catch (error) {
	          reject(error);
	          return;
	        }

	        if (info.done) {
	          resolve(value);
	        } else {
	          return _promise2.default.resolve(value).then(function (value) {
	            step("next", value);
	          }, function (err) {
	            step("throw", err);
	          });
	        }
	      }

	      return step("next");
	    });
	  };
	};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(68), __esModule: true };

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(69);
	__webpack_require__(70);
	__webpack_require__(114);
	__webpack_require__(118);
	module.exports = __webpack_require__(78).Promise;

/***/ }),
/* 69 */
/***/ (function(module, exports) {

	

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(71)(true);

	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(74)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(72)
	  , defined   = __webpack_require__(73);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ }),
/* 72 */
/***/ (function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ }),
/* 73 */
/***/ (function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(75)
	  , $export        = __webpack_require__(76)
	  , redefine       = __webpack_require__(91)
	  , hide           = __webpack_require__(81)
	  , has            = __webpack_require__(92)
	  , Iterators      = __webpack_require__(93)
	  , $iterCreate    = __webpack_require__(94)
	  , setToStringTag = __webpack_require__(110)
	  , getPrototypeOf = __webpack_require__(112)
	  , ITERATOR       = __webpack_require__(111)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';

	var returnThis = function(){ return this; };

	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ }),
/* 75 */
/***/ (function(module, exports) {

	module.exports = true;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(77)
	  , core      = __webpack_require__(78)
	  , ctx       = __webpack_require__(79)
	  , hide      = __webpack_require__(81)
	  , PROTOTYPE = 'prototype';

	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ }),
/* 77 */
/***/ (function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 78 */
/***/ (function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(80);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ }),
/* 80 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(82)
	  , createDesc = __webpack_require__(90);
	module.exports = __webpack_require__(86) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(83)
	  , IE8_DOM_DEFINE = __webpack_require__(85)
	  , toPrimitive    = __webpack_require__(89)
	  , dP             = Object.defineProperty;

	exports.f = __webpack_require__(86) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(84);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ }),
/* 84 */
/***/ (function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(86) && !__webpack_require__(87)(function(){
	  return Object.defineProperty(__webpack_require__(88)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(87)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ }),
/* 87 */
/***/ (function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(84)
	  , document = __webpack_require__(77).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(84);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ }),
/* 90 */
/***/ (function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(81);

/***/ }),
/* 92 */
/***/ (function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ }),
/* 93 */
/***/ (function(module, exports) {

	module.exports = {};

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(95)
	  , descriptor     = __webpack_require__(90)
	  , setToStringTag = __webpack_require__(110)
	  , IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(81)(IteratorPrototype, __webpack_require__(111)('iterator'), function(){ return this; });

	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(83)
	  , dPs         = __webpack_require__(96)
	  , enumBugKeys = __webpack_require__(108)
	  , IE_PROTO    = __webpack_require__(105)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(88)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(109).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};

	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(82)
	  , anObject = __webpack_require__(83)
	  , getKeys  = __webpack_require__(97);

	module.exports = __webpack_require__(86) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(98)
	  , enumBugKeys = __webpack_require__(108);

	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(92)
	  , toIObject    = __webpack_require__(99)
	  , arrayIndexOf = __webpack_require__(102)(false)
	  , IE_PROTO     = __webpack_require__(105)('IE_PROTO');

	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(100)
	  , defined = __webpack_require__(73);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(101);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ }),
/* 101 */
/***/ (function(module, exports) {

	var toString = {}.toString;

	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(99)
	  , toLength  = __webpack_require__(103)
	  , toIndex   = __webpack_require__(104);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(72)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(72)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(106)('keys')
	  , uid    = __webpack_require__(107);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

	var global = __webpack_require__(77)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ }),
/* 107 */
/***/ (function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ }),
/* 108 */
/***/ (function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(77).document && document.documentElement;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

	var def = __webpack_require__(82).f
	  , has = __webpack_require__(92)
	  , TAG = __webpack_require__(111)('toStringTag');

	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(106)('wks')
	  , uid        = __webpack_require__(107)
	  , Symbol     = __webpack_require__(77).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';

	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};

	$exports.store = store;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(92)
	  , toObject    = __webpack_require__(113)
	  , IE_PROTO    = __webpack_require__(105)('IE_PROTO')
	  , ObjectProto = Object.prototype;

	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(73);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(115);
	var global        = __webpack_require__(77)
	  , hide          = __webpack_require__(81)
	  , Iterators     = __webpack_require__(93)
	  , TO_STRING_TAG = __webpack_require__(111)('toStringTag');

	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(116)
	  , step             = __webpack_require__(117)
	  , Iterators        = __webpack_require__(93)
	  , toIObject        = __webpack_require__(99);

	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(74)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;

	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ }),
/* 116 */
/***/ (function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ }),
/* 117 */
/***/ (function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(75)
	  , global             = __webpack_require__(77)
	  , ctx                = __webpack_require__(79)
	  , classof            = __webpack_require__(119)
	  , $export            = __webpack_require__(76)
	  , isObject           = __webpack_require__(84)
	  , aFunction          = __webpack_require__(80)
	  , anInstance         = __webpack_require__(120)
	  , forOf              = __webpack_require__(121)
	  , speciesConstructor = __webpack_require__(125)
	  , task               = __webpack_require__(126).set
	  , microtask          = __webpack_require__(128)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;

	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(111)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();

	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};

	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(129)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(110)($Promise, PROMISE);
	__webpack_require__(130)(PROMISE);
	Wrapper = __webpack_require__(78)[PROMISE];

	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(131)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(101)
	  , TAG = __webpack_require__(111)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};

	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ }),
/* 120 */
/***/ (function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(79)
	  , call        = __webpack_require__(122)
	  , isArrayIter = __webpack_require__(123)
	  , anObject    = __webpack_require__(83)
	  , toLength    = __webpack_require__(103)
	  , getIterFn   = __webpack_require__(124)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(83);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(93)
	  , ITERATOR   = __webpack_require__(111)('iterator')
	  , ArrayProto = Array.prototype;

	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(119)
	  , ITERATOR  = __webpack_require__(111)('iterator')
	  , Iterators = __webpack_require__(93);
	module.exports = __webpack_require__(78).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(83)
	  , aFunction = __webpack_require__(80)
	  , SPECIES   = __webpack_require__(111)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(79)
	  , invoke             = __webpack_require__(127)
	  , html               = __webpack_require__(109)
	  , cel                = __webpack_require__(88)
	  , global             = __webpack_require__(77)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(101)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ }),
/* 127 */
/***/ (function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(77)
	  , macrotask = __webpack_require__(126).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(101)(process) == 'process';

	module.exports = function(){
	  var head, last, notify;

	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };

	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }

	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(81);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(77)
	  , core        = __webpack_require__(78)
	  , dP          = __webpack_require__(82)
	  , DESCRIPTORS = __webpack_require__(86)
	  , SPECIES     = __webpack_require__(111)('species');

	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(111)('iterator')
	  , SAFE_CLOSING = false;

	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }

	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var _assign = __webpack_require__(133);

	var _assign2 = _interopRequireDefault(_assign);

	var _focha = __webpack_require__(139);

	var _focha2 = _interopRequireDefault(_focha);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	module.exports = {
	  guid: function guid() {
	    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	      var r = Math.random() * 16 | 0,
	          v = c == 'x' ? r : r & 0x3 | 0x8;
	      return v.toString(16);
	    });
	  },

	  getUnit: function getUnit(num) {
	    var num = parseFloat(num),
	        unit = 0;

	    while (num < 1) {
	      num *= 10;
	      unit++;
	    }

	    return unit;
	  },

	  getTime: function getTime(timestr, pattern) {
	    return _focha2.default.parse(timestr, pattern || 'YYYY-MM-DD HH:mm:ss').getTime();
	  },

	  formateDate: function formateDate(time, forate) {
	    var date = new Date(time);
	    return _focha2.default.format(date, forate || 'YYYY-MM-DD HH:mm:ss');
	  },

	  getDate: function getDate(time) {
	    var date = new Date(time || Date.now());
	    return _focha2.default.format(date, 'YYYY-MM-DD');
	  },

	  getStrLen: function getStrLen(str) {
	    var len = 0;
	    for (var i = 0; i < str.length; i++) {
	      var c = str.charCodeAt(i);
	      //单字节加1 
	      if (c >= 0x0001 && c <= 0x007e || 0xff60 <= c && c <= 0xff9f) {
	        len++;
	      } else {
	        len += 2;
	      }
	    }

	    return len;
	  },

	  /** * 对Date的扩展，将 Date 转化为指定格式的String * 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q)
	      可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) * eg: * (new
	      Date()).pattern("yyyy-MM-dd hh:mm:ss.S")==> 2006-07-02 08:09:04.423      
	   * (new Date()).pattern("yyyy-MM-dd E HH:mm:ss") ==> 2009-03-10 二 20:09:04      
	   * (new Date()).pattern("yyyy-MM-dd EE hh:mm:ss") ==> 2009-03-10 周二 08:09:04      
	   * (new Date()).pattern("yyyy-MM-dd EEE hh:mm:ss") ==> 2009-03-10 星期二 08:09:04      
	   * (new Date()).pattern("yyyy-M-d h:m:s.S") ==> 2006-7-2 8:9:4.18      
	   */
	  formateTime: function formateTime(time, fmt) {
	    //author: meizz 
	    var date = new Date(time);
	    var o = {
	      "M+": date.getMonth() + 1, //月份         
	      "d+": date.getDate(), //日         
	      "h+": date.getHours() % 12 == 0 ? 12 : date.getHours() % 12, //小时         
	      "H+": date.getHours(), //小时         
	      "m+": date.getMinutes(), //分         
	      "s+": date.getSeconds(), //秒         
	      "q+": Math.floor((date.getMonth() + 3) / 3) //季度         
	      // "S": date.getMilliseconds() //毫秒         
	    };
	    var week = {
	      "0": "/u65e5",
	      "1": "/u4e00",
	      "2": "/u4e8c",
	      "3": "/u4e09",
	      "4": "/u56db",
	      "5": "/u4e94",
	      "6": "/u516d"
	    };
	    if (/(y+)/.test(fmt)) {
	      fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length));
	    }
	    if (/(E+)/.test(fmt)) {
	      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length > 1 ? RegExp.$1.length > 2 ? "/u661f/u671f" : "/u5468" : "") + week[date.getDay() + ""]);
	    }
	    for (var k in o) {
	      if (new RegExp("(" + k + ")").test(fmt)) {
	        fmt = fmt.replace(RegExp.$1, RegExp.$1.length == 1 ? o[k] : ("00" + o[k]).substr(("" + o[k]).length));
	      }
	    }
	    return fmt;
	  },

	  isWeixin: function isWeixin() {
	    var ua = navigator.userAgent.toLowerCase();
	    if (ua.match(/MicroMessenger/i) == 'micromessenger') {
	      return true;
	    } else {
	      return false;
	    }
	  },

	  isZhifubao: function isZhifubao() {
	    var ua = navigator.userAgent.toLowerCase();
	    if (ua.match(/AlipayClient/i) == 'alipayclient') {
	      return true;
	    } else {
	      return false;
	    }
	  },

	  isAndroid: function isAndroid() {
	    var u = navigator.userAgent;
	    return u.indexOf('Android') > -1 || u.indexOf('Linux') > -1;
	  },

	  isIOS: function isIOS() {
	    var u = navigator.userAgent;
	    return u.indexOf('iPhone') > -1 || u.indexOf('iPad') > -1;
	  },

	  isDaily: function isDaily() {
	    return location.host.indexOf('localhost') !== -1 || location.host.indexOf('waibao.') !== -1;
	  },

	  supportWebsocket: function supportWebsocket() {
	    var protocol = 'https:' == location.protocol ? 'wss' : 'ws',
	        protoBin;

	    if ('WebSocket' in window) {
	      if (protoBin = 'binaryType' in WebSocket.prototype) {
	        return protoBin;
	      }
	      try {
	        return !!new WebSocket(protocol + '://.').binaryType;
	      } catch (e) {}
	    }

	    return false;
	  },

	  mixin: function mixin() {
	    for (var _len = arguments.length, list = Array(_len), _key = 0; _key < _len; _key++) {
	      list[_key] = arguments[_key];
	    }

	    if (typeof _assign2.default != 'function') {
	      Object.assign = function (target) {
	        'use strict';

	        if (target == null) {
	          throw new TypeError('Cannot convert undefined or null to object');
	        }

	        target = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	          var source = arguments[index];
	          if (source != null) {
	            for (var key in source) {
	              if (Object.prototype.hasOwnProperty.call(source, key)) {
	                target[key] = source[key];
	              }
	            }
	          }
	        }
	        return target;
	      };
	    }
	    return function (target) {
	      _assign2.default.apply(Object, [target.prototype].concat(list));
	    };
	  }
	};

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(134), __esModule: true };

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(135);
	module.exports = __webpack_require__(78).Object.assign;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.3.1 Object.assign(target, source)
	var $export = __webpack_require__(76);

	$export($export.S + $export.F, 'Object', {assign: __webpack_require__(136)});

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// 19.1.2.1 Object.assign(target, source, ...)
	var getKeys  = __webpack_require__(97)
	  , gOPS     = __webpack_require__(137)
	  , pIE      = __webpack_require__(138)
	  , toObject = __webpack_require__(113)
	  , IObject  = __webpack_require__(100)
	  , $assign  = Object.assign;

	// should work with symbols and should have deterministic property order (V8 bug)
	module.exports = !$assign || __webpack_require__(87)(function(){
	  var A = {}
	    , B = {}
	    , S = Symbol()
	    , K = 'abcdefghijklmnopqrst';
	  A[S] = 7;
	  K.split('').forEach(function(k){ B[k] = k; });
	  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
	}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
	  var T     = toObject(target)
	    , aLen  = arguments.length
	    , index = 1
	    , getSymbols = gOPS.f
	    , isEnum     = pIE.f;
	  while(aLen > index){
	    var S      = IObject(arguments[index++])
	      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
	      , length = keys.length
	      , j      = 0
	      , key;
	    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
	  } return T;
	} : $assign;

/***/ }),
/* 137 */
/***/ (function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ }),
/* 138 */
/***/ (function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	/**
	 * Parse or format dates
	 * @class fecha
	 */

	var fecha = {},
	    token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g,
	    dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	    monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	    amPm = ['am', 'pm'],
	    twoDigits = /\d\d?/,
	    threeDigits = /\d{3}/,
	    fourDigits = /\d{4}/,
	    word = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i,
	    noop = function noop() {},
	    dayNamesShort = [],
	    monthNamesShort = [],
	    parseFlags = {
	    D: [twoDigits, function (d, v) {
	        d.day = v;
	    }],
	    M: [twoDigits, function (d, v) {
	        d.month = v - 1;
	    }],
	    YY: [twoDigits, function (d, v) {
	        var da = new Date(),
	            cent = +('' + da.getFullYear()).substr(0, 2);
	        d.year = '' + (v > 68 ? cent - 1 : cent) + v;
	    }],
	    h: [twoDigits, function (d, v) {
	        d.hour = v;
	    }],
	    m: [twoDigits, function (d, v) {
	        d.minute = v;
	    }],
	    s: [twoDigits, function (d, v) {
	        d.second = v;
	    }],
	    YYYY: [fourDigits, function (d, v) {
	        d.year = v;
	    }],
	    S: [/\d/, function (d, v) {
	        d.millisecond = v * 100;
	    }],
	    SS: [/\d{2}/, function (d, v) {
	        d.millisecond = v * 10;
	    }],
	    SSS: [threeDigits, function (d, v) {
	        d.millisecond = v;
	    }],
	    d: [twoDigits, noop],
	    ddd: [word, noop],
	    MMM: [word, monthUpdate('monthNamesShort')],
	    MMMM: [word, monthUpdate('monthNames')],
	    a: [word, function (d, v) {
	        if (amPm.indexOf(v.toLowerCase())) {
	            d.isPm = true;
	        }
	    }],
	    ZZ: [/[\+\-]\d\d:?\d\d/, function (d, v) {
	        var parts = (v + '').match(/([\+\-]|\d\d)/gi),
	            minutes;

	        if (parts) {
	            minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
	            d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
	        }
	    }]
	};
	parseFlags.dd = parseFlags.d;
	parseFlags.dddd = parseFlags.ddd;
	parseFlags.Do = parseFlags.DD = parseFlags.D;
	parseFlags.mm = parseFlags.m;
	parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
	parseFlags.MM = parseFlags.M;
	parseFlags.ss = parseFlags.s;
	parseFlags.A = parseFlags.a;

	shorten(monthNames, monthNamesShort, 3);
	shorten(dayNames, dayNamesShort, 3);

	function monthUpdate(arrName) {
	    return function (d, v) {
	        var index = fecha.i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());
	        if (~index) {
	            d.month = index;
	        }
	    };
	}

	function pad(val, len) {
	    val = String(val);
	    len = len || 2;
	    while (val.length < len) {
	        val = '0' + val;
	    }
	    return val;
	}

	function shorten(arr, newArr, sLen) {
	    for (var i = 0, len = arr.length; i < len; i++) {
	        newArr.push(arr[i].substr(0, sLen));
	    }
	}

	function DoFn(D) {
	    return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
	}

	fecha.i18n = {
	    dayNamesShort: dayNamesShort,
	    dayNames: dayNames,
	    monthNamesShort: monthNamesShort,
	    monthNames: monthNames,
	    amPm: amPm,
	    DoFn: DoFn
	};

	// Some common format strings
	fecha.masks = {
	    'default': 'ddd MMM DD YYYY HH:mm:ss',
	    shortDate: 'M/D/YY',
	    mediumDate: 'MMM D, YYYY',
	    longDate: 'MMMM D, YYYY',
	    fullDate: 'dddd, MMMM D, YYYY',
	    shortTime: 'HH:mm',
	    mediumTime: 'HH:mm:ss',
	    longTime: 'HH:mm:ss.SSS'
	};

	/***
	 * Format a date
	 * @method format
	 * @param {Date|string} dateObj
	 * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
	 */
	fecha.format = function (dateObj, mask) {
	    // Passing date through Date applies Date.parse, if necessary
	    if (typeof dateObj === 'string') {
	        dateObj = fecha.parse(dateObj);
	    } else if (!dateObj) {
	        dateObj = new Date();
	    }
	    if (isNaN(dateObj)) {
	        throw new SyntaxError('invalid date');
	    }

	    mask = fecha.masks[mask] || mask || fecha.masks['default'];

	    var D = dateObj.getDate(),
	        d = dateObj.getDay(),
	        M = dateObj.getMonth(),
	        y = dateObj.getFullYear(),
	        H = dateObj.getHours(),
	        m = dateObj.getMinutes(),
	        s = dateObj.getSeconds(),
	        S = dateObj.getMilliseconds(),
	        o = dateObj.getTimezoneOffset(),
	        flags = {
	        D: D,
	        DD: pad(D),
	        Do: fecha.i18n.DoFn(D),
	        d: d,
	        dd: pad(d),
	        ddd: fecha.i18n.dayNamesShort[d],
	        dddd: fecha.i18n.dayNames[d],
	        M: M + 1,
	        MM: pad(M + 1),
	        MMM: fecha.i18n.monthNamesShort[M],
	        MMMM: fecha.i18n.monthNames[M],
	        YY: String(y).slice(2),
	        YYYY: y,
	        h: H % 12 || 12,
	        hh: pad(H % 12 || 12),
	        H: H,
	        HH: pad(H),
	        m: m,
	        mm: pad(m),
	        s: s,
	        ss: pad(s),
	        S: Math.round(S / 100),
	        SS: pad(Math.round(S / 10), 2),
	        SSS: pad(S, 3),
	        a: H < 12 ? fecha.i18n.amPm[0] : fecha.i18n.amPm[1],
	        A: H < 12 ? fecha.i18n.amPm[0].toUpperCase() : fecha.i18n.amPm[1].toUpperCase(),
	        ZZ: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4)
	    };

	    return mask.replace(token, function ($0) {
	        return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
	    });
	};

	/**
	 * Parse a date string into an object, changes - into /
	 * @method parse
	 * @param {string} dateStr Date string
	 * @param {string} format Date parse format
	 * @returns {Date|boolean}
	 */
	fecha.parse = function (dateStr, format) {
	    var time, isValid, dateInfo, today, date, info, index;

	    if (!format) {
	        time = Date.parse(dateStr.replace(/\-/g, '/'));
	        if (!isNaN(time)) {
	            return new Date(time);
	        } else {
	            return false;
	        }
	    } else {
	        format = fecha.masks[format] || format;

	        isValid = true;
	        dateInfo = {};
	        format.replace(token, function ($0) {
	            if (parseFlags[$0]) {
	                info = parseFlags[$0];
	                index = dateStr.search(info[0]);
	                if (!~index) {
	                    isValid = false;
	                } else {
	                    dateStr.replace(info[0], function (result) {
	                        info[1](dateInfo, result);
	                        dateStr = dateStr.substr(index + result.length);
	                        return result;
	                    });
	                }
	            }

	            return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);
	        });
	    }

	    if (!isValid) {
	        return false;
	    }

	    today = new Date();
	    if (dateInfo.isPm && dateInfo.hour) {
	        dateInfo.hour = +dateInfo.hour + 12;
	    }

	    if (dateInfo.timezoneOffset) {
	        dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
	        date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
	    } else {
	        date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
	    }
	    return date;
	};

	if (typeof module !== 'undefined' && module.exports) {
	    module.exports = fecha;
	} else if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	        return fecha;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {
	    main.fecha = fecha;
	}

	module.exports = fecha;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _promise = __webpack_require__(67);

	var _promise2 = _interopRequireDefault(_promise);

	var _regenerator = __webpack_require__(63);

	var _regenerator2 = _interopRequireDefault(_regenerator);

	var _asyncToGenerator2 = __webpack_require__(66);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _IO = __webpack_require__(141);

	var _IO2 = _interopRequireDefault(_IO);

	var _cookie = __webpack_require__(167);

	var _cookie2 = _interopRequireDefault(_cookie);

	var _storage = __webpack_require__(185);

	var _storage2 = _interopRequireDefault(_storage);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		/*
	 *  @ token  	   测试服
	 *  @ ccess_token   生产服
	 */

		// 获取账户信息
		getAccount: function getAccount() {
			var _this = this;

			return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
				var params, account;
				return _regenerator2.default.wrap(function _callee$(_context) {
					while (1) {
						switch (_context.prev = _context.next) {
							case 0:
								params = {
									url: 'http://newapi.invhero.com/v4/user/',
									type: 'GET',
									data: {
										access_token: _cookie2.default.get('token'),
										_r: Math.random()
									},
									unjoin: true
								};
								_context.next = 3;
								return _IO2.default.ajax(params);

							case 3:
								account = _context.sent;
								return _context.abrupt('return', account);

							case 5:
							case 'end':
								return _context.stop();
						}
					}
				}, _callee, _this);
			}))();
		},


		// 获取交易页面的symbol
		getOptionSymbolList: function getOptionSymbolList(options) {
			var _this2 = this;

			return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
				var params, symbolData;
				return _regenerator2.default.wrap(function _callee2$(_context2) {
					while (1) {
						switch (_context2.prev = _context2.next) {
							case 0:
								options.url = 'http://newapi.invhero.com/v3/demo/symbols6/';

								options._r = Math.random();

								params = {
									url: options.url,
									type: "GET",
									data: {
										access_token: options.access_token,
										_r: options._r
									},
									unjoin: true
								};
								_context2.next = 5;
								return _IO2.default.ajax(params);

							case 5:
								symbolData = _context2.sent;


								//将获取到的symbol存起来
								_this2._saveSymbols(symbolData);

								return _context2.abrupt('return', symbolData);

							case 8:
							case 'end':
								return _context2.stop();
						}
					}
				}, _callee2, _this2);
			}))();
		},


		//获取k线图数据
		getStockSymbolList: function getStockSymbolList(options) {
			var _this3 = this;

			return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3() {
				var id, tf, group_name, params, stockSymbolList;
				return _regenerator2.default.wrap(function _callee3$(_context3) {
					while (1) {
						switch (_context3.prev = _context3.next) {
							case 0:
								options.url = 'http://price.invhero.com/v3/price/candle/';
								id = options.id, tf = options.tf, group_name = options.group_name;
								params = {
									url: options.url,
									type: 'GET',
									data: {
										id: id,
										tf: tf,
										group_name: group_name
									},
									unjoin: true
								};
								_context3.next = 5;
								return _IO2.default.ajax(params);

							case 5:
								stockSymbolList = _context3.sent;
								return _context3.abrupt('return', stockSymbolList);

							case 7:
							case 'end':
								return _context3.stop();
						}
					}
				}, _callee3, _this3);
			}))();
		},


		// 获取每每一天的数据
		getInfoData: function getInfoData(options) {
			var _this4 = this;

			return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee4() {
				var id, group_name, params, infoData;
				return _regenerator2.default.wrap(function _callee4$(_context4) {
					while (1) {
						switch (_context4.prev = _context4.next) {
							case 0:
								id = options.id, group_name = options.group_name;
								params = {
									url: 'http://price.invhero.com/v3/price/candle/',
									type: 'GET',
									data: {
										id: id,
										tf: 'd1',
										group_name: group_name
									},
									unjoin: true
								};
								_context4.next = 4;
								return _IO2.default.ajax(params);

							case 4:
								infoData = _context4.sent;
								return _context4.abrupt('return', infoData);

							case 6:
							case 'end':
								return _context4.stop();
						}
					}
				}, _callee4, _this4);
			}))();
		},


		// 获取当前品种的信息
		getCurSymbolInfo: function getCurSymbolInfo(options) {
			var _this5 = this;

			return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee5() {
				var id, group_name, params, CurSymbolInfo;
				return _regenerator2.default.wrap(function _callee5$(_context5) {
					while (1) {
						switch (_context5.prev = _context5.next) {
							case 0:
								id = options.id, group_name = options.group_name;
								params = {
									url: 'http://newapi.invhero.com/v3/demo/symbols6/',
									type: 'GET',
									data: {
										symbols: options.symbols,
										access_token: _cookie2.default.get('token')
									},
									unjoin: true
								};
								_context5.next = 4;
								return _IO2.default.ajax(params);

							case 4:
								CurSymbolInfo = _context5.sent;
								return _context5.abrupt('return', CurSymbolInfo);

							case 6:
							case 'end':
								return _context5.stop();
						}
					}
				}, _callee5, _this5);
			}))();
		},


		// 获取当前订单列表
		getCurrentOrderList: function getCurrentOrderList(options) {
			var _this6 = this;

			return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee6() {
				var params, currentOrderList;
				return _regenerator2.default.wrap(function _callee6$(_context6) {
					while (1) {
						switch (_context6.prev = _context6.next) {
							case 0:
								params = {
									url: 'http://newapi.invhero.com/v1/orders/demo/current?',
									type: 'GET',
									data: {
										access_token: _cookie2.default.get('token'),
										_r: Math.random()
									},
									unjoin: true
								};
								_context6.next = 3;
								return _IO2.default.ajax(params);

							case 3:
								currentOrderList = _context6.sent;
								return _context6.abrupt('return', currentOrderList);

							case 5:
							case 'end':
								return _context6.stop();
						}
					}
				}, _callee6, _this6);
			}))();
		},


		// 获取当前订单列表
		getHistoryOrderList: function getHistoryOrderList(options) {
			var _this7 = this;

			return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee7() {
				var params, currentOrderList;
				return _regenerator2.default.wrap(function _callee7$(_context7) {
					while (1) {
						switch (_context7.prev = _context7.next) {
							case 0:
								params = {
									url: 'http://newapi.invhero.com/v1/orders/demo/history/list?',
									type: 'GET',
									data: {
										access_token: _cookie2.default.get('token'),
										page_num: options.page,
										_r: Math.random()
									},
									unjoin: true
								};
								_context7.next = 3;
								return _IO2.default.ajax(params);

							case 3:
								currentOrderList = _context7.sent;
								return _context7.abrupt('return', currentOrderList);

							case 5:
							case 'end':
								return _context7.stop();
						}
					}
				}, _callee7, _this7);
			}))();
		},


		/**
	 * 输入开仓价格, 交易账户, 交易品种, 交易量, 计算占用保证金
	 * openPrice: 设定的开仓价格
	 * symbol: 从2.2.2.4 接口获取的symbol对象
	 * volume: 交易量, 单位 手(Lot)
	 * account: 从2.2.2.5 接口获取的account对象
	 **/

		getMargin: function getMargin(openPrice, symbol, volume, account) {
			var _this8 = this;

			return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee8() {
				var d;
				return _regenerator2.default.wrap(function _callee8$(_context8) {
					while (1) {
						switch (_context8.prev = _context8.next) {
							case 0:
								d = new _promise2.default(function (resolve, reject) {});

							case 1:
							case 'end':
								return _context8.stop();
						}
					}
				}, _callee8, _this8);
			}))();
		},


		//
		_saveSymbols: function _saveSymbols(data) {
			var listSymbols = [],
			    type = 'demo',
			    token = _cookie2.default.get('token'),
			    key = token + ':' + type + ':symbols';
			data = data.data.data;
			for (var i = 0; i < data.length; i++) {
				listSymbols.push(data[i].policy.symbol);
			}

			_storage2.default.set(key, listSymbols);
		},
		getStorageSymbols: function getStorageSymbols() {
			var type = 'demo',
			    token = _cookie2.default.get('token'),
			    key = token + ':' + type + ':symbols';
			return _storage2.default.get(key);
		}
	};

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _promise = __webpack_require__(67);

	var _promise2 = _interopRequireDefault(_promise);

	var _axios = __webpack_require__(142);

	var _axios2 = _interopRequireDefault(_axios);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		errorMessage: {
			'404': '没找到地址'
		},

		ajax: function ajax(options) {
			var url = options.url,
			    type = options.type,
			    data = options.data;

			if (!options.unjoin) {
				options.url = options.url[0] !== '/' ? '/' + options.url : options.url;
				// url = Config.getAjaxPrefix() + options.url;
			}

			var defaultOptions = {
				url: url,

				method: type,

				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },

				params: data,

				data: data,

				timeout: 2000,

				responseType: 'json'

			};

			var d = new _promise2.default(function (resolve, reject) {

				(0, _axios2.default)(defaultOptions).then(function (data) {

					if (data.status == 200) {

						resolve(data);
					} else {

						if (data.data.status == 403) {

							//Toast提示
							alert('密码错误');
						}

						reject(data);
					}
				}, function (err) {

					if (err.status) {

						//Toast错误

					}

					reject(data);
				});
			});

			return d;
		},
		postURL: function postURL(url) {
			var form = document.createElement('FORM');
			form.method = 'POST';
			form.style.display = 'none';
			document.body.appendChild(form);
			form.action = url.replace(/\?(.*)/, function (_, urlArgs) {
				urlArgs.replace(/\+/g, ' ').replace(/([^&=]+)=([^&=]*)/g, function (input, key, value) {
					input = document.createElement('INPUT');
					input.type = 'hidden';
					input.name = decodeURIComponent(key);
					input.value = decodeURIComponent(value);
					form.appendChild(input);
				});
				return '';
			});
			form.submit();
		}
	};

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(143);

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);
	var bind = __webpack_require__(145);
	var Axios = __webpack_require__(146);
	var defaults = __webpack_require__(147);

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 * @return {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  var context = new Axios(defaultConfig);
	  var instance = bind(Axios.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils.extend(instance, Axios.prototype, context);

	  // Copy context to instance
	  utils.extend(instance, context);

	  return instance;
	}

	// Create the default instance to be exported
	var axios = createInstance(defaults);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios;

	// Factory for creating new instances
	axios.create = function create(instanceConfig) {
	  return createInstance(utils.merge(defaults, instanceConfig));
	};

	// Expose Cancel & CancelToken
	axios.Cancel = __webpack_require__(164);
	axios.CancelToken = __webpack_require__(165);
	axios.isCancel = __webpack_require__(161);

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};
	axios.spread = __webpack_require__(166);

	module.exports = axios;

	// Allow use of default import syntax in TypeScript
	module.exports.default = axios;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var bind = __webpack_require__(145);

	/*global toString:true*/

	// utils is a library of generic helper functions non-specific to axios

	var toString = Object.prototype.toString;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	function isArray(val) {
	  return toString.call(val) === '[object Array]';
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	function isArrayBuffer(val) {
	  return toString.call(val) === '[object ArrayBuffer]';
	}

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	function isFormData(val) {
	  return (typeof FormData !== 'undefined') && (val instanceof FormData);
	}

	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  var result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	function isString(val) {
	  return typeof val === 'string';
	}

	/**
	 * Determine if a value is a Number
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	function isNumber(val) {
	  return typeof val === 'number';
	}

	/**
	 * Determine if a value is undefined
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	function isUndefined(val) {
	  return typeof val === 'undefined';
	}

	/**
	 * Determine if a value is an Object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	function isObject(val) {
	  return val !== null && typeof val === 'object';
	}

	/**
	 * Determine if a value is a Date
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	function isDate(val) {
	  return toString.call(val) === '[object Date]';
	}

	/**
	 * Determine if a value is a File
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	function isFile(val) {
	  return toString.call(val) === '[object File]';
	}

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	function isBlob(val) {
	  return toString.call(val) === '[object Blob]';
	}

	/**
	 * Determine if a value is a Function
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	function isFunction(val) {
	  return toString.call(val) === '[object Function]';
	}

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	function isStream(val) {
	  return isObject(val) && isFunction(val.pipe);
	}

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {Object} val The value to test
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	function isURLSearchParams(val) {
	  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
	}

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 * @returns {String} The String freed of excess whitespace
	 */
	function trim(str) {
	  return str.replace(/^\s*/, '').replace(/\s*$/, '');
	}

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  typeof document.createElement -> undefined
	 */
	function isStandardBrowserEnv() {
	  return (
	    typeof window !== 'undefined' &&
	    typeof document !== 'undefined' &&
	    typeof document.createElement === 'function'
	  );
	}

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 */
	function forEach(obj, fn) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object' && !isArray(obj)) {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (var i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    for (var key in obj) {
	      if (Object.prototype.hasOwnProperty.call(obj, key)) {
	        fn.call(null, obj[key], key, obj);
	      }
	    }
	  }
	}

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  var result = {};
	  function assignValue(val, key) {
	    if (typeof result[key] === 'object' && typeof val === 'object') {
	      result[key] = merge(result[key], val);
	    } else {
	      result[key] = val;
	    }
	  }

	  for (var i = 0, l = arguments.length; i < l; i++) {
	    forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 * @return {Object} The resulting value of object a
	 */
	function extend(a, b, thisArg) {
	  forEach(b, function assignValue(val, key) {
	    if (thisArg && typeof val === 'function') {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  });
	  return a;
	}

	module.exports = {
	  isArray: isArray,
	  isArrayBuffer: isArrayBuffer,
	  isFormData: isFormData,
	  isArrayBufferView: isArrayBufferView,
	  isString: isString,
	  isNumber: isNumber,
	  isObject: isObject,
	  isUndefined: isUndefined,
	  isDate: isDate,
	  isFile: isFile,
	  isBlob: isBlob,
	  isFunction: isFunction,
	  isStream: isStream,
	  isURLSearchParams: isURLSearchParams,
	  isStandardBrowserEnv: isStandardBrowserEnv,
	  forEach: forEach,
	  merge: merge,
	  extend: extend,
	  trim: trim
	};


/***/ }),
/* 145 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function bind(fn, thisArg) {
	  return function wrap() {
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	    return fn.apply(thisArg, args);
	  };
	};


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var defaults = __webpack_require__(147);
	var utils = __webpack_require__(144);
	var InterceptorManager = __webpack_require__(158);
	var dispatchRequest = __webpack_require__(159);
	var isAbsoluteURL = __webpack_require__(162);
	var combineURLs = __webpack_require__(163);

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 */
	function Axios(instanceConfig) {
	  this.defaults = instanceConfig;
	  this.interceptors = {
	    request: new InterceptorManager(),
	    response: new InterceptorManager()
	  };
	}

	/**
	 * Dispatch a request
	 *
	 * @param {Object} config The config specific for this request (merged with this.defaults)
	 */
	Axios.prototype.request = function request(config) {
	  /*eslint no-param-reassign:0*/
	  // Allow for axios('example/url'[, config]) a la fetch API
	  if (typeof config === 'string') {
	    config = utils.merge({
	      url: arguments[0]
	    }, arguments[1]);
	  }

	  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);

	  // Support baseURL config
	  if (config.baseURL && !isAbsoluteURL(config.url)) {
	    config.url = combineURLs(config.baseURL, config.url);
	  }

	  // Hook up interceptors middleware
	  var chain = [dispatchRequest, undefined];
	  var promise = Promise.resolve(config);

	  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	    chain.unshift(interceptor.fulfilled, interceptor.rejected);
	  });

	  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	    chain.push(interceptor.fulfilled, interceptor.rejected);
	  });

	  while (chain.length) {
	    promise = promise.then(chain.shift(), chain.shift());
	  }

	  return promise;
	};

	// Provide aliases for supported request methods
	utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url
	    }));
	  };
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, data, config) {
	    return this.request(utils.merge(config || {}, {
	      method: method,
	      url: url,
	      data: data
	    }));
	  };
	});

	module.exports = Axios;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(144);
	var normalizeHeaderName = __webpack_require__(148);

	var PROTECTION_PREFIX = /^\)\]\}',?\n/;
	var DEFAULT_CONTENT_TYPE = {
	  'Content-Type': 'application/x-www-form-urlencoded'
	};

	function setContentTypeIfUnset(headers, value) {
	  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
	    headers['Content-Type'] = value;
	  }
	}

	function getDefaultAdapter() {
	  var adapter;
	  if (typeof XMLHttpRequest !== 'undefined') {
	    // For browsers use XHR adapter
	    adapter = __webpack_require__(149);
	  } else if (typeof process !== 'undefined') {
	    // For node use HTTP adapter
	    adapter = __webpack_require__(149);
	  }
	  return adapter;
	}

	var defaults = {
	  adapter: getDefaultAdapter(),

	  transformRequest: [function transformRequest(data, headers) {
	    normalizeHeaderName(headers, 'Content-Type');
	    if (utils.isFormData(data) ||
	      utils.isArrayBuffer(data) ||
	      utils.isStream(data) ||
	      utils.isFile(data) ||
	      utils.isBlob(data)
	    ) {
	      return data;
	    }
	    if (utils.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils.isURLSearchParams(data)) {
	      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
	      return data.toString();
	    }
	    if (utils.isObject(data)) {
	      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
	      return JSON.stringify(data);
	    }
	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    /*eslint no-param-reassign:0*/
	    if (typeof data === 'string') {
	      data = data.replace(PROTECTION_PREFIX, '');
	      try {
	        data = JSON.parse(data);
	      } catch (e) { /* Ignore */ }
	    }
	    return data;
	  }],

	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  }
	};

	defaults.headers = {
	  common: {
	    'Accept': 'application/json, text/plain, */*'
	  }
	};

	utils.forEach(['delete', 'get', 'head'], function forEachMehtodNoData(method) {
	  defaults.headers[method] = {};
	});

	utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
	});

	module.exports = defaults;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);

	module.exports = function normalizeHeaderName(headers, normalizedName) {
	  utils.forEach(headers, function processHeader(value, name) {
	    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
	      headers[normalizedName] = value;
	      delete headers[name];
	    }
	  });
	};


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var utils = __webpack_require__(144);
	var settle = __webpack_require__(150);
	var buildURL = __webpack_require__(153);
	var parseHeaders = __webpack_require__(154);
	var isURLSameOrigin = __webpack_require__(155);
	var createError = __webpack_require__(151);
	var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(156);

	module.exports = function xhrAdapter(config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    var requestData = config.data;
	    var requestHeaders = config.headers;

	    if (utils.isFormData(requestData)) {
	      delete requestHeaders['Content-Type']; // Let the browser set it
	    }

	    var request = new XMLHttpRequest();
	    var loadEvent = 'onreadystatechange';
	    var xDomain = false;

	    // For IE 8/9 CORS support
	    // Only supports POST and GET calls and doesn't returns the response headers.
	    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
	    if (process.env.NODE_ENV !== 'test' &&
	        typeof window !== 'undefined' &&
	        window.XDomainRequest && !('withCredentials' in request) &&
	        !isURLSameOrigin(config.url)) {
	      request = new window.XDomainRequest();
	      loadEvent = 'onload';
	      xDomain = true;
	      request.onprogress = function handleProgress() {};
	      request.ontimeout = function handleTimeout() {};
	    }

	    // HTTP basic authentication
	    if (config.auth) {
	      var username = config.auth.username || '';
	      var password = config.auth.password || '';
	      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
	    }

	    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

	    // Set the request timeout in MS
	    request.timeout = config.timeout;

	    // Listen for ready state
	    request[loadEvent] = function handleLoad() {
	      if (!request || (request.readyState !== 4 && !xDomain)) {
	        return;
	      }

	      // The request errored out and we didn't get a response, this will be
	      // handled by onerror instead
	      // With one exception: request that using file: protocol, most browsers
	      // will return status as 0 even though it's a successful request
	      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	        return;
	      }

	      // Prepare the response
	      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
	      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
	      var response = {
	        data: responseData,
	        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
	        status: request.status === 1223 ? 204 : request.status,
	        statusText: request.status === 1223 ? 'No Content' : request.statusText,
	        headers: responseHeaders,
	        config: config,
	        request: request
	      };

	      settle(resolve, reject, response);

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(createError('Network Error', config));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));

	      // Clean up request
	      request = null;
	    };

	    // Add xsrf header
	    // This is only done if running in a standard browser environment.
	    // Specifically not if we're in a web worker, or react-native.
	    if (utils.isStandardBrowserEnv()) {
	      var cookies = __webpack_require__(157);

	      // Add xsrf header
	      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
	          cookies.read(config.xsrfCookieName) :
	          undefined;

	      if (xsrfValue) {
	        requestHeaders[config.xsrfHeaderName] = xsrfValue;
	      }
	    }

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
	        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
	          // Remove Content-Type if data is undefined
	          delete requestHeaders[key];
	        } else {
	          // Otherwise add header to the request
	          request.setRequestHeader(key, val);
	        }
	      });
	    }

	    // Add withCredentials to request if needed
	    if (config.withCredentials) {
	      request.withCredentials = true;
	    }

	    // Add responseType to request if needed
	    if (config.responseType) {
	      try {
	        request.responseType = config.responseType;
	      } catch (e) {
	        if (request.responseType !== 'json') {
	          throw e;
	        }
	      }
	    }

	    // Handle progress if needed
	    if (typeof config.onDownloadProgress === 'function') {
	      request.addEventListener('progress', config.onDownloadProgress);
	    }

	    // Not all browsers support upload events
	    if (typeof config.onUploadProgress === 'function' && request.upload) {
	      request.upload.addEventListener('progress', config.onUploadProgress);
	    }

	    if (config.cancelToken) {
	      // Handle cancellation
	      config.cancelToken.promise.then(function onCanceled(cancel) {
	        if (!request) {
	          return;
	        }

	        request.abort();
	        reject(cancel);
	        // Clean up request
	        request = null;
	      });
	    }

	    if (requestData === undefined) {
	      requestData = null;
	    }

	    // Send the request
	    request.send(requestData);
	  });
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(24)))

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var createError = __webpack_require__(151);

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 */
	module.exports = function settle(resolve, reject, response) {
	  var validateStatus = response.config.validateStatus;
	  // Note: status is not exposed by XDomainRequest
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(createError(
	      'Request failed with status code ' + response.status,
	      response.config,
	      null,
	      response
	    ));
	  }
	};


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var enhanceError = __webpack_require__(152);

	/**
	 * Create an Error with the specified message, config, error code, and response.
	 *
	 * @param {string} message The error message.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The created error.
	 */
	module.exports = function createError(message, config, code, response) {
	  var error = new Error(message);
	  return enhanceError(error, config, code, response);
	};


/***/ }),
/* 152 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Update an Error with the specified config, error code, and response.
	 *
	 * @param {Error} error The error to update.
	 * @param {Object} config The config.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 @ @param {Object} [response] The response.
	 * @returns {Error} The error.
	 */
	module.exports = function enhanceError(error, config, code, response) {
	  error.config = config;
	  if (code) {
	    error.code = code;
	  }
	  error.response = response;
	  return error;
	};


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);

	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%40/gi, '@').
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @returns {string} The formatted url
	 */
	module.exports = function buildURL(url, params, paramsSerializer) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }

	  var serializedParams;
	  if (paramsSerializer) {
	    serializedParams = paramsSerializer(params);
	  } else if (utils.isURLSearchParams(params)) {
	    serializedParams = params.toString();
	  } else {
	    var parts = [];

	    utils.forEach(params, function serialize(val, key) {
	      if (val === null || typeof val === 'undefined') {
	        return;
	      }

	      if (utils.isArray(val)) {
	        key = key + '[]';
	      }

	      if (!utils.isArray(val)) {
	        val = [val];
	      }

	      utils.forEach(val, function parseValue(v) {
	        if (utils.isDate(v)) {
	          v = v.toISOString();
	        } else if (utils.isObject(v)) {
	          v = JSON.stringify(v);
	        }
	        parts.push(encode(key) + '=' + encode(v));
	      });
	    });

	    serializedParams = parts.join('&');
	  }

	  if (serializedParams) {
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	};


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} headers Headers needing to be parsed
	 * @returns {Object} Headers parsed into an object
	 */
	module.exports = function parseHeaders(headers) {
	  var parsed = {};
	  var key;
	  var val;
	  var i;

	  if (!headers) { return parsed; }

	  utils.forEach(headers.split('\n'), function parser(line) {
	    i = line.indexOf(':');
	    key = utils.trim(line.substr(0, i)).toLowerCase();
	    val = utils.trim(line.substr(i + 1));

	    if (key) {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });

	  return parsed;
	};


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs have full support of the APIs needed to test
	  // whether the request URL is of the same origin as current location.
	  (function standardBrowserEnv() {
	    var msie = /(msie|trident)/i.test(navigator.userAgent);
	    var urlParsingNode = document.createElement('a');
	    var originURL;

	    /**
	    * Parse a URL to discover it's components
	    *
	    * @param {String} url The URL to be parsed
	    * @returns {Object}
	    */
	    function resolveURL(url) {
	      var href = url;

	      if (msie) {
	        // IE needs attribute set twice to normalize properties
	        urlParsingNode.setAttribute('href', href);
	        href = urlParsingNode.href;
	      }

	      urlParsingNode.setAttribute('href', href);

	      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
	      return {
	        href: urlParsingNode.href,
	        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
	        host: urlParsingNode.host,
	        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
	        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
	        hostname: urlParsingNode.hostname,
	        port: urlParsingNode.port,
	        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
	                  urlParsingNode.pathname :
	                  '/' + urlParsingNode.pathname
	      };
	    }

	    originURL = resolveURL(window.location.href);

	    /**
	    * Determine if a URL shares the same origin as the current location
	    *
	    * @param {String} requestURL The URL to test
	    * @returns {boolean} True if URL shares the same origin, otherwise false
	    */
	    return function isURLSameOrigin(requestURL) {
	      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
	      return (parsed.protocol === originURL.protocol &&
	            parsed.host === originURL.host);
	    };
	  })() :

	  // Non standard browser envs (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return function isURLSameOrigin() {
	      return true;
	    };
	  })()
	);


/***/ }),
/* 156 */
/***/ (function(module, exports) {

	'use strict';

	// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function E() {
	  this.message = 'String contains an invalid character';
	}
	E.prototype = new Error;
	E.prototype.code = 5;
	E.prototype.name = 'InvalidCharacterError';

	function btoa(input) {
	  var str = String(input);
	  var output = '';
	  for (
	    // initialize result and counter
	    var block, charCode, idx = 0, map = chars;
	    // if the next str index does not exist:
	    //   change the mapping table to "="
	    //   check if d has no fractional digits
	    str.charAt(idx | 0) || (map = '=', idx % 1);
	    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
	    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
	  ) {
	    charCode = str.charCodeAt(idx += 3 / 4);
	    if (charCode > 0xFF) {
	      throw new E();
	    }
	    block = block << 8 | charCode;
	  }
	  return output;
	}

	module.exports = btoa;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);

	module.exports = (
	  utils.isStandardBrowserEnv() ?

	  // Standard browser envs support document.cookie
	  (function standardBrowserEnv() {
	    return {
	      write: function write(name, value, expires, path, domain, secure) {
	        var cookie = [];
	        cookie.push(name + '=' + encodeURIComponent(value));

	        if (utils.isNumber(expires)) {
	          cookie.push('expires=' + new Date(expires).toGMTString());
	        }

	        if (utils.isString(path)) {
	          cookie.push('path=' + path);
	        }

	        if (utils.isString(domain)) {
	          cookie.push('domain=' + domain);
	        }

	        if (secure === true) {
	          cookie.push('secure');
	        }

	        document.cookie = cookie.join('; ');
	      },

	      read: function read(name) {
	        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	        return (match ? decodeURIComponent(match[3]) : null);
	      },

	      remove: function remove(name) {
	        this.write(name, '', Date.now() - 86400000);
	      }
	    };
	  })() :

	  // Non standard browser env (web workers, react-native) lack needed support.
	  (function nonStandardBrowserEnv() {
	    return {
	      write: function write() {},
	      read: function read() { return null; },
	      remove: function remove() {}
	    };
	  })()
	);


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);

	function InterceptorManager() {
	  this.handlers = [];
	}

	/**
	 * Add a new interceptor to the stack
	 *
	 * @param {Function} fulfilled The function to handle `then` for a `Promise`
	 * @param {Function} rejected The function to handle `reject` for a `Promise`
	 *
	 * @return {Number} An ID used to remove interceptor later
	 */
	InterceptorManager.prototype.use = function use(fulfilled, rejected) {
	  this.handlers.push({
	    fulfilled: fulfilled,
	    rejected: rejected
	  });
	  return this.handlers.length - 1;
	};

	/**
	 * Remove an interceptor from the stack
	 *
	 * @param {Number} id The ID that was returned by `use`
	 */
	InterceptorManager.prototype.eject = function eject(id) {
	  if (this.handlers[id]) {
	    this.handlers[id] = null;
	  }
	};

	/**
	 * Iterate over all the registered interceptors
	 *
	 * This method is particularly useful for skipping over any
	 * interceptors that may have become `null` calling `eject`.
	 *
	 * @param {Function} fn The function to call for each interceptor
	 */
	InterceptorManager.prototype.forEach = function forEach(fn) {
	  utils.forEach(this.handlers, function forEachHandler(h) {
	    if (h !== null) {
	      fn(h);
	    }
	  });
	};

	module.exports = InterceptorManager;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);
	var transformData = __webpack_require__(160);
	var isCancel = __webpack_require__(161);
	var defaults = __webpack_require__(147);

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 * @returns {Promise} The Promise to be fulfilled
	 */
	module.exports = function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  // Ensure headers exist
	  config.headers = config.headers || {};

	  // Transform request data
	  config.data = transformData(
	    config.data,
	    config.headers,
	    config.transformRequest
	  );

	  // Flatten headers
	  config.headers = utils.merge(
	    config.headers.common || {},
	    config.headers[config.method] || {},
	    config.headers || {}
	  );

	  utils.forEach(
	    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	    function cleanHeaderConfig(method) {
	      delete config.headers[method];
	    }
	  );

	  var adapter = config.adapter || defaults.adapter;

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData(
	      response.data,
	      response.headers,
	      config.transformResponse
	    );

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData(
	          reason.response.data,
	          reason.response.headers,
	          config.transformResponse
	        );
	      }
	    }

	    return Promise.reject(reason);
	  });
	};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var utils = __webpack_require__(144);

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Object|String} data The data to be transformed
	 * @param {Array} headers The headers for the request or response
	 * @param {Array|Function} fns A single function or Array of functions
	 * @returns {*} The resulting transformed data
	 */
	module.exports = function transformData(data, headers, fns) {
	  /*eslint no-param-reassign:0*/
	  utils.forEach(fns, function transform(fn) {
	    data = fn(data, headers);
	  });

	  return data;
	};


/***/ }),
/* 161 */
/***/ (function(module, exports) {

	'use strict';

	module.exports = function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	};


/***/ }),
/* 162 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	module.exports = function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
	};


/***/ }),
/* 163 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 * @returns {string} The combined URL
	 */
	module.exports = function combineURLs(baseURL, relativeURL) {
	  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
	};


/***/ }),
/* 164 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * A `Cancel` is an object that is thrown when an operation is canceled.
	 *
	 * @class
	 * @param {string=} message The message.
	 */
	function Cancel(message) {
	  this.message = message;
	}

	Cancel.prototype.toString = function toString() {
	  return 'Cancel' + (this.message ? ': ' + this.message : '');
	};

	Cancel.prototype.__CANCEL__ = true;

	module.exports = Cancel;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	var Cancel = __webpack_require__(164);

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @class
	 * @param {Function} executor The executor function.
	 */
	function CancelToken(executor) {
	  if (typeof executor !== 'function') {
	    throw new TypeError('executor must be a function.');
	  }

	  var resolvePromise;
	  this.promise = new Promise(function promiseExecutor(resolve) {
	    resolvePromise = resolve;
	  });

	  var token = this;
	  executor(function cancel(message) {
	    if (token.reason) {
	      // Cancellation has already been requested
	      return;
	    }

	    token.reason = new Cancel(message);
	    resolvePromise(token.reason);
	  });
	}

	/**
	 * Throws a `Cancel` if cancellation has been requested.
	 */
	CancelToken.prototype.throwIfRequested = function throwIfRequested() {
	  if (this.reason) {
	    throw this.reason;
	  }
	};

	/**
	 * Returns an object that contains a new `CancelToken` and a function that, when called,
	 * cancels the `CancelToken`.
	 */
	CancelToken.source = function source() {
	  var cancel;
	  var token = new CancelToken(function executor(c) {
	    cancel = c;
	  });
	  return {
	    token: token,
	    cancel: cancel
	  };
	};

	module.exports = CancelToken;


/***/ }),
/* 166 */
/***/ (function(module, exports) {

	'use strict';

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 * @returns {Function}
	 */
	module.exports = function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	};


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;'use strict';

	var _typeof2 = __webpack_require__(168);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	 * Cookies.js - 1.2.1
	 * https://github.com/ScottHamper/Cookies
	 *
	 * This is free and unencumbered software released into the public domain.
	 */
	(function (global, undefined) {
	    'use strict';

	    var factory = function factory(window) {
	        if ((0, _typeof3.default)(window.document) !== 'object') {
	            throw new Error('Cookies.js requires a `window` with a `document` object');
	        }

	        var Cookies = function Cookies(key, value, options) {
	            return arguments.length === 1 ? Cookies.get(key) : Cookies.set(key, value, options);
	        };

	        // Allows for setter injection in unit tests
	        Cookies._document = window.document;

	        // Used to ensure cookie keys do not collide with
	        // built-in `Object` properties
	        Cookies._cacheKeyPrefix = 'cookey.'; // Hurr hurr, :)

	        Cookies._maxExpireDate = new Date('Fri, 31 Dec 9999 23:59:59 UTC');

	        Cookies.defaults = {
	            path: '/',
	            secure: false,
	            expires: Infinity
	        };

	        Cookies.get = function (key) {
	            if (Cookies._cachedDocumentCookie !== Cookies._document.cookie) {
	                Cookies._renewCache();
	            }

	            return Cookies._cache[Cookies._cacheKeyPrefix + key];
	        };

	        Cookies.set = function (key, value, options) {
	            options = Cookies._getExtendedOptions(options);
	            options.expires = Cookies._getExpiresDate(value === undefined ? -1000 : options.expires);

	            //Cookies._document.cookie = Cookies._generateCookieString(key, value, options);
	            var c = Cookies._generateCookieString(key, value, options);
	            // console.log("[Cookies.set]c=" + c);
	            Cookies._document.cookie = c;
	            return Cookies;
	        };

	        /*
	        Cookies.set = function (key, value, options) {
	            options = Cookies._getExtendedOptions(options);
	            options.expires = Cookies._getExpiresDate(value === undefined ? -1 : options.expires);
	             Cookies._document.cookie = Cookies._generateCookieString(key, value, options);
	             return Cookies;
	        };
	        */

	        Cookies.expire = function (key, options) {
	            return Cookies.set(key, undefined, options);
	        };

	        Cookies._getExtendedOptions = function (options) {
	            return {
	                path: options && options.path || Cookies.defaults.path,
	                domain: options && options.domain || Cookies.defaults.domain,
	                expires: options && options.expires || Cookies.defaults.expires,
	                secure: options && options.secure !== undefined ? options.secure : Cookies.defaults.secure
	            };
	        };

	        Cookies._isValidDate = function (date) {
	            return Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date.getTime());
	        };

	        Cookies._getExpiresDate = function (expires, now) {
	            now = now || new Date();

	            if (typeof expires === 'number') {
	                expires = expires === Infinity ? Cookies._maxExpireDate : new Date(now.getTime() + expires * 1000);
	            } else if (typeof expires === 'string') {
	                expires = new Date(expires);
	            }

	            if (expires && !Cookies._isValidDate(expires)) {
	                throw new Error('`expires` parameter cannot be converted to a valid Date instance');
	            }

	            return expires;
	        };

	        Cookies._generateCookieString = function (key, value, options) {
	            key = key.replace(/[^#$&+\^`|]/g, encodeURIComponent);
	            key = key.replace(/\(/g, '%28').replace(/\)/g, '%29');
	            value = (value + '').replace(/[^!#$&-+\--:<-\[\]-~]/g, encodeURIComponent);
	            options = options || {};

	            var cookieString = key + '=' + value;
	            cookieString += options.path ? ';path=' + options.path : '';
	            cookieString += options.domain ? ';domain=' + options.domain : '';
	            cookieString += options.expires ? ';expires=' + options.expires.toUTCString() : '';
	            cookieString += options.secure ? ';secure' : '';

	            return cookieString;
	        };

	        Cookies._getCacheFromString = function (documentCookie) {
	            var cookieCache = {};
	            var cookiesArray = documentCookie ? documentCookie.split('; ') : [];

	            for (var i = 0; i < cookiesArray.length; i++) {
	                var cookieKvp = Cookies._getKeyValuePairFromCookieString(cookiesArray[i]);

	                if (cookieCache[Cookies._cacheKeyPrefix + cookieKvp.key] === undefined) {
	                    cookieCache[Cookies._cacheKeyPrefix + cookieKvp.key] = cookieKvp.value;
	                }
	            }

	            return cookieCache;
	        };

	        Cookies._getKeyValuePairFromCookieString = function (cookieString) {
	            // "=" is a valid character in a cookie value according to RFC6265, so cannot `split('=')`
	            var separatorIndex = cookieString.indexOf('=');

	            // IE omits the "=" when the cookie value is an empty string
	            separatorIndex = separatorIndex < 0 ? cookieString.length : separatorIndex;

	            return {
	                key: decodeURIComponent(cookieString.substr(0, separatorIndex)),
	                value: decodeURIComponent(cookieString.substr(separatorIndex + 1))
	            };
	        };

	        Cookies._renewCache = function () {
	            Cookies._cache = Cookies._getCacheFromString(Cookies._document.cookie);
	            Cookies._cachedDocumentCookie = Cookies._document.cookie;
	        };

	        Cookies._areEnabled = function () {
	            var testKey = 'cookies.js';
	            var areEnabled = Cookies.set(testKey, 1).get(testKey) === '1';
	            Cookies.expire(testKey);
	            return areEnabled;
	        };

	        Cookies.enabled = Cookies._areEnabled();

	        return Cookies;
	    };

	    var cookiesExport = (0, _typeof3.default)(global.document) === 'object' ? factory(global) : factory;

	    // AMD support
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	            return cookiesExport;
	        }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	        // CommonJS/Node.js support
	    } else if ((typeof exports === 'undefined' ? 'undefined' : (0, _typeof3.default)(exports)) === 'object') {
	        // Support Node.js specific `module.exports` (which can be a function)
	        if ((typeof module === 'undefined' ? 'undefined' : (0, _typeof3.default)(module)) === 'object' && (0, _typeof3.default)(module.exports) === 'object') {
	            exports = module.exports = cookiesExport;
	        }
	        // But always support CommonJS module 1.1.1 spec (`exports` cannot be a function)
	        exports.Cookies = cookiesExport;
	    } else {
	        global.Cookies = cookiesExport;
	    }
	})(typeof window === 'undefined' ? undefined : window);

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _iterator = __webpack_require__(169);

	var _iterator2 = _interopRequireDefault(_iterator);

	var _symbol = __webpack_require__(172);

	var _symbol2 = _interopRequireDefault(_symbol);

	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(170), __esModule: true };

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(70);
	__webpack_require__(114);
	module.exports = __webpack_require__(171).f('iterator');

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(111);

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(173), __esModule: true };

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(174);
	__webpack_require__(69);
	__webpack_require__(183);
	__webpack_require__(184);
	module.exports = __webpack_require__(78).Symbol;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(77)
	  , has            = __webpack_require__(92)
	  , DESCRIPTORS    = __webpack_require__(86)
	  , $export        = __webpack_require__(76)
	  , redefine       = __webpack_require__(91)
	  , META           = __webpack_require__(175).KEY
	  , $fails         = __webpack_require__(87)
	  , shared         = __webpack_require__(106)
	  , setToStringTag = __webpack_require__(110)
	  , uid            = __webpack_require__(107)
	  , wks            = __webpack_require__(111)
	  , wksExt         = __webpack_require__(171)
	  , wksDefine      = __webpack_require__(176)
	  , keyOf          = __webpack_require__(177)
	  , enumKeys       = __webpack_require__(178)
	  , isArray        = __webpack_require__(179)
	  , anObject       = __webpack_require__(83)
	  , toIObject      = __webpack_require__(99)
	  , toPrimitive    = __webpack_require__(89)
	  , createDesc     = __webpack_require__(90)
	  , _create        = __webpack_require__(95)
	  , gOPNExt        = __webpack_require__(180)
	  , $GOPD          = __webpack_require__(182)
	  , $DP            = __webpack_require__(82)
	  , $keys          = __webpack_require__(97)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;

	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};

	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};

	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });

	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(181).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(138).f  = $propertyIsEnumerable;
	  __webpack_require__(137).f = $getOwnPropertySymbols;

	  if(DESCRIPTORS && !__webpack_require__(75)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }

	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}

	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});

	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});

	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(81)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(107)('meta')
	  , isObject = __webpack_require__(84)
	  , has      = __webpack_require__(92)
	  , setDesc  = __webpack_require__(82).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(87)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(77)
	  , core           = __webpack_require__(78)
	  , LIBRARY        = __webpack_require__(75)
	  , wksExt         = __webpack_require__(171)
	  , defineProperty = __webpack_require__(82).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(97)
	  , toIObject = __webpack_require__(99);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(97)
	  , gOPS    = __webpack_require__(137)
	  , pIE     = __webpack_require__(138);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(101);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(99)
	  , gOPN      = __webpack_require__(181).f
	  , toString  = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};

	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(98)
	  , hiddenKeys = __webpack_require__(108).concat('length', 'prototype');

	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(138)
	  , createDesc     = __webpack_require__(90)
	  , toIObject      = __webpack_require__(99)
	  , toPrimitive    = __webpack_require__(89)
	  , has            = __webpack_require__(92)
	  , IE8_DOM_DEFINE = __webpack_require__(85)
	  , gOPD           = Object.getOwnPropertyDescriptor;

	exports.f = __webpack_require__(86) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(176)('asyncIterator');

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(176)('observable');

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	var _stringify = __webpack_require__(186);

	var _stringify2 = _interopRequireDefault(_stringify);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	module.exports = {
	    /**
	     * 将数据放置到localstorage:类似于map的set方法，如果value不是string对象，会用JSON.stringify转化为string，
	     * @method setCookie
	     * @public
	     * @static
	     * @param {String} key key
	     * @param {String} value 值
	     */
	    set: function set(key, value) {
	        if (this.isSuppLocalStorage()) {
	            if (typeof value !== "string") {
	                value = (0, _stringify2.default)(value);
	            }
	            try {
	                window.localStorage.setItem(key, value);
	                return true;
	            } catch (e) {}
	        }
	        return false;
	    },
	    /**
	     * 将数据放置到localstorage:
	     *    如果value是string对象，直接設置到key的值里，
	     *    否则将改对象append到现有的localstorgae的key值里
	     * @method add
	     * @public
	     * @static
	     * @param {String} key key
	     * @param {String} value 值
	     */
	    add: function add(key, value) {
	        if (this.isSuppLocalStorage()) {
	            if (typeof value === "string") {
	                value = JSON.parse(value);
	            } else {
	                // JSON.parse
	                try {
	                    _extend(value, JSON.parse(this.get(key)));
	                } catch (e) {
	                    //  console.log(e);
	                }
	                value = (0, _stringify2.default)(value);
	            }
	            window.localStorage.setItem(key, value);
	            return true;
	        }
	        return false;
	    },
	    /**
	     * 从localstorage中获得数据
	     * @method get
	     * @public
	     * @static
	     * @param {String} key key
	     * @return {String} if not exist ,return null
	     */
	    get: function get(key) {
	        if (this.isSuppLocalStorage()) {
	            return window.localStorage.getItem(key);
	        }
	        return null;
	    },
	    //简单的做了一个window.localStorage.getItem 映射
	    /**
	     * 清除 localStorage
	     * @method removeValue
	     * @public
	     * @static
	     * @param {String} key key
	     */
	    removeValue: function removeValue(key) {
	        if (this.isSuppLocalStorage()) {
	            return window.localStorage.removeItem(key);
	        }
	    },
	    /**
	     * 清除所有localStorage
	     * @method clearAll
	     * @public
	     * @static
	     */
	    clearAll: function clearAll() {
	        if (this.isSuppLocalStorage()) {
	            return window.localStorage.clear();
	        }
	    },

	    /**
	     * 判断是否支持localStorage，并且开启
	     * @method isSuppLocalStorage
	     * @public
	     * @static
	     * @return {Boolean} ret
	     */
	    isSuppLocalStorage: function isSuppLocalStorage() {
	        if (this.supportStorage !== undefined) {
	            return this.supportStorage;
	        }
	        try {
	            if (window.localStorage === 'undefined') {
	                this.supportStorage = false;
	                return false;
	            } else {
	                var key = 'testSupportKey';
	                var support;
	                window.localStorage.setItem(key, '1');
	                var value = window.localStorage.getItem(key);
	                window.localStorage.removeItem(key);
	                support = '1' === value ? true : false;

	                this.supportStorage = support;
	                return support;
	            }
	        } catch (e) {}
	        this.supportStorage = false;
	        return false;
	    }
	};

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(187), __esModule: true };

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

	var core  = __webpack_require__(78)
	  , $JSON = core.JSON || (core.JSON = {stringify: JSON.stringify});
	module.exports = function stringify(it){ // eslint-disable-line no-unused-vars
	  return $JSON.stringify.apply($JSON, arguments);
	};

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _util = __webpack_require__(132);

	var _util2 = _interopRequireDefault(_util);

	var _highstock = __webpack_require__(189);

	var _highstock2 = _interopRequireDefault(_highstock);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var instance = null;
	exports.default = {
		initChart: function initChart(data) {
			instance = new _highstock2.default.StockChart({
				chart: {
					renderTo: 'stockWrap',
					className: 'stock-chart',
					backgroundColor: '#150d22',
					reflow: true,
					zoomType: '',
					panning: true,
					pinchType: true,
					resetZoomButton: {
						theme: {
							style: {
								display: 'none'
							}
						}
					}
				},

				events: {
					redraw: function redraw(event) {
						if (this.xAxis) {
							var extremes = this.xAxis[0].getExtremes();
							if (extremes && extremes.min == extremes.dataMin) {
								// console.log("time to load more data!");

							}
						}
					}
				},

				loading: {
					style: {
						backgroundColor: 'rgba(24,14,35,0.2)'
					},
					labelStyle: {
						color: 'white'
					}
				},

				title: {
					style: {
						display: 'none'
					}
				},

				colors: ['#2dcea4'],

				credits: {
					enabled: false
				},
				exporting: {
					enabled: false
				},

				navigator: {
					enabled: false,

					series: {
						data: data
					},
					maskFill: 'rgba(128, 179, 236, 0.1)',
					handles: {
						backgroundColor: '#9579DB',
						height: 100
					}
					// adaptToUpdatedData: false
				},

				scrollbar: {
					enabled: false,
					liveRedraw: false,
					height: 0
				},

				rangeSelector: {
					enabled: false,
					buttons: [{
						type: 'minute',
						count: 1,
						text: '1M'
					}, {
						type: 'minute',
						count: 5,
						text: '5M'
					}, {
						type: 'minute',
						count: 15,
						text: '15M'
					}, {
						type: 'minute',
						count: 30,
						text: '30M'
					}, {
						type: 'hour',
						count: 1,
						text: '1h'
					}, {
						type: 'day',
						count: 1,
						text: '1D'
					}, {
						type: 'all',
						count: 1,
						text: 'All'
					}],
					// selected: 0,//
					buttonSpacing: 0,
					inputEnabled: false,
					buttonTheme: {
						fill: '#1c2230',
						stroke: 'none',
						width: 100,
						'stroke-width': 0,
						r: 0,
						style: {
							color: '#807691',
							fontWeight: 'bold',
							fontSize: '.5rem'
						},
						states: {
							select: {
								fill: '#1b5f5e',
								style: {
									color: 'white'
								}
							}
						}
					},
					inputBoxBorderColor: 'gray',
					labelStyle: {
						color: 'red',
						fontWeight: 'bold',
						display: 'none'
					}
				},

				plotOptions: {
					candlestick: {
						lineColor: '#27c1a7',
						upLineColor: '#f74b47',
						color: '#27c1a7',
						upColor: '#f74b47'
					},
					series: {
						gapSize: 0
					}
				},

				xAxis: {
					gridLineColor: '#20182d',
					gridLineWidth: 1,

					// type: 'datetime',
					// minRange: 3600 * 1000 * 24 * 25

					events: {
						//afterSetExtremes : this.afterSetExtremes
					}

				},

				yAxis: {
					gridLineColor: '#20182d',
					// plotLines: [plotLines],
					endOnTick: false
				},

				series: [{
					// name: stockName,
					type: 'candlestick',
					data: data,
					id: 'dataseries',
					// pointWidth: 10,
					// maxPointWidth: 50,
					// minPointWidth: 50,
					dataGrouping: {
						enabled: false
					},
					tooltip: {
						valueDecimals: 2
					},
					tickPixelInterval: 100
				}],

				tooltip: {
					useHTML: true,
					formatter: function formatter(e) {
						return ['<p>' + _util2.default.formateDate(this.points[0].key) + '</p>', '<p>' + this.points[0].series.name + '</p>', '<p>开盘：' + this.points[0].point.open + '</p>', '<p>最高：' + this.points[0].point.high + '</p>', '<p>最低：' + this.points[0].point.low + '</p>', '<p>收盘：' + this.points[0].point.close + '</p>'].join('');
					},

					backgroundColor: 'rgba(22,14,27,0.85)',
					borderColor: '#2f2543'
				}

			});

			return instance;
		},
		setChartData: function setChartData(data) {
			instance && instance.get('dataseries').setData(data, true);
		},
		addChartPoint: function addChartPoint(point) {
			var data = instance.get('dataseries').data,
			    lastData = data[data.length - 1],
			    date = new Date(point[0]);

			if (true) {
				updata();
			}

			//updata the chart lastData
			function updata() {
				lastData.update(point);
			};

			function add() {
				// [x, open, high, low, close]
				var newPoint = [point[0], point[4], point[4], point[4], point[4]];
				try {
					instance.get('dataseries').addPoint(point, false, true);
					instance.series[1].addPoint(point, false, true);
					instance.redraw();

					return newPoint;
				} catch (e) {
					console.log(e);
				}
			}
		}
	};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {"use strict";

	var _typeof2 = __webpack_require__(168);

	var _typeof3 = _interopRequireDefault(_typeof2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*
	 Highstock JS v5.0.10 (2017-03-31)

	 (c) 2009-2016 Torstein Honsi

	 License: www.highcharts.com/license
	*/
	(function (K, a) {
	  "object" === ( false ? "undefined" : (0, _typeof3.default)(module)) && module.exports ? module.exports = K.document ? a(K) : a : K.Highcharts = a(K);
	})("undefined" !== typeof window ? window : undefined, function (K) {
	  K = function () {
	    var a = window,
	        D = a.document,
	        C = a.navigator && a.navigator.userAgent || "",
	        G = D && D.createElementNS && !!D.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
	        H = /(edge|msie|trident)/i.test(C) && !window.opera,
	        v = !G,
	        l = /Firefox/.test(C),
	        r = l && 4 > parseInt(C.split("Firefox/")[1], 10);return a.Highcharts ? a.Highcharts.error(16, !0) : { product: "Highstock",
	      version: "5.0.10", deg2rad: 2 * Math.PI / 360, doc: D, hasBidiBug: r, hasTouch: D && void 0 !== D.documentElement.ontouchstart, isMS: H, isWebKit: /AppleWebKit/.test(C), isFirefox: l, isTouchDevice: /(Mobile|Android|Windows Phone)/.test(C), SVG_NS: "http://www.w3.org/2000/svg", chartCount: 0, seriesTypes: {}, symbolSizes: {}, svg: G, vml: v, win: a, charts: [], marginNames: ["plotTop", "marginRight", "marginBottom", "plotLeft"], noop: function noop() {} };
	  }();(function (a) {
	    var D = [],
	        C = a.charts,
	        G = a.doc,
	        H = a.win;a.error = function (v, l) {
	      v = a.isNumber(v) ? "Highcharts error #" + v + ": www.highcharts.com/errors/" + v : v;if (l) throw Error(v);H.console && console.log(v);
	    };a.Fx = function (a, l, r) {
	      this.options = l;this.elem = a;this.prop = r;
	    };a.Fx.prototype = { dSetter: function dSetter() {
	        var a = this.paths[0],
	            l = this.paths[1],
	            r = [],
	            w = this.now,
	            q = a.length,
	            n;if (1 === w) r = this.toD;else if (q === l.length && 1 > w) for (; q--;) {
	          n = parseFloat(a[q]), r[q] = isNaN(n) ? a[q] : w * parseFloat(l[q] - n) + n;
	        } else r = l;this.elem.attr("d", r, null, !0);
	      }, update: function update() {
	        var a = this.elem,
	            l = this.prop,
	            r = this.now,
	            w = this.options.step;if (this[l + "Setter"]) this[l + "Setter"]();else a.attr ? a.element && a.attr(l, r, null, !0) : a.style[l] = r + this.unit;w && w.call(a, r, this);
	      }, run: function run(a, l, r) {
	        var v = this,
	            q = function q(a) {
	          return q.stopped ? !1 : v.step(a);
	        },
	            n;this.startTime = +new Date();this.start = a;this.end = l;this.unit = r;this.now = this.start;this.pos = 0;q.elem = this.elem;q.prop = this.prop;q() && 1 === D.push(q) && (q.timerId = setInterval(function () {
	          for (n = 0; n < D.length; n++) {
	            D[n]() || D.splice(n--, 1);
	          }D.length || clearInterval(q.timerId);
	        }, 13));
	      }, step: function step(a) {
	        var l = +new Date(),
	            v,
	            w = this.options;v = this.elem;
	        var q = w.complete,
	            n = w.duration,
	            f = w.curAnim,
	            c;if (v.attr && !v.element) v = !1;else if (a || l >= n + this.startTime) {
	          this.now = this.end;this.pos = 1;this.update();a = f[this.prop] = !0;for (c in f) {
	            !0 !== f[c] && (a = !1);
	          }a && q && q.call(v);v = !1;
	        } else this.pos = w.easing((l - this.startTime) / n), this.now = this.start + (this.end - this.start) * this.pos, this.update(), v = !0;return v;
	      }, initPath: function initPath(v, l, r) {
	        function w(a) {
	          var b, k;for (B = a.length; B--;) {
	            b = "M" === a[B] || "L" === a[B], k = /[a-zA-Z]/.test(a[B + 3]), b && k && a.splice(B + 1, 0, a[B + 1], a[B + 2], a[B + 1], a[B + 2]);
	          }
	        }function q(a, d) {
	          for (; a.length < t;) {
	            a[0] = d[t - a.length];var k = a.slice(0, b);[].splice.apply(a, [0, 0].concat(k));p && (k = a.slice(a.length - b), [].splice.apply(a, [a.length, 0].concat(k)), B--);
	          }a[0] = "M";
	        }function n(a, d) {
	          for (var k = (t - a.length) / b; 0 < k && k--;) {
	            h = a.slice().splice(a.length / x - b, b * x), h[0] = d[t - b - k * b], z && (h[b - 6] = h[b - 2], h[b - 5] = h[b - 1]), [].splice.apply(a, [a.length / x, 0].concat(h)), p && k--;
	          }
	        }l = l || "";var f,
	            c = v.startX,
	            e = v.endX,
	            z = -1 < l.indexOf("C"),
	            b = z ? 7 : 3,
	            t,
	            h,
	            B;l = l.split(" ");r = r.slice();var p = v.isArea,
	            x = p ? 2 : 1,
	            k;
	        z && (w(l), w(r));if (c && e) {
	          for (B = 0; B < c.length; B++) {
	            if (c[B] === e[0]) {
	              f = B;break;
	            } else if (c[0] === e[e.length - c.length + B]) {
	              f = B;k = !0;break;
	            }
	          }void 0 === f && (l = []);
	        }l.length && a.isNumber(f) && (t = r.length + f * x * b, k ? (q(l, r), n(r, l)) : (q(r, l), n(l, r)));return [l, r];
	      } };a.extend = function (a, l) {
	      var v;a || (a = {});for (v in l) {
	        a[v] = l[v];
	      }return a;
	    };a.merge = function () {
	      var v,
	          l = arguments,
	          r,
	          w = {},
	          q = function q(n, f) {
	        var c, e;"object" !== (typeof n === "undefined" ? "undefined" : (0, _typeof3.default)(n)) && (n = {});for (e in f) {
	          f.hasOwnProperty(e) && (c = f[e], a.isObject(c, !0) && "renderTo" !== e && "number" !== typeof c.nodeType ? n[e] = q(n[e] || {}, c) : n[e] = f[e]);
	        }return n;
	      };!0 === l[0] && (w = l[1], l = Array.prototype.slice.call(l, 2));r = l.length;for (v = 0; v < r; v++) {
	        w = q(w, l[v]);
	      }return w;
	    };a.pInt = function (a, l) {
	      return parseInt(a, l || 10);
	    };a.isString = function (a) {
	      return "string" === typeof a;
	    };a.isArray = function (a) {
	      a = Object.prototype.toString.call(a);return "[object Array]" === a || "[object Array Iterator]" === a;
	    };a.isObject = function (v, l) {
	      return v && "object" === (typeof v === "undefined" ? "undefined" : (0, _typeof3.default)(v)) && (!l || !a.isArray(v));
	    };a.isNumber = function (a) {
	      return "number" === typeof a && !isNaN(a);
	    };a.erase = function (a, l) {
	      for (var v = a.length; v--;) {
	        if (a[v] === l) {
	          a.splice(v, 1);break;
	        }
	      }
	    };a.defined = function (a) {
	      return void 0 !== a && null !== a;
	    };a.attr = function (v, l, r) {
	      var w, q;if (a.isString(l)) a.defined(r) ? v.setAttribute(l, r) : v && v.getAttribute && (q = v.getAttribute(l));else if (a.defined(l) && a.isObject(l)) for (w in l) {
	        v.setAttribute(w, l[w]);
	      }return q;
	    };a.splat = function (v) {
	      return a.isArray(v) ? v : [v];
	    };a.syncTimeout = function (a, l, r) {
	      if (l) return setTimeout(a, l, r);a.call(0, r);
	    };a.pick = function () {
	      var a = arguments,
	          l,
	          r,
	          w = a.length;for (l = 0; l < w; l++) {
	        if (r = a[l], void 0 !== r && null !== r) return r;
	      }
	    };a.css = function (v, l) {
	      a.isMS && !a.svg && l && void 0 !== l.opacity && (l.filter = "alpha(opacity\x3d" + 100 * l.opacity + ")");a.extend(v.style, l);
	    };a.createElement = function (v, l, r, w, q) {
	      v = G.createElement(v);var n = a.css;l && a.extend(v, l);q && n(v, { padding: 0, border: "none", margin: 0 });r && n(v, r);w && w.appendChild(v);return v;
	    };a.extendClass = function (v, l) {
	      var r = function r() {};r.prototype = new v();a.extend(r.prototype, l);return r;
	    };a.pad = function (a, l, r) {
	      return Array((l || 2) + 1 - String(a).length).join(r || 0) + a;
	    };a.relativeLength = function (a, l) {
	      return (/%$/.test(a) ? l * parseFloat(a) / 100 : parseFloat(a)
	      );
	    };a.wrap = function (a, l, r) {
	      var w = a[l];a[l] = function () {
	        var a = Array.prototype.slice.call(arguments),
	            n = arguments,
	            f = this;f.proceed = function () {
	          w.apply(f, arguments.length ? arguments : n);
	        };a.unshift(w);a = r.apply(this, a);f.proceed = null;return a;
	      };
	    };a.getTZOffset = function (v) {
	      var l = a.Date;return 6E4 * (l.hcGetTimezoneOffset && l.hcGetTimezoneOffset(v) || l.hcTimezoneOffset || 0);
	    };a.dateFormat = function (v, l, r) {
	      if (!a.defined(l) || isNaN(l)) return a.defaultOptions.lang.invalidDate || "";v = a.pick(v, "%Y-%m-%d %H:%M:%S");var w = a.Date,
	          q = new w(l - a.getTZOffset(l)),
	          n,
	          f = q[w.hcGetHours](),
	          c = q[w.hcGetDay](),
	          e = q[w.hcGetDate](),
	          z = q[w.hcGetMonth](),
	          b = q[w.hcGetFullYear](),
	          t = a.defaultOptions.lang,
	          h = t.weekdays,
	          B = t.shortWeekdays,
	          p = a.pad,
	          w = a.extend({ a: B ? B[c] : h[c].substr(0, 3), A: h[c], d: p(e), e: p(e, 2, " "), w: c, b: t.shortMonths[z], B: t.months[z], m: p(z + 1), y: b.toString().substr(2, 2), Y: b, H: p(f), k: f, I: p(f % 12 || 12), l: f % 12 || 12, M: p(q[w.hcGetMinutes]()), p: 12 > f ? "AM" : "PM", P: 12 > f ? "am" : "pm", S: p(q.getSeconds()), L: p(Math.round(l % 1E3), 3) }, a.dateFormats);for (n in w) {
	        for (; -1 !== v.indexOf("%" + n);) {
	          v = v.replace("%" + n, "function" === typeof w[n] ? w[n](l) : w[n]);
	        }
	      }return r ? v.substr(0, 1).toUpperCase() + v.substr(1) : v;
	    };a.formatSingle = function (v, l) {
	      var r = /\.([0-9])/,
	          w = a.defaultOptions.lang;/f$/.test(v) ? (r = (r = v.match(r)) ? r[1] : -1, null !== l && (l = a.numberFormat(l, r, w.decimalPoint, -1 < v.indexOf(",") ? w.thousandsSep : ""))) : l = a.dateFormat(v, l);return l;
	    };a.format = function (v, l) {
	      for (var r = "{", w = !1, q, n, f, c, e = [], z; v;) {
	        r = v.indexOf(r);if (-1 === r) break;q = v.slice(0, r);if (w) {
	          q = q.split(":");n = q.shift().split(".");c = n.length;z = l;for (f = 0; f < c; f++) {
	            z = z[n[f]];
	          }q.length && (z = a.formatSingle(q.join(":"), z));e.push(z);
	        } else e.push(q);v = v.slice(r + 1);r = (w = !w) ? "}" : "{";
	      }e.push(v);return e.join("");
	    };a.getMagnitude = function (a) {
	      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));
	    };a.normalizeTickInterval = function (v, l, r, w, q) {
	      var n,
	          f = v;r = a.pick(r, 1);n = v / r;l || (l = q ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === w && (1 === r ? l = a.grep(l, function (a) {
	        return 0 === a % 1;
	      }) : .1 >= r && (l = [1 / r])));
	      for (w = 0; w < l.length && !(f = l[w], q && f * r >= v || !q && n <= (l[w] + (l[w + 1] || l[w])) / 2); w++) {}return f = a.correctFloat(f * r, -Math.round(Math.log(.001) / Math.LN10));
	    };a.stableSort = function (a, l) {
	      var r = a.length,
	          w,
	          q;for (q = 0; q < r; q++) {
	        a[q].safeI = q;
	      }a.sort(function (a, f) {
	        w = l(a, f);return 0 === w ? a.safeI - f.safeI : w;
	      });for (q = 0; q < r; q++) {
	        delete a[q].safeI;
	      }
	    };a.arrayMin = function (a) {
	      for (var l = a.length, r = a[0]; l--;) {
	        a[l] < r && (r = a[l]);
	      }return r;
	    };a.arrayMax = function (a) {
	      for (var l = a.length, r = a[0]; l--;) {
	        a[l] > r && (r = a[l]);
	      }return r;
	    };a.destroyObjectProperties = function (a, l) {
	      for (var r in a) {
	        a[r] && a[r] !== l && a[r].destroy && a[r].destroy(), delete a[r];
	      }
	    };a.discardElement = function (v) {
	      var l = a.garbageBin;l || (l = a.createElement("div"));v && l.appendChild(v);l.innerHTML = "";
	    };a.correctFloat = function (a, l) {
	      return parseFloat(a.toPrecision(l || 14));
	    };a.setAnimation = function (v, l) {
	      l.renderer.globalAnimation = a.pick(v, l.options.chart.animation, !0);
	    };a.animObject = function (v) {
	      return a.isObject(v) ? a.merge(v) : { duration: v ? 500 : 0 };
	    };a.timeUnits = { millisecond: 1, second: 1E3, minute: 6E4, hour: 36E5,
	      day: 864E5, week: 6048E5, month: 24192E5, year: 314496E5 };a.numberFormat = function (v, l, r, w) {
	      v = +v || 0;l = +l;var q = a.defaultOptions.lang,
	          n = (v.toString().split(".")[1] || "").length,
	          f,
	          c;-1 === l ? l = Math.min(n, 20) : a.isNumber(l) || (l = 2);c = (Math.abs(v) + Math.pow(10, -Math.max(l, n) - 1)).toFixed(l);n = String(a.pInt(c));f = 3 < n.length ? n.length % 3 : 0;r = a.pick(r, q.decimalPoint);w = a.pick(w, q.thousandsSep);v = (0 > v ? "-" : "") + (f ? n.substr(0, f) + w : "");v += n.substr(f).replace(/(\d{3})(?=\d)/g, "$1" + w);l && (v += r + c.slice(-l));return v;
	    };Math.easeInOutSine = function (a) {
	      return -.5 * (Math.cos(Math.PI * a) - 1);
	    };a.getStyle = function (v, l) {
	      return "width" === l ? Math.min(v.offsetWidth, v.scrollWidth) - a.getStyle(v, "padding-left") - a.getStyle(v, "padding-right") : "height" === l ? Math.min(v.offsetHeight, v.scrollHeight) - a.getStyle(v, "padding-top") - a.getStyle(v, "padding-bottom") : (v = H.getComputedStyle(v, void 0)) && a.pInt(v.getPropertyValue(l));
	    };a.inArray = function (a, l) {
	      return l.indexOf ? l.indexOf(a) : [].indexOf.call(l, a);
	    };a.grep = function (a, l) {
	      return [].filter.call(a, l);
	    };a.find = function (a, l) {
	      return [].find.call(a, l);
	    };a.map = function (a, l) {
	      for (var r = [], w = 0, q = a.length; w < q; w++) {
	        r[w] = l.call(a[w], a[w], w, a);
	      }return r;
	    };a.offset = function (a) {
	      var l = G.documentElement;a = a.getBoundingClientRect();return { top: a.top + (H.pageYOffset || l.scrollTop) - (l.clientTop || 0), left: a.left + (H.pageXOffset || l.scrollLeft) - (l.clientLeft || 0) };
	    };a.stop = function (a, l) {
	      for (var r = D.length; r--;) {
	        D[r].elem !== a || l && l !== D[r].prop || (D[r].stopped = !0);
	      }
	    };a.each = function (a, l, r) {
	      return Array.prototype.forEach.call(a, l, r);
	    };a.addEvent = function (v, l, r) {
	      function w(a) {
	        a.target = a.srcElement || H;r.call(v, a);
	      }var q = v.hcEvents = v.hcEvents || {};v.addEventListener ? v.addEventListener(l, r, !1) : v.attachEvent && (v.hcEventsIE || (v.hcEventsIE = {}), v.hcEventsIE[r.toString()] = w, v.attachEvent("on" + l, w));q[l] || (q[l] = []);q[l].push(r);return function () {
	        a.removeEvent(v, l, r);
	      };
	    };a.removeEvent = function (v, l, r) {
	      function w(a, c) {
	        v.removeEventListener ? v.removeEventListener(a, c, !1) : v.attachEvent && (c = v.hcEventsIE[c.toString()], v.detachEvent("on" + a, c));
	      }function q() {
	        var a, c;if (v.nodeName) for (c in l ? (a = {}, a[l] = !0) : a = f, a) {
	          if (f[c]) for (a = f[c].length; a--;) {
	            w(c, f[c][a]);
	          }
	        }
	      }var n,
	          f = v.hcEvents,
	          c;f && (l ? (n = f[l] || [], r ? (c = a.inArray(r, n), -1 < c && (n.splice(c, 1), f[l] = n), w(l, r)) : (q(), f[l] = [])) : (q(), v.hcEvents = {}));
	    };a.fireEvent = function (v, l, r, w) {
	      var q;q = v.hcEvents;var n, f;r = r || {};if (G.createEvent && (v.dispatchEvent || v.fireEvent)) q = G.createEvent("Events"), q.initEvent(l, !0, !0), a.extend(q, r), v.dispatchEvent ? v.dispatchEvent(q) : v.fireEvent(l, q);else if (q) for (q = q[l] || [], n = q.length, r.target || a.extend(r, { preventDefault: function preventDefault() {
	          r.defaultPrevented = !0;
	        }, target: v, type: l }), l = 0; l < n; l++) {
	        (f = q[l]) && !1 === f.call(v, r) && r.preventDefault();
	      }w && !r.defaultPrevented && w(r);
	    };a.animate = function (v, l, r) {
	      var w,
	          q = "",
	          n,
	          f,
	          c;a.isObject(r) || (w = arguments, r = { duration: w[2], easing: w[3], complete: w[4] });a.isNumber(r.duration) || (r.duration = 400);r.easing = "function" === typeof r.easing ? r.easing : Math[r.easing] || Math.easeInOutSine;r.curAnim = a.merge(l);for (c in l) {
	        a.stop(v, c), f = new a.Fx(v, r, c), n = null, "d" === c ? (f.paths = f.initPath(v, v.d, l.d), f.toD = l.d, w = 0, n = 1) : v.attr ? w = v.attr(c) : (w = parseFloat(a.getStyle(v, c)) || 0, "opacity" !== c && (q = "px")), n || (n = l[c]), n && n.match && n.match("px") && (n = n.replace(/px/g, "")), f.run(w, n, q);
	      }
	    };a.seriesType = function (v, l, r, w, q) {
	      var n = a.getOptions(),
	          f = a.seriesTypes;n.plotOptions[v] = a.merge(n.plotOptions[l], r);f[v] = a.extendClass(f[l] || function () {}, w);f[v].prototype.type = v;q && (f[v].prototype.pointClass = a.extendClass(a.Point, q));return f[v];
	    };a.uniqueKey = function () {
	      var a = Math.random().toString(36).substring(2, 9),
	          l = 0;return function () {
	        return "highcharts-" + a + "-" + l++;
	      };
	    }();H.jQuery && (H.jQuery.fn.highcharts = function () {
	      var v = [].slice.call(arguments);if (this[0]) return v[0] ? (new a[a.isString(v[0]) ? v.shift() : "Chart"](this[0], v[0], v[1]), this) : C[a.attr(this[0], "data-highcharts-chart")];
	    });G && !G.defaultView && (a.getStyle = function (v, l) {
	      var r = { width: "clientWidth", height: "clientHeight" }[l];if (v.style[l]) return a.pInt(v.style[l]);"opacity" === l && (l = "filter");if (r) return v.style.zoom = 1, Math.max(v[r] - 2 * a.getStyle(v, "padding"), 0);v = v.currentStyle[l.replace(/\-(\w)/g, function (a, q) {
	        return q.toUpperCase();
	      })];"filter" === l && (v = v.replace(/alpha\(opacity=([0-9]+)\)/, function (a, q) {
	        return q / 100;
	      }));return "" === v ? 1 : a.pInt(v);
	    });Array.prototype.forEach || (a.each = function (a, l, r) {
	      for (var w = 0, q = a.length; w < q; w++) {
	        if (!1 === l.call(r, a[w], w, a)) return w;
	      }
	    });Array.prototype.indexOf || (a.inArray = function (a, l) {
	      var r,
	          w = 0;if (l) for (r = l.length; w < r; w++) {
	        if (l[w] === a) return w;
	      }return -1;
	    });Array.prototype.filter || (a.grep = function (a, l) {
	      for (var r = [], w = 0, q = a.length; w < q; w++) {
	        l(a[w], w) && r.push(a[w]);
	      }return r;
	    });Array.prototype.find || (a.find = function (a, l) {
	      var r,
	          w = a.length;for (r = 0; r < w; r++) {
	        if (l(a[r], r)) return a[r];
	      }
	    });
	  })(K);(function (a) {
	    var D = a.each,
	        C = a.isNumber,
	        G = a.map,
	        H = a.merge,
	        v = a.pInt;a.Color = function (l) {
	      if (!(this instanceof a.Color)) return new a.Color(l);this.init(l);
	    };a.Color.prototype = { parsers: [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function parse(a) {
	          return [v(a[1]), v(a[2]), v(a[3]), parseFloat(a[4], 10)];
	        } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function parse(a) {
	          return [v(a[1]), v(a[2]), v(a[3]), 1];
	        } }], names: { white: "#ffffff", black: "#000000" }, init: function init(l) {
	        var r, w, q, n;if ((this.input = l = this.names[l && l.toLowerCase ? l.toLowerCase() : ""] || l) && l.stops) this.stops = G(l.stops, function (f) {
	          return new a.Color(f[1]);
	        });else if (l && "#" === l[0] && (r = l.length, l = parseInt(l.substr(1), 16), 7 === r ? w = [(l & 16711680) >> 16, (l & 65280) >> 8, l & 255, 1] : 4 === r && (w = [(l & 3840) >> 4 | (l & 3840) >> 8, (l & 240) >> 4 | l & 240, (l & 15) << 4 | l & 15, 1])), !w) for (q = this.parsers.length; q-- && !w;) {
	          n = this.parsers[q], (r = n.regex.exec(l)) && (w = n.parse(r));
	        }this.rgba = w || [];
	      }, get: function get(a) {
	        var l = this.input,
	            w = this.rgba,
	            q;this.stops ? (q = H(l), q.stops = [].concat(q.stops), D(this.stops, function (n, f) {
	          q.stops[f] = [q.stops[f][0], n.get(a)];
	        })) : q = w && C(w[0]) ? "rgb" === a || !a && 1 === w[3] ? "rgb(" + w[0] + "," + w[1] + "," + w[2] + ")" : "a" === a ? w[3] : "rgba(" + w.join(",") + ")" : l;return q;
	      }, brighten: function brighten(a) {
	        var l,
	            w = this.rgba;if (this.stops) D(this.stops, function (q) {
	          q.brighten(a);
	        });else if (C(a) && 0 !== a) for (l = 0; 3 > l; l++) {
	          w[l] += v(255 * a), 0 > w[l] && (w[l] = 0), 255 < w[l] && (w[l] = 255);
	        }return this;
	      }, setOpacity: function setOpacity(a) {
	        this.rgba[3] = a;return this;
	      } };a.color = function (l) {
	      return new a.Color(l);
	    };
	  })(K);(function (a) {
	    var D,
	        C,
	        G = a.addEvent,
	        H = a.animate,
	        v = a.attr,
	        l = a.charts,
	        r = a.color,
	        w = a.css,
	        q = a.createElement,
	        n = a.defined,
	        f = a.deg2rad,
	        c = a.destroyObjectProperties,
	        e = a.doc,
	        z = a.each,
	        b = a.extend,
	        t = a.erase,
	        h = a.grep,
	        B = a.hasTouch,
	        p = a.inArray,
	        x = a.isArray,
	        k = a.isFirefox,
	        F = a.isMS,
	        d = a.isObject,
	        u = a.isString,
	        m = a.isWebKit,
	        y = a.merge,
	        J = a.noop,
	        E = a.pick,
	        I = a.pInt,
	        g = a.removeEvent,
	        L = a.stop,
	        R = a.svg,
	        O = a.SVG_NS,
	        M = a.symbolSizes,
	        P = a.win;D = a.SVGElement = function () {
	      return this;
	    };
	    D.prototype = { opacity: 1, SVG_NS: O, textProps: "direction fontSize fontWeight fontFamily fontStyle color lineHeight width textAlign textDecoration textOverflow textOutline".split(" "), init: function init(a, g) {
	        this.element = "span" === g ? q(g) : e.createElementNS(this.SVG_NS, g);this.renderer = a;
	      }, animate: function animate(A, g, b) {
	        g = a.animObject(E(g, this.renderer.globalAnimation, !0));0 !== g.duration ? (b && (g.complete = b), H(this, A, g)) : (this.attr(A, null, b), g.step && g.step.call(this));return this;
	      }, colorGradient: function colorGradient(A, g, b) {
	        var k = this.renderer,
	            d,
	            m,
	            c,
	            h,
	            L,
	            E,
	            F,
	            u,
	            Q,
	            p,
	            t,
	            e = [],
	            I;A.radialGradient ? m = "radialGradient" : A.linearGradient && (m = "linearGradient");if (m) {
	          c = A[m];L = k.gradients;F = A.stops;p = b.radialReference;x(c) && (A[m] = c = { x1: c[0], y1: c[1], x2: c[2], y2: c[3], gradientUnits: "userSpaceOnUse" });"radialGradient" === m && p && !n(c.gradientUnits) && (h = c, c = y(c, k.getRadialAttr(p, h), { gradientUnits: "userSpaceOnUse" }));for (t in c) {
	            "id" !== t && e.push(t, c[t]);
	          }for (t in F) {
	            e.push(F[t]);
	          }e = e.join(",");L[e] ? p = L[e].attr("id") : (c.id = p = a.uniqueKey(), L[e] = E = k.createElement(m).attr(c).add(k.defs), E.radAttr = h, E.stops = [], z(F, function (A) {
	            0 === A[1].indexOf("rgba") ? (d = a.color(A[1]), u = d.get("rgb"), Q = d.get("a")) : (u = A[1], Q = 1);A = k.createElement("stop").attr({ offset: A[0], "stop-color": u, "stop-opacity": Q }).add(E);E.stops.push(A);
	          }));I = "url(" + k.url + "#" + p + ")";b.setAttribute(g, I);b.gradient = e;A.toString = function () {
	            return I;
	          };
	        }
	      }, applyTextOutline: function applyTextOutline(A) {
	        var g = this.element,
	            b,
	            k,
	            d,
	            m,
	            c;-1 !== A.indexOf("contrast") && (A = A.replace(/contrast/g, this.renderer.getContrast(g.style.fill)));A = A.split(" ");k = A[A.length - 1];
	        if ((d = A[0]) && "none" !== d && a.svg) {
	          this.fakeTS = !0;A = [].slice.call(g.getElementsByTagName("tspan"));this.ySetter = this.xSetter;d = d.replace(/(^[\d\.]+)(.*?)$/g, function (a, A, g) {
	            return 2 * A + g;
	          });for (c = A.length; c--;) {
	            b = A[c], "highcharts-text-outline" === b.getAttribute("class") && t(A, g.removeChild(b));
	          }m = g.firstChild;z(A, function (a, A) {
	            0 === A && (a.setAttribute("x", g.getAttribute("x")), A = g.getAttribute("y"), a.setAttribute("y", A || 0), null === A && g.setAttribute("y", 0));a = a.cloneNode(1);v(a, { "class": "highcharts-text-outline",
	              fill: k, stroke: k, "stroke-width": d, "stroke-linejoin": "round" });g.insertBefore(a, m);
	          });
	        }
	      }, attr: function attr(a, g, b, k) {
	        var A,
	            d = this.element,
	            m,
	            c = this,
	            h;"string" === typeof a && void 0 !== g && (A = a, a = {}, a[A] = g);if ("string" === typeof a) c = (this[a + "Getter"] || this._defaultGetter).call(this, a, d);else {
	          for (A in a) {
	            g = a[A], h = !1, k || L(this, A), this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/.test(A) && (m || (this.symbolAttr(a), m = !0), h = !0), !this.rotation || "x" !== A && "y" !== A || (this.doTransform = !0), h || (h = this[A + "Setter"] || this._defaultSetter, h.call(this, g, A, d), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(A) && this.updateShadows(A, g, h));
	          }this.doTransform && (this.updateTransform(), this.doTransform = !1);
	        }b && b();return c;
	      }, updateShadows: function updateShadows(a, g, b) {
	        for (var A = this.shadows, k = A.length; k--;) {
	          b.call(A[k], "height" === a ? Math.max(g - (A[k].cutHeight || 0), 0) : "d" === a ? this.d : g, a, A[k]);
	        }
	      }, addClass: function addClass(a, g) {
	        var A = this.attr("class") || "";-1 === A.indexOf(a) && (g || (a = (A + (A ? " " : "") + a).replace("  ", " ")), this.attr("class", a));return this;
	      }, hasClass: function hasClass(a) {
	        return -1 !== v(this.element, "class").indexOf(a);
	      }, removeClass: function removeClass(a) {
	        v(this.element, "class", (v(this.element, "class") || "").replace(a, ""));return this;
	      }, symbolAttr: function symbolAttr(a) {
	        var A = this;z("x y r start end width height innerR anchorX anchorY".split(" "), function (g) {
	          A[g] = E(a[g], A[g]);
	        });A.attr({ d: A.renderer.symbols[A.symbolName](A.x, A.y, A.width, A.height, A) });
	      }, clip: function clip(a) {
	        return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : "none");
	      }, crisp: function crisp(a, g) {
	        var A,
	            b = {},
	            k;g = g || a.strokeWidth || 0;k = Math.round(g) % 2 / 2;a.x = Math.floor(a.x || this.x || 0) + k;a.y = Math.floor(a.y || this.y || 0) + k;a.width = Math.floor((a.width || this.width || 0) - 2 * k);a.height = Math.floor((a.height || this.height || 0) - 2 * k);n(a.strokeWidth) && (a.strokeWidth = g);for (A in a) {
	          this[A] !== a[A] && (this[A] = b[A] = a[A]);
	        }return b;
	      }, css: function css(a) {
	        var A = this.styles,
	            g = {},
	            k = this.element,
	            d,
	            m = "",
	            c = !A,
	            h = ["textOutline", "textOverflow", "width"];a && a.color && (a.fill = a.color);if (A) for (d in a) {
	          a[d] !== A[d] && (g[d] = a[d], c = !0);
	        }if (c) {
	          A && (a = b(A, g));A = this.textWidth = a && a.width && "auto" !== a.width && "text" === k.nodeName.toLowerCase() && I(a.width);this.styles = a;A && !R && this.renderer.forExport && delete a.width;if (F && !R) w(this.element, a);else {
	            A = function A(a, _A) {
	              return "-" + _A.toLowerCase();
	            };for (d in a) {
	              -1 === p(d, h) && (m += d.replace(/([A-Z])/g, A) + ":" + a[d] + ";");
	            }m && v(k, "style", m);
	          }this.added && ("text" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline));
	        }return this;
	      }, strokeWidth: function strokeWidth() {
	        return this["stroke-width"] || 0;
	      }, on: function on(a, g) {
	        var A = this,
	            b = A.element;B && "click" === a ? (b.ontouchstart = function (a) {
	          A.touchEventFired = Date.now();a.preventDefault();g.call(b, a);
	        }, b.onclick = function (a) {
	          (-1 === P.navigator.userAgent.indexOf("Android") || 1100 < Date.now() - (A.touchEventFired || 0)) && g.call(b, a);
	        }) : b["on" + a] = g;return this;
	      }, setRadialReference: function setRadialReference(a) {
	        var A = this.renderer.gradients[this.element.gradient];this.element.radialReference = a;A && A.radAttr && A.animate(this.renderer.getRadialAttr(a, A.radAttr));return this;
	      }, translate: function translate(a, g) {
	        return this.attr({ translateX: a, translateY: g });
	      }, invert: function invert(a) {
	        this.inverted = a;this.updateTransform();return this;
	      }, updateTransform: function updateTransform() {
	        var a = this.translateX || 0,
	            g = this.translateY || 0,
	            b = this.scaleX,
	            k = this.scaleY,
	            d = this.inverted,
	            m = this.rotation,
	            c = this.element;d && (a += this.width, g += this.height);a = ["translate(" + a + "," + g + ")"];d ? a.push("rotate(90) scale(-1,1)") : m && a.push("rotate(" + m + " " + (c.getAttribute("x") || 0) + " " + (c.getAttribute("y") || 0) + ")");(n(b) || n(k)) && a.push("scale(" + E(b, 1) + " " + E(k, 1) + ")");
	        a.length && c.setAttribute("transform", a.join(" "));
	      }, toFront: function toFront() {
	        var a = this.element;a.parentNode.appendChild(a);return this;
	      }, align: function align(a, g, b) {
	        var A,
	            k,
	            d,
	            m,
	            c = {};k = this.renderer;d = k.alignedObjects;var h, y;if (a) {
	          if (this.alignOptions = a, this.alignByTranslate = g, !b || u(b)) this.alignTo = A = b || "renderer", t(d, this), d.push(this), b = null;
	        } else a = this.alignOptions, g = this.alignByTranslate, A = this.alignTo;b = E(b, k[A], k);A = a.align;k = a.verticalAlign;d = (b.x || 0) + (a.x || 0);m = (b.y || 0) + (a.y || 0);"right" === A ? h = 1 : "center" === A && (h = 2);h && (d += (b.width - (a.width || 0)) / h);c[g ? "translateX" : "x"] = Math.round(d);"bottom" === k ? y = 1 : "middle" === k && (y = 2);y && (m += (b.height - (a.height || 0)) / y);c[g ? "translateY" : "y"] = Math.round(m);this[this.placed ? "animate" : "attr"](c);this.placed = !0;this.alignAttr = c;return this;
	      }, getBBox: function getBBox(a, g) {
	        var A,
	            k = this.renderer,
	            d,
	            m = this.element,
	            c = this.styles,
	            h,
	            y = this.textStr,
	            L,
	            F = k.cache,
	            u = k.cacheKeys,
	            p;g = E(g, this.rotation);d = g * f;h = c && c.fontSize;void 0 !== y && (p = y.toString(), -1 === p.indexOf("\x3c") && (p = p.replace(/[0-9]/g, "0")), p += ["", g || 0, h, c && c.width, c && c.textOverflow].join());p && !a && (A = F[p]);if (!A) {
	          if (m.namespaceURI === this.SVG_NS || k.forExport) {
	            try {
	              (L = this.fakeTS && function (a) {
	                z(m.querySelectorAll(".highcharts-text-outline"), function (A) {
	                  A.style.display = a;
	                });
	              }) && L("none"), A = m.getBBox ? b({}, m.getBBox()) : { width: m.offsetWidth, height: m.offsetHeight }, L && L("");
	            } catch (U) {}if (!A || 0 > A.width) A = { width: 0, height: 0 };
	          } else A = this.htmlGetBBox();k.isSVG && (a = A.width, k = A.height, c && "11px" === c.fontSize && 17 === Math.round(k) && (A.height = k = 14), g && (A.width = Math.abs(k * Math.sin(d)) + Math.abs(a * Math.cos(d)), A.height = Math.abs(k * Math.cos(d)) + Math.abs(a * Math.sin(d))));if (p && 0 < A.height) {
	            for (; 250 < u.length;) {
	              delete F[u.shift()];
	            }F[p] || u.push(p);F[p] = A;
	          }
	        }return A;
	      }, show: function show(a) {
	        return this.attr({ visibility: a ? "inherit" : "visible" });
	      }, hide: function hide() {
	        return this.attr({ visibility: "hidden" });
	      }, fadeOut: function fadeOut(a) {
	        var A = this;A.animate({ opacity: 0 }, { duration: a || 150, complete: function complete() {
	            A.attr({ y: -9999 });
	          } });
	      }, add: function add(a) {
	        var A = this.renderer,
	            g = this.element,
	            b;a && (this.parentGroup = a);this.parentInverted = a && a.inverted;void 0 !== this.textStr && A.buildText(this);this.added = !0;if (!a || a.handleZ || this.zIndex) b = this.zIndexSetter();b || (a ? a.element : A.box).appendChild(g);if (this.onAdd) this.onAdd();return this;
	      }, safeRemoveChild: function safeRemoveChild(a) {
	        var A = a.parentNode;A && A.removeChild(a);
	      }, destroy: function destroy() {
	        var a = this,
	            g = a.element || {},
	            b = a.renderer.isSVG && "SPAN" === g.nodeName && a.parentGroup,
	            k,
	            d;g.onclick = g.onmouseout = g.onmouseover = g.onmousemove = g.point = null;L(a);a.clipPath && (z(a.element.ownerSVGElement.querySelectorAll("[clip-path]"), function (g) {
	          -1 < g.getAttribute("clip-path").indexOf(a.clipPath.element.id) && g.removeAttribute("clip-path");
	        }), a.clipPath = a.clipPath.destroy());if (a.stops) {
	          for (d = 0; d < a.stops.length; d++) {
	            a.stops[d] = a.stops[d].destroy();
	          }a.stops = null;
	        }a.safeRemoveChild(g);for (a.destroyShadows(); b && b.div && 0 === b.div.childNodes.length;) {
	          g = b.parentGroup, a.safeRemoveChild(b.div), delete b.div, b = g;
	        }a.alignTo && t(a.renderer.alignedObjects, a);for (k in a) {
	          delete a[k];
	        }return null;
	      }, shadow: function shadow(a, g, b) {
	        var A = [],
	            k,
	            d,
	            m = this.element,
	            c,
	            h,
	            y,
	            L;if (!a) this.destroyShadows();else if (!this.shadows) {
	          h = E(a.width, 3);y = (a.opacity || .15) / h;L = this.parentInverted ? "(-1,-1)" : "(" + E(a.offsetX, 1) + ", " + E(a.offsetY, 1) + ")";for (k = 1; k <= h; k++) {
	            d = m.cloneNode(0), c = 2 * h + 1 - 2 * k, v(d, { isShadow: "true", stroke: a.color || "#000000", "stroke-opacity": y * k, "stroke-width": c, transform: "translate" + L, fill: "none" }), b && (v(d, "height", Math.max(v(d, "height") - c, 0)), d.cutHeight = c), g ? g.element.appendChild(d) : m.parentNode.insertBefore(d, m), A.push(d);
	          }this.shadows = A;
	        }return this;
	      }, destroyShadows: function destroyShadows() {
	        z(this.shadows || [], function (a) {
	          this.safeRemoveChild(a);
	        }, this);this.shadows = void 0;
	      }, xGetter: function xGetter(a) {
	        "circle" === this.element.nodeName && ("x" === a ? a = "cx" : "y" === a && (a = "cy"));return this._defaultGetter(a);
	      }, _defaultGetter: function _defaultGetter(a) {
	        a = E(this[a], this.element ? this.element.getAttribute(a) : null, 0);/^[\-0-9\.]+$/.test(a) && (a = parseFloat(a));return a;
	      }, dSetter: function dSetter(a, g, b) {
	        a && a.join && (a = a.join(" "));/(NaN| {2}|^$)/.test(a) && (a = "M 0 0");b.setAttribute(g, a);this[g] = a;
	      }, dashstyleSetter: function dashstyleSetter(a) {
	        var g,
	            A = this["stroke-width"];
	        "inherit" === A && (A = 1);if (a = a && a.toLowerCase()) {
	          a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");for (g = a.length; g--;) {
	            a[g] = I(a[g]) * A;
	          }a = a.join(",").replace(/NaN/g, "none");this.element.setAttribute("stroke-dasharray", a);
	        }
	      }, alignSetter: function alignSetter(a) {
	        this.element.setAttribute("text-anchor", { left: "start", center: "middle", right: "end" }[a]);
	      },
	      opacitySetter: function opacitySetter(a, g, b) {
	        this[g] = a;b.setAttribute(g, a);
	      }, titleSetter: function titleSetter(a) {
	        var g = this.element.getElementsByTagName("title")[0];g || (g = e.createElementNS(this.SVG_NS, "title"), this.element.appendChild(g));g.firstChild && g.removeChild(g.firstChild);g.appendChild(e.createTextNode(String(E(a), "").replace(/<[^>]*>/g, "")));
	      }, textSetter: function textSetter(a) {
	        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this));
	      }, fillSetter: function fillSetter(a, g, b) {
	        "string" === typeof a ? b.setAttribute(g, a) : a && this.colorGradient(a, g, b);
	      }, visibilitySetter: function visibilitySetter(a, g, b) {
	        "inherit" === a ? b.removeAttribute(g) : b.setAttribute(g, a);
	      }, zIndexSetter: function zIndexSetter(a, g) {
	        var A = this.renderer,
	            b = this.parentGroup,
	            k = (b || A).element || A.box,
	            d,
	            m = this.element,
	            c;d = this.added;var h;n(a) && (m.zIndex = a, a = +a, this[g] === a && (d = !1), this[g] = a);if (d) {
	          (a = this.zIndex) && b && (b.handleZ = !0);g = k.childNodes;for (h = 0; h < g.length && !c; h++) {
	            b = g[h], d = b.zIndex, b !== m && (I(d) > a || !n(a) && n(d) || 0 > a && !n(d) && k !== A.box) && (k.insertBefore(m, b), c = !0);
	          }c || k.appendChild(m);
	        }return c;
	      },
	      _defaultSetter: function _defaultSetter(a, g, b) {
	        b.setAttribute(g, a);
	      } };D.prototype.yGetter = D.prototype.xGetter;D.prototype.translateXSetter = D.prototype.translateYSetter = D.prototype.rotationSetter = D.prototype.verticalAlignSetter = D.prototype.scaleXSetter = D.prototype.scaleYSetter = function (a, g) {
	      this[g] = a;this.doTransform = !0;
	    };D.prototype["stroke-widthSetter"] = D.prototype.strokeSetter = function (a, g, b) {
	      this[g] = a;this.stroke && this["stroke-width"] ? (D.prototype.fillSetter.call(this, this.stroke, "stroke", b), b.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === g && 0 === a && this.hasStroke && (b.removeAttribute("stroke"), this.hasStroke = !1);
	    };C = a.SVGRenderer = function () {
	      this.init.apply(this, arguments);
	    };C.prototype = { Element: D, SVG_NS: O, init: function init(a, g, b, d, c, h) {
	        var A;d = this.createElement("svg").attr({ version: "1.1", "class": "highcharts-root" }).css(this.getStyle(d));A = d.element;a.appendChild(A);-1 === a.innerHTML.indexOf("xmlns") && v(A, "xmlns", this.SVG_NS);this.isSVG = !0;this.box = A;this.boxWrapper = d;this.alignedObjects = [];this.url = (k || m) && e.getElementsByTagName("base").length ? P.location.href.replace(/#.*?$/, "").replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "";this.createElement("desc").add().element.appendChild(e.createTextNode("Created with Highstock 5.0.10"));this.defs = this.createElement("defs").add();this.allowHTML = h;this.forExport = c;this.gradients = {};this.cache = {};this.cacheKeys = [];this.imgCount = 0;this.setSize(g, b, !1);var y;k && a.getBoundingClientRect && (g = function g() {
	          w(a, { left: 0, top: 0 });
	          y = a.getBoundingClientRect();w(a, { left: Math.ceil(y.left) - y.left + "px", top: Math.ceil(y.top) - y.top + "px" });
	        }, g(), this.unSubPixelFix = G(P, "resize", g));
	      }, getStyle: function getStyle(a) {
	        return this.style = b({ fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px" }, a);
	      }, setStyle: function setStyle(a) {
	        this.boxWrapper.css(this.getStyle(a));
	      }, isHidden: function isHidden() {
	        return !this.boxWrapper.getBBox().width;
	      }, destroy: function destroy() {
	        var a = this.defs;this.box = null;this.boxWrapper = this.boxWrapper.destroy();c(this.gradients || {});this.gradients = null;a && (this.defs = a.destroy());this.unSubPixelFix && this.unSubPixelFix();return this.alignedObjects = null;
	      }, createElement: function createElement(a) {
	        var g = new this.Element();g.init(this, a);return g;
	      }, draw: J, getRadialAttr: function getRadialAttr(a, g) {
	        return { cx: a[0] - a[2] / 2 + g.cx * a[2], cy: a[1] - a[2] / 2 + g.cy * a[2], r: g.r * a[2] };
	      }, getSpanWidth: function getSpanWidth(a, g) {
	        var b = a.getBBox(!0).width;!R && this.forExport && (b = this.measureSpanWidth(g.firstChild.data, a.styles));return b;
	      }, applyEllipsis: function applyEllipsis(a, g, b, d) {
	        var k = this.getSpanWidth(a, g),
	            A = k > d,
	            k = b,
	            m,
	            c = 0,
	            h = b.length,
	            y = function y(a) {
	          g.removeChild(g.firstChild);a && g.appendChild(e.createTextNode(a));
	        };if (A) {
	          for (; c <= h;) {
	            m = Math.ceil((c + h) / 2), k = b.substring(0, m) + "\u2026", y(k), k = this.getSpanWidth(a, g), c === h ? c = h + 1 : k > d ? h = m - 1 : c = m;
	          }0 === h && y("");
	        }return A;
	      }, buildText: function buildText(a) {
	        var g = a.element,
	            b = this,
	            k = b.forExport,
	            d = E(a.textStr, "").toString(),
	            m = -1 !== d.indexOf("\x3c"),
	            A = g.childNodes,
	            c,
	            y,
	            L,
	            F,
	            p = v(g, "x"),
	            u = a.styles,
	            x = a.textWidth,
	            t = u && u.lineHeight,
	            B = u && u.textOutline,
	            f = u && "ellipsis" === u.textOverflow,
	            J = u && "nowrap" === u.whiteSpace,
	            q = u && u.fontSize,
	            n,
	            l,
	            r = A.length,
	            u = x && !a.added && this.box,
	            M = function M(a) {
	          var d;d = /(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : q || b.style.fontSize || 12;return t ? I(t) : b.fontMetrics(d, a.getAttribute("style") ? a : g).h;
	        };n = [d, f, J, t, B, q, x].join();if (n !== a.textCache) {
	          for (a.textCache = n; r--;) {
	            g.removeChild(A[r]);
	          }m || B || f || x || -1 !== d.indexOf(" ") ? (c = /<.*class="([^"]+)".*>/, y = /<.*style="([^"]+)".*>/, L = /<.*href="(http[^"]+)".*>/, u && u.appendChild(g), d = m ? d.replace(/<(b|strong)>/g, '\x3cspan style\x3d"font-weight:bold"\x3e').replace(/<(i|em)>/g, '\x3cspan style\x3d"font-style:italic"\x3e').replace(/<a/g, "\x3cspan").replace(/<\/(b|strong|i|em|a)>/g, "\x3c/span\x3e").split(/<br.*?>/g) : [d], d = h(d, function (a) {
	            return "" !== a;
	          }), z(d, function (d, m) {
	            var A,
	                h = 0;d = d.replace(/^\s+|\s+$/g, "").replace(/<span/g, "|||\x3cspan").replace(/<\/span>/g, "\x3c/span\x3e|||");A = d.split("|||");z(A, function (d) {
	              if ("" !== d || 1 === A.length) {
	                var E = {},
	                    u = e.createElementNS(b.SVG_NS, "tspan"),
	                    t,
	                    I;c.test(d) && (t = d.match(c)[1], v(u, "class", t));y.test(d) && (I = d.match(y)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), v(u, "style", I));L.test(d) && !k && (v(u, "onclick", 'location.href\x3d"' + d.match(L)[1] + '"'), w(u, { cursor: "pointer" }));d = (d.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "\x3c").replace(/&gt;/g, "\x3e");if (" " !== d) {
	                  u.appendChild(e.createTextNode(d));h ? E.dx = 0 : m && null !== p && (E.x = p);v(u, E);g.appendChild(u);!h && l && (!R && k && w(u, { display: "block" }), v(u, "dy", M(u)));if (x) {
	                    E = d.replace(/([^\^])-/g, "$1- ").split(" ");t = 1 < A.length || m || 1 < E.length && !J;var z = [],
	                        B,
	                        q = M(u),
	                        n = a.rotation;for (f && (F = b.applyEllipsis(a, u, d, x)); !f && t && (E.length || z.length);) {
	                      a.rotation = 0, B = b.getSpanWidth(a, u), d = B > x, void 0 === F && (F = d), d && 1 !== E.length ? (u.removeChild(u.firstChild), z.unshift(E.pop())) : (E = z, z = [], E.length && !J && (u = e.createElementNS(O, "tspan"), v(u, { dy: q, x: p }), I && v(u, "style", I), g.appendChild(u)), B > x && (x = B)), E.length && u.appendChild(e.createTextNode(E.join(" ").replace(/- /g, "-")));
	                    }a.rotation = n;
	                  }h++;
	                }
	              }
	            });l = l || g.childNodes.length;
	          }), F && a.attr("title", a.textStr), u && u.removeChild(g), B && a.applyTextOutline && a.applyTextOutline(B)) : g.appendChild(e.createTextNode(d.replace(/&lt;/g, "\x3c").replace(/&gt;/g, "\x3e")));
	        }
	      }, getContrast: function getContrast(a) {
	        a = r(a).rgba;return 510 < a[0] + a[1] + a[2] ? "#000000" : "#FFFFFF";
	      }, button: function button(a, g, d, k, m, c, h, L, E) {
	        var A = this.label(a, g, d, E, null, null, null, null, "button"),
	            u = 0;A.attr(y({ padding: 8, r: 2 }, m));var p, x, t, e;m = y({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1, style: { color: "#333333", cursor: "pointer", fontWeight: "normal" } }, m);p = m.style;delete m.style;c = y(m, { fill: "#e6e6e6" }, c);x = c.style;delete c.style;h = y(m, { fill: "#e6ebf5", style: { color: "#000000", fontWeight: "bold" } }, h);t = h.style;delete h.style;L = y(m, { style: { color: "#cccccc" } }, L);e = L.style;delete L.style;G(A.element, F ? "mouseover" : "mouseenter", function () {
	          3 !== u && A.setState(1);
	        });G(A.element, F ? "mouseout" : "mouseleave", function () {
	          3 !== u && A.setState(u);
	        });A.setState = function (a) {
	          1 !== a && (A.state = u = a);A.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][a || 0]);A.attr([m, c, h, L][a || 0]).css([p, x, t, e][a || 0]);
	        };A.attr(m).css(b({ cursor: "default" }, p));return A.on("click", function (a) {
	          3 !== u && k.call(A, a);
	        });
	      }, crispLine: function crispLine(a, g) {
	        a[1] === a[4] && (a[1] = a[4] = Math.round(a[1]) - g % 2 / 2);a[2] === a[5] && (a[2] = a[5] = Math.round(a[2]) + g % 2 / 2);return a;
	      }, path: function path(a) {
	        var g = { fill: "none" };x(a) ? g.d = a : d(a) && b(g, a);return this.createElement("path").attr(g);
	      }, circle: function circle(a, g, b) {
	        a = d(a) ? a : { x: a, y: g, r: b };g = this.createElement("circle");g.xSetter = g.ySetter = function (a, g, d) {
	          d.setAttribute("c" + g, a);
	        };return g.attr(a);
	      }, arc: function arc(a, g, b, k, m, c) {
	        d(a) ? (k = a, g = k.y, b = k.r, a = k.x) : k = { innerR: k, start: m, end: c };a = this.symbol("arc", a, g, b, b, k);a.r = b;return a;
	      }, rect: function rect(a, g, b, k, m, c) {
	        m = d(a) ? a.r : m;var h = this.createElement("rect");a = d(a) ? a : void 0 === a ? {} : { x: a, y: g, width: Math.max(b, 0), height: Math.max(k, 0) };void 0 !== c && (a.strokeWidth = c, a = h.crisp(a));a.fill = "none";m && (a.r = m);h.rSetter = function (a, g, b) {
	          v(b, { rx: a, ry: a });
	        };return h.attr(a);
	      }, setSize: function setSize(a, g, b) {
	        var d = this.alignedObjects,
	            k = d.length;this.width = a;this.height = g;for (this.boxWrapper.animate({ width: a, height: g }, { step: function step() {
	            this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
	          }, duration: E(b, !0) ? void 0 : 0 }); k--;) {
	          d[k].align();
	        }
	      }, g: function g(a) {
	        var g = this.createElement("g");return a ? g.attr({ "class": "highcharts-" + a }) : g;
	      }, image: function image(a, g, d, k, m) {
	        var c = { preserveAspectRatio: "none" };1 < arguments.length && b(c, { x: g, y: d, width: k, height: m });c = this.createElement("image").attr(c);c.element.setAttributeNS ? c.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : c.element.setAttribute("hc-svg-href", a);return c;
	      }, symbol: function symbol(a, g, d, k, m, c) {
	        var h = this,
	            A,
	            y = this.symbols[a],
	            L = n(g) && y && this.symbols[a](Math.round(g), Math.round(d), k, m, c),
	            u = /^url\((.*?)\)$/,
	            F,
	            p;y ? (A = this.path(L), A.attr("fill", "none"), b(A, { symbolName: a, x: g, y: d, width: k, height: m }), c && b(A, c)) : u.test(a) && (F = a.match(u)[1], A = this.image(F), A.imgwidth = E(M[F] && M[F].width, c && c.width), A.imgheight = E(M[F] && M[F].height, c && c.height), p = function p() {
	          A.attr({ width: A.width, height: A.height });
	        }, z(["width", "height"], function (a) {
	          A[a + "Setter"] = function (a, g) {
	            var d = {},
	                b = this["img" + g],
	                k = "width" === g ? "translateX" : "translateY";this[g] = a;n(b) && (this.element && this.element.setAttribute(g, b), this.alignByTranslate || (d[k] = ((this[g] || 0) - b) / 2, this.attr(d)));
	          };
	        }), n(g) && A.attr({ x: g, y: d }), A.isImg = !0, n(A.imgwidth) && n(A.imgheight) ? p() : (A.attr({ width: 0, height: 0 }), q("img", { onload: function onload() {
	            var a = l[h.chartIndex];0 === this.width && (w(this, { position: "absolute", top: "-999em" }), e.body.appendChild(this));M[F] = { width: this.width, height: this.height };A.imgwidth = this.width;A.imgheight = this.height;A.element && p();this.parentNode && this.parentNode.removeChild(this);
	            h.imgCount--;if (!h.imgCount && a && a.onload) a.onload();
	          }, src: F }), this.imgCount++));return A;
	      }, symbols: { circle: function circle(a, g, b, d) {
	          return this.arc(a + b / 2, g + d / 2, b / 2, d / 2, { start: 0, end: 2 * Math.PI, open: !1 });
	        }, square: function square(a, g, b, d) {
	          return ["M", a, g, "L", a + b, g, a + b, g + d, a, g + d, "Z"];
	        }, triangle: function triangle(a, g, b, d) {
	          return ["M", a + b / 2, g, "L", a + b, g + d, a, g + d, "Z"];
	        }, "triangle-down": function triangleDown(a, g, b, d) {
	          return ["M", a, g, "L", a + b, g, a + b / 2, g + d, "Z"];
	        }, diamond: function diamond(a, g, b, d) {
	          return ["M", a + b / 2, g, "L", a + b, g + d / 2, a + b / 2, g + d, a, g + d / 2, "Z"];
	        }, arc: function arc(a, g, b, d, k) {
	          var m = k.start,
	              c = k.r || b,
	              h = k.r || d || b,
	              y = k.end - .001;b = k.innerR;d = k.open;var A = Math.cos(m),
	              L = Math.sin(m),
	              E = Math.cos(y),
	              y = Math.sin(y);k = k.end - m < Math.PI ? 0 : 1;c = ["M", a + c * A, g + h * L, "A", c, h, 0, k, 1, a + c * E, g + h * y];n(b) && c.push(d ? "M" : "L", a + b * E, g + b * y, "A", b, b, 0, k, 0, a + b * A, g + b * L);c.push(d ? "" : "Z");return c;
	        }, callout: function callout(a, g, b, d, k) {
	          var m = Math.min(k && k.r || 0, b, d),
	              c = m + 6,
	              h = k && k.anchorX;k = k && k.anchorY;var y;y = ["M", a + m, g, "L", a + b - m, g, "C", a + b, g, a + b, g, a + b, g + m, "L", a + b, g + d - m, "C", a + b, g + d, a + b, g + d, a + b - m, g + d, "L", a + m, g + d, "C", a, g + d, a, g + d, a, g + d - m, "L", a, g + m, "C", a, g, a, g, a + m, g];h && h > b ? k > g + c && k < g + d - c ? y.splice(13, 3, "L", a + b, k - 6, a + b + 6, k, a + b, k + 6, a + b, g + d - m) : y.splice(13, 3, "L", a + b, d / 2, h, k, a + b, d / 2, a + b, g + d - m) : h && 0 > h ? k > g + c && k < g + d - c ? y.splice(33, 3, "L", a, k + 6, a - 6, k, a, k - 6, a, g + m) : y.splice(33, 3, "L", a, d / 2, h, k, a, d / 2, a, g + m) : k && k > d && h > a + c && h < a + b - c ? y.splice(23, 3, "L", h + 6, g + d, h, g + d + 6, h - 6, g + d, a + m, g + d) : k && 0 > k && h > a + c && h < a + b - c && y.splice(3, 3, "L", h - 6, g, h, g - 6, h + 6, g, b - m, g);return y;
	        } }, clipRect: function clipRect(g, b, d, k) {
	        var m = a.uniqueKey(),
	            c = this.createElement("clipPath").attr({ id: m }).add(this.defs);
	        g = this.rect(g, b, d, k, 0).add(c);g.id = m;g.clipPath = c;g.count = 0;return g;
	      }, text: function text(a, g, b, d) {
	        var k = !R && this.forExport,
	            m = {};if (d && (this.allowHTML || !this.forExport)) return this.html(a, g, b);m.x = Math.round(g || 0);b && (m.y = Math.round(b));if (a || 0 === a) m.text = a;a = this.createElement("text").attr(m);k && a.css({ position: "absolute" });d || (a.xSetter = function (a, g, b) {
	          var d = b.getElementsByTagName("tspan"),
	              k,
	              m = b.getAttribute(g),
	              c;for (c = 0; c < d.length; c++) {
	            k = d[c], k.getAttribute(g) === m && k.setAttribute(g, a);
	          }b.setAttribute(g, a);
	        });return a;
	      }, fontMetrics: function fontMetrics(a, g) {
	        a = a || g && g.style && g.style.fontSize || this.style && this.style.fontSize;a = /px/.test(a) ? I(a) : /em/.test(a) ? parseFloat(a) * (g ? this.fontMetrics(null, g.parentNode).f : 16) : 12;g = 24 > a ? a + 3 : Math.round(1.2 * a);return { h: g, b: Math.round(.8 * g), f: a };
	      }, rotCorr: function rotCorr(a, g, b) {
	        var d = a;g && b && (d = Math.max(d * Math.cos(g * f), 4));return { x: -a / 3 * Math.sin(g * f), y: d };
	      }, label: function label(d, k, m, c, h, L, E, u, F) {
	        var A = this,
	            p = A.g("button" !== F && "label"),
	            x = p.text = A.text("", 0, 0, E).attr({ zIndex: 1 }),
	            t,
	            e,
	            I = 0,
	            B = 3,
	            f = 0,
	            J,
	            R,
	            O,
	            q,
	            l,
	            w = {},
	            r,
	            M,
	            Q = /^url\((.*?)\)$/.test(c),
	            v = Q,
	            P,
	            S,
	            N,
	            T;F && p.addClass("highcharts-" + F);v = Q;P = function P() {
	          return (r || 0) % 2 / 2;
	        };S = function S() {
	          var a = x.element.style,
	              g = {};e = (void 0 === J || void 0 === R || l) && n(x.textStr) && x.getBBox();p.width = (J || e.width || 0) + 2 * B + f;p.height = (R || e.height || 0) + 2 * B;M = B + A.fontMetrics(a && a.fontSize, x).b;v && (t || (p.box = t = A.symbols[c] || Q ? A.symbol(c) : A.rect(), t.addClass(("button" === F ? "" : "highcharts-label-box") + (F ? " highcharts-" + F + "-box" : "")), t.add(p), a = P(), g.x = a, g.y = (u ? -M : 0) + a), g.width = Math.round(p.width), g.height = Math.round(p.height), t.attr(b(g, w)), w = {});
	        };N = function N() {
	          var a = f + B,
	              g;g = u ? 0 : M;n(J) && e && ("center" === l || "right" === l) && (a += { center: .5, right: 1 }[l] * (J - e.width));if (a !== x.x || g !== x.y) x.attr("x", a), void 0 !== g && x.attr("y", g);x.x = a;x.y = g;
	        };T = function T(a, g) {
	          t ? t.attr(a, g) : w[a] = g;
	        };p.onAdd = function () {
	          x.add(p);p.attr({ text: d || 0 === d ? d : "", x: k, y: m });t && n(h) && p.attr({ anchorX: h, anchorY: L });
	        };p.widthSetter = function (g) {
	          J = a.isNumber(g) ? g : null;
	        };p.heightSetter = function (a) {
	          R = a;
	        };p["text-alignSetter"] = function (a) {
	          l = a;
	        };p.paddingSetter = function (a) {
	          n(a) && a !== B && (B = p.padding = a, N());
	        };p.paddingLeftSetter = function (a) {
	          n(a) && a !== f && (f = a, N());
	        };p.alignSetter = function (a) {
	          a = { left: 0, center: .5, right: 1 }[a];a !== I && (I = a, e && p.attr({ x: O }));
	        };p.textSetter = function (a) {
	          void 0 !== a && x.textSetter(a);S();N();
	        };p["stroke-widthSetter"] = function (a, g) {
	          a && (v = !0);r = this["stroke-width"] = a;T(g, a);
	        };p.strokeSetter = p.fillSetter = p.rSetter = function (a, g) {
	          "fill" === g && a && (v = !0);T(g, a);
	        };p.anchorXSetter = function (a, g) {
	          h = a;T(g, Math.round(a) - P() - O);
	        };p.anchorYSetter = function (a, g) {
	          L = a;T(g, a - q);
	        };p.xSetter = function (a) {
	          p.x = a;I && (a -= I * ((J || e.width) + 2 * B));O = Math.round(a);p.attr("translateX", O);
	        };p.ySetter = function (a) {
	          q = p.y = Math.round(a);p.attr("translateY", q);
	        };var C = p.css;return b(p, { css: function css(a) {
	            if (a) {
	              var g = {};a = y(a);z(p.textProps, function (b) {
	                void 0 !== a[b] && (g[b] = a[b], delete a[b]);
	              });x.css(g);
	            }return C.call(p, a);
	          }, getBBox: function getBBox() {
	            return { width: e.width + 2 * B, height: e.height + 2 * B, x: e.x - B, y: e.y - B };
	          }, shadow: function shadow(a) {
	            a && (S(), t && t.shadow(a));return p;
	          },
	          destroy: function destroy() {
	            g(p.element, "mouseenter");g(p.element, "mouseleave");x && (x = x.destroy());t && (t = t.destroy());D.prototype.destroy.call(p);p = A = S = N = T = null;
	          } });
	      } };a.Renderer = C;
	  })(K);(function (a) {
	    var D = a.attr,
	        C = a.createElement,
	        G = a.css,
	        H = a.defined,
	        v = a.each,
	        l = a.extend,
	        r = a.isFirefox,
	        w = a.isMS,
	        q = a.isWebKit,
	        n = a.pInt,
	        f = a.SVGRenderer,
	        c = a.win,
	        e = a.wrap;l(a.SVGElement.prototype, { htmlCss: function htmlCss(a) {
	        var b = this.element;if (b = a && "SPAN" === b.tagName && a.width) delete a.width, this.textWidth = b, this.updateTransform();a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden");this.styles = l(this.styles, a);G(this.element, a);return this;
	      }, htmlGetBBox: function htmlGetBBox() {
	        var a = this.element;"text" === a.nodeName && (a.style.position = "absolute");return { x: a.offsetLeft, y: a.offsetTop, width: a.offsetWidth, height: a.offsetHeight };
	      }, htmlUpdateTransform: function htmlUpdateTransform() {
	        if (this.added) {
	          var a = this.renderer,
	              b = this.element,
	              c = this.translateX || 0,
	              h = this.translateY || 0,
	              e = this.x || 0,
	              p = this.y || 0,
	              x = this.textAlign || "left",
	              k = { left: 0, center: .5, right: 1 }[x],
	              F = this.styles;
	          G(b, { marginLeft: c, marginTop: h });this.shadows && v(this.shadows, function (a) {
	            G(a, { marginLeft: c + 1, marginTop: h + 1 });
	          });this.inverted && v(b.childNodes, function (d) {
	            a.invertChild(d, b);
	          });if ("SPAN" === b.tagName) {
	            var d = this.rotation,
	                u = n(this.textWidth),
	                m = F && F.whiteSpace,
	                y = [d, x, b.innerHTML, this.textWidth, this.textAlign].join();y !== this.cTT && (F = a.fontMetrics(b.style.fontSize).b, H(d) && this.setSpanRotation(d, k, F), G(b, { width: "", whiteSpace: m || "nowrap" }), b.offsetWidth > u && /[ \-]/.test(b.textContent || b.innerText) && G(b, { width: u + "px", display: "block", whiteSpace: m || "normal" }), this.getSpanCorrection(b.offsetWidth, F, k, d, x));G(b, { left: e + (this.xCorr || 0) + "px", top: p + (this.yCorr || 0) + "px" });q && (F = b.offsetHeight);this.cTT = y;
	          }
	        } else this.alignOnAdd = !0;
	      }, setSpanRotation: function setSpanRotation(a, b, t) {
	        var h = {},
	            e = w ? "-ms-transform" : q ? "-webkit-transform" : r ? "MozTransform" : c.opera ? "-o-transform" : "";h[e] = h.transform = "rotate(" + a + "deg)";h[e + (r ? "Origin" : "-origin")] = h.transformOrigin = 100 * b + "% " + t + "px";G(this.element, h);
	      }, getSpanCorrection: function getSpanCorrection(a, b, c) {
	        this.xCorr = -a * c;this.yCorr = -b;
	      } });l(f.prototype, { html: function html(a, b, c) {
	        var h = this.createElement("span"),
	            t = h.element,
	            p = h.renderer,
	            x = p.isSVG,
	            k = function k(a, b) {
	          v(["opacity", "visibility"], function (d) {
	            e(a, d + "Setter", function (a, d, k, c) {
	              a.call(this, d, k, c);b[k] = d;
	            });
	          });
	        };h.textSetter = function (a) {
	          a !== t.innerHTML && delete this.bBox;t.innerHTML = this.textStr = a;h.htmlUpdateTransform();
	        };x && k(h, h.element.style);h.xSetter = h.ySetter = h.alignSetter = h.rotationSetter = function (a, b) {
	          "align" === b && (b = "textAlign");h[b] = a;h.htmlUpdateTransform();
	        };
	        h.attr({ text: a, x: Math.round(b), y: Math.round(c) }).css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize, position: "absolute" });t.style.whiteSpace = "nowrap";h.css = h.htmlCss;x && (h.add = function (a) {
	          var b,
	              c = p.box.parentNode,
	              m = [];if (this.parentGroup = a) {
	            if (b = a.div, !b) {
	              for (; a;) {
	                m.push(a), a = a.parentGroup;
	              }v(m.reverse(), function (a) {
	                var d,
	                    y = D(a.element, "class");y && (y = { className: y });b = a.div = a.div || C("div", y, { position: "absolute", left: (a.translateX || 0) + "px", top: (a.translateY || 0) + "px", display: a.display,
	                  opacity: a.opacity, pointerEvents: a.styles && a.styles.pointerEvents }, b || c);d = b.style;l(a, { on: function on() {
	                    h.on.apply({ element: m[0].div }, arguments);return a;
	                  }, translateXSetter: function translateXSetter(b, g) {
	                    d.left = b + "px";a[g] = b;a.doTransform = !0;
	                  }, translateYSetter: function translateYSetter(b, g) {
	                    d.top = b + "px";a[g] = b;a.doTransform = !0;
	                  } });k(a, d);
	              });
	            }
	          } else b = c;b.appendChild(t);h.added = !0;h.alignOnAdd && h.htmlUpdateTransform();return h;
	        });return h;
	      } });
	  })(K);(function (a) {
	    var D,
	        C,
	        G = a.createElement,
	        H = a.css,
	        v = a.defined,
	        l = a.deg2rad,
	        r = a.discardElement,
	        w = a.doc,
	        q = a.each,
	        n = a.erase,
	        f = a.extend;D = a.extendClass;var c = a.isArray,
	        e = a.isNumber,
	        z = a.isObject,
	        b = a.merge;C = a.noop;var t = a.pick,
	        h = a.pInt,
	        B = a.SVGElement,
	        p = a.SVGRenderer,
	        x = a.win;a.svg || (C = { docMode8: w && 8 === w.documentMode, init: function init(a, b) {
	        var d = ["\x3c", b, ' filled\x3d"f" stroked\x3d"f"'],
	            k = ["position: ", "absolute", ";"],
	            m = "div" === b;("shape" === b || m) && k.push("left:0;top:0;width:1px;height:1px;");k.push("visibility: ", m ? "hidden" : "visible");d.push(' style\x3d"', k.join(""), '"/\x3e');b && (d = m || "span" === b || "img" === b ? d.join("") : a.prepVML(d), this.element = G(d));this.renderer = a;
	      }, add: function add(a) {
	        var b = this.renderer,
	            d = this.element,
	            k = b.box,
	            m = a && a.inverted,
	            k = a ? a.element || a : k;a && (this.parentGroup = a);m && b.invertChild(d, k);k.appendChild(d);this.added = !0;this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform();if (this.onAdd) this.onAdd();this.className && this.attr("class", this.className);return this;
	      }, updateTransform: B.prototype.htmlUpdateTransform, setSpanRotation: function setSpanRotation() {
	        var a = this.rotation,
	            b = Math.cos(a * l),
	            d = Math.sin(a * l);H(this.element, { filter: a ? ["progid:DXImageTransform.Microsoft.Matrix(M11\x3d", b, ", M12\x3d", -d, ", M21\x3d", d, ", M22\x3d", b, ", sizingMethod\x3d'auto expand')"].join("") : "none" });
	      }, getSpanCorrection: function getSpanCorrection(a, b, d, c, m) {
	        var k = c ? Math.cos(c * l) : 1,
	            h = c ? Math.sin(c * l) : 0,
	            p = t(this.elemHeight, this.element.offsetHeight),
	            u;this.xCorr = 0 > k && -a;this.yCorr = 0 > h && -p;u = 0 > k * h;this.xCorr += h * b * (u ? 1 - d : d);this.yCorr -= k * b * (c ? u ? d : 1 - d : 1);m && "left" !== m && (this.xCorr -= a * d * (0 > k ? -1 : 1), c && (this.yCorr -= p * d * (0 > h ? -1 : 1)), H(this.element, { textAlign: m }));
	      }, pathToVML: function pathToVML(a) {
	        for (var b = a.length, d = []; b--;) {
	          e(a[b]) ? d[b] = Math.round(10 * a[b]) - 5 : "Z" === a[b] ? d[b] = "x" : (d[b] = a[b], !a.isArc || "wa" !== a[b] && "at" !== a[b] || (d[b + 5] === d[b + 7] && (d[b + 7] += a[b + 7] > a[b + 5] ? 1 : -1), d[b + 6] === d[b + 8] && (d[b + 8] += a[b + 8] > a[b + 6] ? 1 : -1)));
	        }return d.join(" ") || "x";
	      }, clip: function clip(a) {
	        var b = this,
	            d;a ? (d = a.members, n(d, b), d.push(b), b.destroyClip = function () {
	          n(d, b);
	        }, a = a.getCSS(b)) : (b.destroyClip && b.destroyClip(), a = { clip: b.docMode8 ? "inherit" : "rect(auto)" });return b.css(a);
	      }, css: B.prototype.htmlCss,
	      safeRemoveChild: function safeRemoveChild(a) {
	        a.parentNode && r(a);
	      }, destroy: function destroy() {
	        this.destroyClip && this.destroyClip();return B.prototype.destroy.apply(this);
	      }, on: function on(a, b) {
	        this.element["on" + a] = function () {
	          var a = x.event;a.target = a.srcElement;b(a);
	        };return this;
	      }, cutOffPath: function cutOffPath(a, b) {
	        var d;a = a.split(/[ ,]/);d = a.length;if (9 === d || 11 === d) a[d - 4] = a[d - 2] = h(a[d - 2]) - 10 * b;return a.join(" ");
	      }, shadow: function shadow(a, b, d) {
	        var c = [],
	            k,
	            y = this.element,
	            p = this.renderer,
	            E,
	            x = y.style,
	            g,
	            L = y.path,
	            e,
	            F,
	            B,
	            f;L && "string" !== typeof L.value && (L = "x");F = L;if (a) {
	          B = t(a.width, 3);f = (a.opacity || .15) / B;for (k = 1; 3 >= k; k++) {
	            e = 2 * B + 1 - 2 * k, d && (F = this.cutOffPath(L.value, e + .5)), g = ['\x3cshape isShadow\x3d"true" strokeweight\x3d"', e, '" filled\x3d"false" path\x3d"', F, '" coordsize\x3d"10 10" style\x3d"', y.style.cssText, '" /\x3e'], E = G(p.prepVML(g), null, { left: h(x.left) + t(a.offsetX, 1), top: h(x.top) + t(a.offsetY, 1) }), d && (E.cutOff = e + 1), g = ['\x3cstroke color\x3d"', a.color || "#000000", '" opacity\x3d"', f * k, '"/\x3e'], G(p.prepVML(g), null, null, E), b ? b.element.appendChild(E) : y.parentNode.insertBefore(E, y), c.push(E);
	          }this.shadows = c;
	        }return this;
	      }, updateShadows: C, setAttr: function setAttr(a, b) {
	        this.docMode8 ? this.element[a] = b : this.element.setAttribute(a, b);
	      }, classSetter: function classSetter(a) {
	        (this.added ? this.element : this).className = a;
	      }, dashstyleSetter: function dashstyleSetter(a, b, d) {
	        (d.getElementsByTagName("stroke")[0] || G(this.renderer.prepVML(["\x3cstroke/\x3e"]), null, null, d))[b] = a || "solid";this[b] = a;
	      }, dSetter: function dSetter(a, b, d) {
	        var c = this.shadows;a = a || [];this.d = a.join && a.join(" ");d.path = a = this.pathToVML(a);if (c) for (d = c.length; d--;) {
	          c[d].path = c[d].cutOff ? this.cutOffPath(a, c[d].cutOff) : a;
	        }this.setAttr(b, a);
	      }, fillSetter: function fillSetter(a, b, d) {
	        var c = d.nodeName;"SPAN" === c ? d.style.color = a : "IMG" !== c && (d.filled = "none" !== a, this.setAttr("fillcolor", this.renderer.color(a, d, b, this)));
	      }, "fill-opacitySetter": function fillOpacitySetter(a, b, d) {
	        G(this.renderer.prepVML(["\x3c", b.split("-")[0], ' opacity\x3d"', a, '"/\x3e']), null, null, d);
	      }, opacitySetter: C, rotationSetter: function rotationSetter(a, b, d) {
	        d = d.style;this[b] = d[b] = a;d.left = -Math.round(Math.sin(a * l) + 1) + "px";d.top = Math.round(Math.cos(a * l)) + "px";
	      }, strokeSetter: function strokeSetter(a, b, d) {
	        this.setAttr("strokecolor", this.renderer.color(a, d, b, this));
	      }, "stroke-widthSetter": function strokeWidthSetter(a, b, d) {
	        d.stroked = !!a;this[b] = a;e(a) && (a += "px");this.setAttr("strokeweight", a);
	      }, titleSetter: function titleSetter(a, b) {
	        this.setAttr(b, a);
	      }, visibilitySetter: function visibilitySetter(a, b, d) {
	        "inherit" === a && (a = "visible");this.shadows && q(this.shadows, function (d) {
	          d.style[b] = a;
	        });"DIV" === d.nodeName && (a = "hidden" === a ? "-999em" : 0, this.docMode8 || (d.style[b] = a ? "visible" : "hidden"), b = "top");d.style[b] = a;
	      }, xSetter: function xSetter(a, b, d) {
	        this[b] = a;"x" === b ? b = "left" : "y" === b && (b = "top");this.updateClipping ? (this[b] = a, this.updateClipping()) : d.style[b] = a;
	      }, zIndexSetter: function zIndexSetter(a, b, d) {
	        d.style[b] = a;
	      } }, C["stroke-opacitySetter"] = C["fill-opacitySetter"], a.VMLElement = C = D(B, C), C.prototype.ySetter = C.prototype.widthSetter = C.prototype.heightSetter = C.prototype.xSetter, C = { Element: C, isIE8: -1 < x.navigator.userAgent.indexOf("MSIE 8.0"), init: function init(a, b, d) {
	        var c, m;this.alignedObjects = [];c = this.createElement("div").css({ position: "relative" });m = c.element;
	        a.appendChild(c.element);this.isVML = !0;this.box = m;this.boxWrapper = c;this.gradients = {};this.cache = {};this.cacheKeys = [];this.imgCount = 0;this.setSize(b, d, !1);if (!w.namespaces.hcv) {
	          w.namespaces.add("hcv", "urn:schemas-microsoft-com:vml");try {
	            w.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
	          } catch (y) {
	            w.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
	          }
	        }
	      },
	      isHidden: function isHidden() {
	        return !this.box.offsetWidth;
	      }, clipRect: function clipRect(a, b, d, c) {
	        var m = this.createElement(),
	            k = z(a);return f(m, { members: [], count: 0, left: (k ? a.x : a) + 1, top: (k ? a.y : b) + 1, width: (k ? a.width : d) - 1, height: (k ? a.height : c) - 1, getCSS: function getCSS(a) {
	            var b = a.element,
	                d = b.nodeName,
	                g = a.inverted,
	                c = this.top - ("shape" === d ? b.offsetTop : 0),
	                m = this.left,
	                b = m + this.width,
	                k = c + this.height,
	                c = { clip: "rect(" + Math.round(g ? m : c) + "px," + Math.round(g ? k : b) + "px," + Math.round(g ? b : k) + "px," + Math.round(g ? c : m) + "px)" };!g && a.docMode8 && "DIV" === d && f(c, { width: b + "px", height: k + "px" });return c;
	          }, updateClipping: function updateClipping() {
	            q(m.members, function (a) {
	              a.element && a.css(m.getCSS(a));
	            });
	          } });
	      }, color: function color(b, c, d, h) {
	        var m = this,
	            k,
	            p = /^rgba/,
	            E,
	            x,
	            g = "none";b && b.linearGradient ? x = "gradient" : b && b.radialGradient && (x = "pattern");if (x) {
	          var L,
	              u,
	              t = b.linearGradient || b.radialGradient,
	              e,
	              B,
	              A,
	              F,
	              f,
	              z = "";b = b.stops;var n,
	              l = [],
	              w = function w() {
	            E = ['\x3cfill colors\x3d"' + l.join(",") + '" opacity\x3d"', A, '" o:opacity2\x3d"', B, '" type\x3d"', x, '" ', z, 'focus\x3d"100%" method\x3d"any" /\x3e'];
	            G(m.prepVML(E), null, null, c);
	          };e = b[0];n = b[b.length - 1];0 < e[0] && b.unshift([0, e[1]]);1 > n[0] && b.push([1, n[1]]);q(b, function (g, b) {
	            p.test(g[1]) ? (k = a.color(g[1]), L = k.get("rgb"), u = k.get("a")) : (L = g[1], u = 1);l.push(100 * g[0] + "% " + L);b ? (A = u, F = L) : (B = u, f = L);
	          });if ("fill" === d) {
	            if ("gradient" === x) d = t.x1 || t[0] || 0, b = t.y1 || t[1] || 0, e = t.x2 || t[2] || 0, t = t.y2 || t[3] || 0, z = 'angle\x3d"' + (90 - 180 * Math.atan((t - b) / (e - d)) / Math.PI) + '"', w();else {
	              var g = t.r,
	                  r = 2 * g,
	                  v = 2 * g,
	                  C = t.cx,
	                  D = t.cy,
	                  H = c.radialReference,
	                  K,
	                  g = function g() {
	                H && (K = h.getBBox(), C += (H[0] - K.x) / K.width - .5, D += (H[1] - K.y) / K.height - .5, r *= H[2] / K.width, v *= H[2] / K.height);z = 'src\x3d"' + a.getOptions().global.VMLRadialGradientURL + '" size\x3d"' + r + "," + v + '" origin\x3d"0.5,0.5" position\x3d"' + C + "," + D + '" color2\x3d"' + f + '" ';w();
	              };h.added ? g() : h.onAdd = g;g = F;
	            }
	          } else g = L;
	        } else p.test(b) && "IMG" !== c.tagName ? (k = a.color(b), h[d + "-opacitySetter"](k.get("a"), d, c), g = k.get("rgb")) : (g = c.getElementsByTagName(d), g.length && (g[0].opacity = 1, g[0].type = "solid"), g = b);return g;
	      }, prepVML: function prepVML(a) {
	        var b = this.isIE8;a = a.join("");
	        b ? (a = a.replace("/\x3e", ' xmlns\x3d"urn:schemas-microsoft-com:vml" /\x3e'), a = -1 === a.indexOf('style\x3d"') ? a.replace("/\x3e", ' style\x3d"display:inline-block;behavior:url(#default#VML);" /\x3e') : a.replace('style\x3d"', 'style\x3d"display:inline-block;behavior:url(#default#VML);')) : a = a.replace("\x3c", "\x3chcv:");return a;
	      }, text: p.prototype.html, path: function path(a) {
	        var b = { coordsize: "10 10" };c(a) ? b.d = a : z(a) && f(b, a);return this.createElement("shape").attr(b);
	      }, circle: function circle(a, b, d) {
	        var c = this.symbol("circle");
	        z(a) && (d = a.r, b = a.y, a = a.x);c.isCircle = !0;c.r = d;return c.attr({ x: a, y: b });
	      }, g: function g(a) {
	        var b;a && (b = { className: "highcharts-" + a, "class": "highcharts-" + a });return this.createElement("div").attr(b);
	      }, image: function image(a, b, d, c, m) {
	        var h = this.createElement("img").attr({ src: a });1 < arguments.length && h.attr({ x: b, y: d, width: c, height: m });return h;
	      }, createElement: function createElement(a) {
	        return "rect" === a ? this.symbol(a) : p.prototype.createElement.call(this, a);
	      }, invertChild: function invertChild(a, b) {
	        var d = this;b = b.style;var c = "IMG" === a.tagName && a.style;
	        H(a, { flip: "x", left: h(b.width) - (c ? h(c.top) : 1), top: h(b.height) - (c ? h(c.left) : 1), rotation: -90 });q(a.childNodes, function (b) {
	          d.invertChild(b, a);
	        });
	      }, symbols: { arc: function arc(a, b, d, c, m) {
	          var h = m.start,
	              k = m.end,
	              p = m.r || d || c;d = m.innerR;c = Math.cos(h);var x = Math.sin(h),
	              g = Math.cos(k),
	              L = Math.sin(k);if (0 === k - h) return ["x"];h = ["wa", a - p, b - p, a + p, b + p, a + p * c, b + p * x, a + p * g, b + p * L];m.open && !d && h.push("e", "M", a, b);h.push("at", a - d, b - d, a + d, b + d, a + d * g, b + d * L, a + d * c, b + d * x, "x", "e");h.isArc = !0;return h;
	        }, circle: function circle(a, b, d, c, m) {
	          m && v(m.r) && (d = c = 2 * m.r);m && m.isCircle && (a -= d / 2, b -= c / 2);return ["wa", a, b, a + d, b + c, a + d, b + c / 2, a + d, b + c / 2, "e"];
	        }, rect: function rect(a, b, d, c, m) {
	          return p.prototype.symbols[v(m) && m.r ? "callout" : "square"].call(0, a, b, d, c, m);
	        } } }, a.VMLRenderer = D = function D() {
	      this.init.apply(this, arguments);
	    }, D.prototype = b(p.prototype, C), a.Renderer = D);p.prototype.measureSpanWidth = function (a, b) {
	      var d = w.createElement("span");a = w.createTextNode(a);d.appendChild(a);H(d, b);this.box.appendChild(d);b = d.offsetWidth;r(d);return b;
	    };
	  })(K);(function (a) {
	    function D() {
	      var q = a.defaultOptions.global,
	          n = w.moment;if (q.timezone) {
	        if (n) return function (a) {
	          return -n.tz(a, q.timezone).utcOffset();
	        };a.error(25);
	      }return q.useUTC && q.getTimezoneOffset;
	    }function C() {
	      var q = a.defaultOptions.global,
	          n,
	          f = q.useUTC,
	          c = f ? "getUTC" : "get",
	          e = f ? "setUTC" : "set";a.Date = n = q.Date || w.Date;n.hcTimezoneOffset = f && q.timezoneOffset;n.hcGetTimezoneOffset = D();n.hcMakeTime = function (a, b, c, h, e, p) {
	        var x;f ? (x = n.UTC.apply(0, arguments), x += v(x)) : x = new n(a, b, r(c, 1), r(h, 0), r(e, 0), r(p, 0)).getTime();return x;
	      };H("Minutes Hours Day Date Month FullYear".split(" "), function (a) {
	        n["hcGet" + a] = c + a;
	      });H("Milliseconds Seconds Minutes Hours Date Month FullYear".split(" "), function (a) {
	        n["hcSet" + a] = e + a;
	      });
	    }var G = a.color,
	        H = a.each,
	        v = a.getTZOffset,
	        l = a.merge,
	        r = a.pick,
	        w = a.win;a.defaultOptions = { colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" "), symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: "January February March April May June July August September October November December".split(" "),
	        shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint: ".", numericSymbols: "kMGTPE".split(""), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " }, global: { useUTC: !0, VMLRadialGradientURL: "http://code.highcharts.com/5.0.10/gfx/vml-radial-gradient.png" }, chart: { borderRadius: 0, defaultSeriesType: "line", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], resetZoomButton: { theme: { zIndex: 20 },
	          position: { align: "right", x: -10, y: 10 } }, width: null, height: null, borderColor: "#335cad", backgroundColor: "#ffffff", plotBorderColor: "#cccccc" }, title: { text: "Chart title", align: "center", margin: 15, widthAdjust: -44 }, subtitle: { text: "", align: "center", widthAdjust: -44 }, plotOptions: {}, labels: { style: { position: "absolute", color: "#333333" } }, legend: { enabled: !0, align: "center", layout: "horizontal", labelFormatter: function labelFormatter() {
	          return this.name;
	        }, borderColor: "#999999", borderRadius: 0, navigation: { activeColor: "#003399", inactiveColor: "#cccccc" },
	        itemStyle: { color: "#333333", fontSize: "12px", fontWeight: "bold" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#cccccc" }, shadow: !1, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: !0, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: { position: "absolute", backgroundColor: "#ffffff", opacity: .5, textAlign: "center" } }, tooltip: { enabled: !0, animation: a.svg, borderRadius: 3,
	        dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" }, footerFormat: "", padding: 8, snap: a.isTouchDevice ? 25 : 10, backgroundColor: G("#f7f7f7").setOpacity(.85).get(), borderWidth: 1, headerFormat: '\x3cspan style\x3d"font-size: 10px"\x3e{point.key}\x3c/span\x3e\x3cbr/\x3e', pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> {series.name}: <b>{point.y}</b><br/>",
	        shadow: !0, style: { color: "#333333", cursor: "default", fontSize: "12px", pointerEvents: "none", whiteSpace: "nowrap" } }, credits: { enabled: !0, href: "http://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "9px" }, text: "Highcharts.com" } };a.setOptions = function (q) {
	      a.defaultOptions = l(!0, a.defaultOptions, q);C();return a.defaultOptions;
	    };a.getOptions = function () {
	      return a.defaultOptions;
	    };a.defaultPlotOptions = a.defaultOptions.plotOptions;C();
	  })(K);
	  (function (a) {
	    var D = a.arrayMax,
	        C = a.arrayMin,
	        G = a.defined,
	        H = a.destroyObjectProperties,
	        v = a.each,
	        l = a.erase,
	        r = a.merge,
	        w = a.pick;a.PlotLineOrBand = function (a, n) {
	      this.axis = a;n && (this.options = n, this.id = n.id);
	    };a.PlotLineOrBand.prototype = { render: function render() {
	        var a = this,
	            n = a.axis,
	            f = n.horiz,
	            c = a.options,
	            e = c.label,
	            z = a.label,
	            b = c.to,
	            t = c.from,
	            h = c.value,
	            B = G(t) && G(b),
	            p = G(h),
	            x = a.svgElem,
	            k = !x,
	            F = [],
	            d,
	            u = c.color,
	            m = w(c.zIndex, 0),
	            y = c.events,
	            F = { "class": "highcharts-plot-" + (B ? "band " : "line ") + (c.className || "") },
	            J = {},
	            E = n.chart.renderer,
	            I = B ? "bands" : "lines",
	            g = n.log2lin;n.isLog && (t = g(t), b = g(b), h = g(h));p ? (F = { stroke: u, "stroke-width": c.width }, c.dashStyle && (F.dashstyle = c.dashStyle)) : B && (u && (F.fill = u), c.borderWidth && (F.stroke = c.borderColor, F["stroke-width"] = c.borderWidth));J.zIndex = m;I += "-" + m;(u = n.plotLinesAndBandsGroups[I]) || (n.plotLinesAndBandsGroups[I] = u = E.g("plot-" + I).attr(J).add());k && (a.svgElem = x = E.path().attr(F).add(u));if (p) F = n.getPlotLinePath(h, x.strokeWidth());else if (B) F = n.getPlotBandPath(t, b, c);else return;if (k && F && F.length) {
	          if (x.attr({ d: F }), y) for (d in c = function c(g) {
	            x.on(g, function (b) {
	              y[g].apply(a, [b]);
	            });
	          }, y) {
	            c(d);
	          }
	        } else x && (F ? (x.show(), x.animate({ d: F })) : (x.hide(), z && (a.label = z = z.destroy())));e && G(e.text) && F && F.length && 0 < n.width && 0 < n.height && !F.flat ? (e = r({ align: f && B && "center", x: f ? !B && 4 : 10, verticalAlign: !f && B && "middle", y: f ? B ? 16 : 10 : B ? 6 : -4, rotation: f && !B && 90 }, e), this.renderLabel(e, F, B, m)) : z && z.hide();return a;
	      }, renderLabel: function renderLabel(a, n, f, c) {
	        var e = this.label,
	            z = this.axis.chart.renderer;e || (e = { align: a.textAlign || a.align, rotation: a.rotation, "class": "highcharts-plot-" + (f ? "band" : "line") + "-label " + (a.className || "") }, e.zIndex = c, this.label = e = z.text(a.text, 0, 0, a.useHTML).attr(e).add(), e.css(a.style));c = [n[1], n[4], f ? n[6] : n[1]];n = [n[2], n[5], f ? n[7] : n[2]];f = C(c);z = C(n);e.align(a, !1, { x: f, y: z, width: D(c) - f, height: D(n) - z });e.show();
	      }, destroy: function destroy() {
	        l(this.axis.plotLinesAndBands, this);delete this.axis;H(this);
	      } };a.AxisPlotLineOrBandExtension = { getPlotBandPath: function getPlotBandPath(a, n) {
	        var f = this.getPlotLinePath(n, null, null, !0),
	            c = this.getPlotLinePath(a, null, null, !0),
	            e = this.horiz,
	            z = 1;a = a < this.min && n < this.min || a > this.max && n > this.max;c && f ? (a && (c.flat = c.toString() === f.toString(), z = 0), c.push(e && f[4] === c[4] ? f[4] + z : f[4], e || f[5] !== c[5] ? f[5] : f[5] + z, e && f[1] === c[1] ? f[1] + z : f[1], e || f[2] !== c[2] ? f[2] : f[2] + z)) : c = null;return c;
	      }, addPlotBand: function addPlotBand(a) {
	        return this.addPlotBandOrLine(a, "plotBands");
	      }, addPlotLine: function addPlotLine(a) {
	        return this.addPlotBandOrLine(a, "plotLines");
	      }, addPlotBandOrLine: function addPlotBandOrLine(l, n) {
	        var f = new a.PlotLineOrBand(this, l).render(),
	            c = this.userOptions;f && (n && (c[n] = c[n] || [], c[n].push(l)), this.plotLinesAndBands.push(f));return f;
	      }, removePlotBandOrLine: function removePlotBandOrLine(a) {
	        for (var n = this.plotLinesAndBands, f = this.options, c = this.userOptions, e = n.length; e--;) {
	          n[e].id === a && n[e].destroy();
	        }v([f.plotLines || [], c.plotLines || [], f.plotBands || [], c.plotBands || []], function (c) {
	          for (e = c.length; e--;) {
	            c[e].id === a && l(c, c[e]);
	          }
	        });
	      } };
	  })(K);(function (a) {
	    var D = a.correctFloat,
	        C = a.defined,
	        G = a.destroyObjectProperties,
	        H = a.isNumber,
	        v = a.merge,
	        l = a.pick,
	        r = a.deg2rad;a.Tick = function (a, l, n, f) {
	      this.axis = a;this.pos = l;this.type = n || "";this.isNew = !0;n || f || this.addLabel();
	    };a.Tick.prototype = { addLabel: function addLabel() {
	        var a = this.axis,
	            q = a.options,
	            n = a.chart,
	            f = a.categories,
	            c = a.names,
	            e = this.pos,
	            z = q.labels,
	            b = a.tickPositions,
	            t = e === b[0],
	            h = e === b[b.length - 1],
	            c = f ? l(f[e], c[e], e) : e,
	            f = this.label,
	            b = b.info,
	            B;a.isDatetimeAxis && b && (B = q.dateTimeLabelFormats[b.higherRanks[e] || b.unitName]);this.isFirst = t;this.isLast = h;q = a.labelFormatter.call({ axis: a, chart: n, isFirst: t, isLast: h, dateTimeLabelFormat: B, value: a.isLog ? D(a.lin2log(c)) : c });C(f) ? f && f.attr({ text: q }) : (this.labelLength = (this.label = f = C(q) && z.enabled ? n.renderer.text(q, 0, 0, z.useHTML).css(v(z.style)).add(a.labelGroup) : null) && f.getBBox().width, this.rotation = 0);
	      }, getLabelSize: function getLabelSize() {
	        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
	      }, handleOverflow: function handleOverflow(a) {
	        var q = this.axis,
	            n = a.x,
	            f = q.chart.chartWidth,
	            c = q.chart.spacing,
	            e = l(q.labelLeft, Math.min(q.pos, c[3])),
	            c = l(q.labelRight, Math.max(q.pos + q.len, f - c[1])),
	            z = this.label,
	            b = this.rotation,
	            t = { left: 0, center: .5, right: 1 }[q.labelAlign],
	            h = z.getBBox().width,
	            B = q.getSlotWidth(),
	            p = B,
	            x = 1,
	            k,
	            F = {};if (b) 0 > b && n - t * h < e ? k = Math.round(n / Math.cos(b * r) - e) : 0 < b && n + t * h > c && (k = Math.round((f - n) / Math.cos(b * r)));else if (f = n + (1 - t) * h, n - t * h < e ? p = a.x + p * (1 - t) - e : f > c && (p = c - a.x + p * t, x = -1), p = Math.min(B, p), p < B && "center" === q.labelAlign && (a.x += x * (B - p - t * (B - Math.min(h, p)))), h > p || q.autoRotation && (z.styles || {}).width) k = p;k && (F.width = k, (q.options.labels.style || {}).textOverflow || (F.textOverflow = "ellipsis"), z.css(F));
	      }, getPosition: function getPosition(a, l, n, f) {
	        var c = this.axis,
	            e = c.chart,
	            z = f && e.oldChartHeight || e.chartHeight;return { x: a ? c.translate(l + n, null, null, f) + c.transB : c.left + c.offset + (c.opposite ? (f && e.oldChartWidth || e.chartWidth) - c.right - c.left : 0), y: a ? z - c.bottom + c.offset - (c.opposite ? c.height : 0) : z - c.translate(l + n, null, null, f) - c.transB };
	      }, getLabelPosition: function getLabelPosition(a, l, n, f, c, e, z, b) {
	        var t = this.axis,
	            h = t.transA,
	            B = t.reversed,
	            p = t.staggerLines,
	            x = t.tickRotCorr || { x: 0, y: 0 },
	            k = c.y;C(k) || (k = 0 === t.side ? n.rotation ? -8 : -n.getBBox().height : 2 === t.side ? x.y + 8 : Math.cos(n.rotation * r) * (x.y - n.getBBox(!1, 0).height / 2));a = a + c.x + x.x - (e && f ? e * h * (B ? -1 : 1) : 0);l = l + k - (e && !f ? e * h * (B ? 1 : -1) : 0);p && (n = z / (b || 1) % p, t.opposite && (n = p - n - 1), l += t.labelOffset / p * n);return { x: a, y: Math.round(l) };
	      }, getMarkPath: function getMarkPath(a, l, n, f, c, e) {
	        return e.crispLine(["M", a, l, "L", a + (c ? 0 : -n), l + (c ? n : 0)], f);
	      }, renderGridLine: function renderGridLine(a, l, n) {
	        var f = this.axis,
	            c = f.options,
	            e = this.gridLine,
	            z = {},
	            b = this.pos,
	            t = this.type,
	            h = f.tickmarkOffset,
	            B = f.chart.renderer,
	            p = t ? t + "Grid" : "grid",
	            x = c[p + "LineWidth"],
	            k = c[p + "LineColor"],
	            c = c[p + "LineDashStyle"];e || (z.stroke = k, z["stroke-width"] = x, c && (z.dashstyle = c), t || (z.zIndex = 1), a && (z.opacity = 0), this.gridLine = e = B.path().attr(z).addClass("highcharts-" + (t ? t + "-" : "") + "grid-line").add(f.gridGroup));if (!a && e && (a = f.getPlotLinePath(b + h, e.strokeWidth() * n, a, !0))) e[this.isNew ? "attr" : "animate"]({ d: a, opacity: l });
	      }, renderMark: function renderMark(a, q, n) {
	        var f = this.axis,
	            c = f.options,
	            e = f.chart.renderer,
	            z = this.type,
	            b = z ? z + "Tick" : "tick",
	            t = f.tickSize(b),
	            h = this.mark,
	            B = !h,
	            p = a.x;a = a.y;var x = l(c[b + "Width"], !z && f.isXAxis ? 1 : 0),
	            c = c[b + "Color"];t && (f.opposite && (t[0] = -t[0]), B && (this.mark = h = e.path().addClass("highcharts-" + (z ? z + "-" : "") + "tick").add(f.axisGroup), h.attr({ stroke: c, "stroke-width": x })), h[B ? "attr" : "animate"]({ d: this.getMarkPath(p, a, t[0], h.strokeWidth() * n, f.horiz, e), opacity: q }));
	      }, renderLabel: function renderLabel(a, q, n, f) {
	        var c = this.axis,
	            e = c.horiz,
	            z = c.options,
	            b = this.label,
	            t = z.labels,
	            h = t.step,
	            B = c.tickmarkOffset,
	            p = !0,
	            x = a.x;a = a.y;b && H(x) && (b.xy = a = this.getLabelPosition(x, a, b, e, t, B, f, h), this.isFirst && !this.isLast && !l(z.showFirstLabel, 1) || this.isLast && !this.isFirst && !l(z.showLastLabel, 1) ? p = !1 : !e || c.isRadial || t.step || t.rotation || q || 0 === n || this.handleOverflow(a), h && f % h && (p = !1), p && H(a.y) ? (a.opacity = n, b[this.isNew ? "attr" : "animate"](a)) : b.attr("y", -9999), this.isNew = !1);
	      }, render: function render(a, q, n) {
	        var f = this.axis,
	            c = f.horiz,
	            e = this.getPosition(c, this.pos, f.tickmarkOffset, q),
	            z = e.x,
	            b = e.y,
	            f = c && z === f.pos + f.len || !c && b === f.pos ? -1 : 1;n = l(n, 1);this.isActive = !0;this.renderGridLine(q, n, f);this.renderMark(e, n, f);this.renderLabel(e, q, n, a);
	      }, destroy: function destroy() {
	        G(this, this.axis);
	      } };
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.animObject,
	        G = a.arrayMax,
	        H = a.arrayMin,
	        v = a.AxisPlotLineOrBandExtension,
	        l = a.color,
	        r = a.correctFloat,
	        w = a.defaultOptions,
	        q = a.defined,
	        n = a.deg2rad,
	        f = a.destroyObjectProperties,
	        c = a.each,
	        e = a.extend,
	        z = a.fireEvent,
	        b = a.format,
	        t = a.getMagnitude,
	        h = a.grep,
	        B = a.inArray,
	        p = a.isArray,
	        x = a.isNumber,
	        k = a.isString,
	        F = a.merge,
	        d = a.normalizeTickInterval,
	        u = a.pick,
	        m = a.PlotLineOrBand,
	        y = a.removeEvent,
	        J = a.splat,
	        E = a.syncTimeout,
	        I = a.Tick;a.Axis = function () {
	      this.init.apply(this, arguments);
	    };a.Axis.prototype = { defaultOptions: { dateTimeLabelFormats: { millisecond: "%H:%M:%S.%L", second: "%H:%M:%S",
	          minute: "%H:%M", hour: "%H:%M", day: "%e. %b", week: "%e. %b", month: "%b '%y", year: "%Y" }, endOnTick: !1, labels: { enabled: !0, style: { color: "#666666", cursor: "default", fontSize: "11px" }, x: 0 }, minPadding: .01, maxPadding: .01, minorTickLength: 2, minorTickPosition: "outside", startOfWeek: 1, startOnTick: !1, tickLength: 10, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", title: { align: "middle", style: { color: "#666666" } }, type: "linear", minorGridLineColor: "#f2f2f2", minorGridLineWidth: 1, minorTickColor: "#999999",
	        lineColor: "#ccd6eb", lineWidth: 1, gridLineColor: "#e6e6e6", tickColor: "#ccd6eb" }, defaultYAxisOptions: { endOnTick: !0, tickPixelInterval: 72, showLastLabel: !0, labels: { x: -8 }, maxPadding: .05, minPadding: .05, startOnTick: !0, title: { rotation: 270, text: "Values" }, stackLabels: { enabled: !1, formatter: function formatter() {
	            return a.numberFormat(this.total, -1);
	          }, style: { fontSize: "11px", fontWeight: "bold", color: "#000000", textOutline: "1px contrast" } }, gridLineWidth: 1, lineWidth: 0 }, defaultLeftAxisOptions: { labels: { x: -15 }, title: { rotation: 270 } },
	      defaultRightAxisOptions: { labels: { x: 15 }, title: { rotation: 90 } }, defaultBottomAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } }, defaultTopAxisOptions: { labels: { autoRotation: [-45], x: 0 }, title: { rotation: 0 } }, init: function init(a, b) {
	        var g = b.isX;this.chart = a;this.horiz = a.inverted ? !g : g;this.isXAxis = g;this.coll = this.coll || (g ? "xAxis" : "yAxis");this.opposite = b.opposite;this.side = b.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);this.setOptions(b);var d = this.options,
	            c = d.type;this.labelFormatter = d.labels.formatter || this.defaultLabelFormatter;this.userOptions = b;this.minPixelPadding = 0;this.reversed = d.reversed;this.visible = !1 !== d.visible;this.zoomEnabled = !1 !== d.zoomEnabled;this.hasNames = "category" === c || !0 === d.categories;this.categories = d.categories || this.hasNames;this.names = this.names || [];this.plotLinesAndBandsGroups = {};this.isLog = "logarithmic" === c;this.isDatetimeAxis = "datetime" === c;this.positiveValuesOnly = this.isLog && !this.allowNegativeLog;this.isLinked = q(d.linkedTo);this.ticks = {};this.labelEdge = [];this.minorTicks = {};this.plotLinesAndBands = [];this.alternateBands = {};this.len = 0;this.minRange = this.userMinRange = d.minRange || d.maxZoom;this.range = d.range;this.offset = d.offset || 0;this.stacks = {};this.oldStacks = {};this.stacksTouched = 0;this.min = this.max = null;this.crosshair = u(d.crosshair, J(a.options.tooltip.crosshairs)[g ? 0 : 1], !1);var m;b = this.options.events;-1 === B(this, a.axes) && (g ? a.axes.splice(a.xAxis.length, 0, this) : a.axes.push(this), a[this.coll].push(this));this.series = this.series || [];a.inverted && g && void 0 === this.reversed && (this.reversed = !0);this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine;for (m in b) {
	          D(this, m, b[m]);
	        }this.lin2log = d.linearToLogConverter || this.lin2log;this.isLog && (this.val2lin = this.log2lin, this.lin2val = this.lin2log);
	      }, setOptions: function setOptions(a) {
	        this.options = F(this.defaultOptions, "yAxis" === this.coll && this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], F(w[this.coll], a));
	      }, defaultLabelFormatter: function defaultLabelFormatter() {
	        var g = this.axis,
	            d = this.value,
	            c = g.categories,
	            m = this.dateTimeLabelFormat,
	            h = w.lang,
	            k = h.numericSymbols,
	            h = h.numericSymbolMagnitude || 1E3,
	            p = k && k.length,
	            y,
	            E = g.options.labels.format,
	            g = g.isLog ? Math.abs(d) : g.tickInterval;if (E) y = b(E, this);else if (c) y = d;else if (m) y = a.dateFormat(m, d);else if (p && 1E3 <= g) for (; p-- && void 0 === y;) {
	          c = Math.pow(h, p + 1), g >= c && 0 === 10 * d % c && null !== k[p] && 0 !== d && (y = a.numberFormat(d / c, -1) + k[p]);
	        }void 0 === y && (y = 1E4 <= Math.abs(d) ? a.numberFormat(d, -1) : a.numberFormat(d, -1, void 0, ""));return y;
	      }, getSeriesExtremes: function getSeriesExtremes() {
	        var a = this,
	            b = a.chart;a.hasVisibleSeries = !1;a.dataMin = a.dataMax = a.threshold = null;a.softThreshold = !a.isXAxis;a.buildStacks && a.buildStacks();c(a.series, function (g) {
	          if (g.visible || !b.options.chart.ignoreHiddenSeries) {
	            var d = g.options,
	                c = d.threshold,
	                m;a.hasVisibleSeries = !0;a.positiveValuesOnly && 0 >= c && (c = null);if (a.isXAxis) d = g.xData, d.length && (g = H(d), x(g) || g instanceof Date || (d = h(d, function (a) {
	              return x(a);
	            }), g = H(d)), a.dataMin = Math.min(u(a.dataMin, d[0]), g), a.dataMax = Math.max(u(a.dataMax, d[0]), G(d)));else if (g.getExtremes(), m = g.dataMax, g = g.dataMin, q(g) && q(m) && (a.dataMin = Math.min(u(a.dataMin, g), g), a.dataMax = Math.max(u(a.dataMax, m), m)), q(c) && (a.threshold = c), !d.softThreshold || a.positiveValuesOnly) a.softThreshold = !1;
	          }
	        });
	      }, translate: function translate(a, b, d, c, m, h) {
	        var g = this.linkedParent || this,
	            k = 1,
	            p = 0,
	            y = c ? g.oldTransA : g.transA;c = c ? g.oldMin : g.min;var L = g.minPixelPadding;m = (g.isOrdinal || g.isBroken || g.isLog && m) && g.lin2val;y || (y = g.transA);d && (k *= -1, p = g.len);g.reversed && (k *= -1, p -= k * (g.sector || g.len));b ? (a = (a * k + p - L) / y + c, m && (a = g.lin2val(a))) : (m && (a = g.val2lin(a)), a = k * (a - c) * y + p + k * L + (x(h) ? y * h : 0));return a;
	      }, toPixels: function toPixels(a, b) {
	        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
	      }, toValue: function toValue(a, b) {
	        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
	      }, getPlotLinePath: function getPlotLinePath(a, b, d, c, m) {
	        var g = this.chart,
	            h = this.left,
	            k = this.top,
	            y,
	            p,
	            L = d && g.oldChartHeight || g.chartHeight,
	            E = d && g.oldChartWidth || g.chartWidth,
	            t;y = this.transB;var e = function e(a, b, g) {
	          if (a < b || a > g) c ? a = Math.min(Math.max(b, a), g) : t = !0;return a;
	        };m = u(m, this.translate(a, null, null, d));a = d = Math.round(m + y);y = p = Math.round(L - m - y);x(m) ? this.horiz ? (y = k, p = L - this.bottom, a = d = e(a, h, h + this.width)) : (a = h, d = E - this.right, y = p = e(y, k, k + this.height)) : t = !0;return t && !c ? null : g.renderer.crispLine(["M", a, y, "L", d, p], b || 1);
	      }, getLinearTickPositions: function getLinearTickPositions(a, b, d) {
	        var g,
	            c = r(Math.floor(b / a) * a);d = r(Math.ceil(d / a) * a);var m = [];if (this.single) return [b];for (b = c; b <= d;) {
	          m.push(b);b = r(b + a);if (b === g) break;g = b;
	        }return m;
	      }, getMinorTickPositions: function getMinorTickPositions() {
	        var a = this,
	            b = a.options,
	            d = a.tickPositions,
	            m = a.minorTickInterval,
	            h = [],
	            k = a.pointRangePadding || 0,
	            y = a.min - k,
	            k = a.max + k,
	            p = k - y;if (p && p / m < a.len / 3) if (a.isLog) c(this.paddedTicks, function (b, g, d) {
	          g && h.push.apply(h, a.getLogTickPositions(m, d[g - 1], d[g], !0));
	        });else if (a.isDatetimeAxis && "auto" === b.minorTickInterval) h = h.concat(a.getTimeTicks(a.normalizeTimeTickInterval(m), y, k, b.startOfWeek));else for (b = y + (d[0] - y) % m; b <= k && b !== h[0]; b += m) {
	          h.push(b);
	        }0 !== h.length && a.trimTicks(h);return h;
	      }, adjustForMinRange: function adjustForMinRange() {
	        var a = this.options,
	            b = this.min,
	            d = this.max,
	            m,
	            h = this.dataMax - this.dataMin >= this.minRange,
	            k,
	            y,
	            p,
	            E,
	            x,
	            t;this.isXAxis && void 0 === this.minRange && !this.isLog && (q(a.min) || q(a.max) ? this.minRange = null : (c(this.series, function (a) {
	          E = a.xData;for (y = x = a.xIncrement ? 1 : E.length - 1; 0 < y; y--) {
	            if (p = E[y] - E[y - 1], void 0 === k || p < k) k = p;
	          }
	        }), this.minRange = Math.min(5 * k, this.dataMax - this.dataMin)));d - b < this.minRange && (t = this.minRange, m = (t - d + b) / 2, m = [b - m, u(a.min, b - m)], h && (m[2] = this.isLog ? this.log2lin(this.dataMin) : this.dataMin), b = G(m), d = [b + t, u(a.max, b + t)], h && (d[2] = this.isLog ? this.log2lin(this.dataMax) : this.dataMax), d = H(d), d - b < t && (m[0] = d - t, m[1] = u(a.min, d - t), b = G(m)));this.min = b;this.max = d;
	      }, getClosest: function getClosest() {
	        var a;this.categories ? a = 1 : c(this.series, function (b) {
	          var g = b.closestPointRange,
	              d = b.visible || !b.chart.options.chart.ignoreHiddenSeries;!b.noSharedTooltip && q(g) && d && (a = q(a) ? Math.min(a, g) : g);
	        });return a;
	      }, nameToX: function nameToX(a) {
	        var b = p(this.categories),
	            g = b ? this.categories : this.names,
	            d = a.options.x,
	            c;a.series.requireSorting = !1;q(d) || (d = !1 === this.options.uniqueNames ? a.series.autoIncrement() : B(a.name, g));-1 === d ? b || (c = g.length) : c = d;void 0 !== c && (this.names[c] = a.name);return c;
	      }, updateNames: function updateNames() {
	        var a = this;0 < this.names.length && (this.names.length = 0, this.minRange = void 0, c(this.series || [], function (b) {
	          b.xIncrement = null;if (!b.points || b.isDirtyData) b.processData(), b.generatePoints();c(b.points, function (g, d) {
	            var c;g.options && (c = a.nameToX(g), void 0 !== c && c !== g.x && (g.x = c, b.xData[d] = c));
	          });
	        }));
	      }, setAxisTranslation: function setAxisTranslation(a) {
	        var b = this,
	            g = b.max - b.min,
	            d = b.axisPointRange || 0,
	            m,
	            h = 0,
	            y = 0,
	            p = b.linkedParent,
	            E = !!b.categories,
	            x = b.transA,
	            t = b.isXAxis;if (t || E || d) m = b.getClosest(), p ? (h = p.minPointOffset, y = p.pointRangePadding) : c(b.series, function (a) {
	          var g = E ? 1 : t ? u(a.options.pointRange, m, 0) : b.axisPointRange || 0;a = a.options.pointPlacement;d = Math.max(d, g);b.single || (h = Math.max(h, k(a) ? 0 : g / 2), y = Math.max(y, "on" === a ? 0 : g));
	        }), p = b.ordinalSlope && m ? b.ordinalSlope / m : 1, b.minPointOffset = h *= p, b.pointRangePadding = y *= p, b.pointRange = Math.min(d, g), t && (b.closestPointRange = m);a && (b.oldTransA = x);b.translationSlope = b.transA = x = b.options.staticScale || b.len / (g + y || 1);b.transB = b.horiz ? b.left : b.bottom;b.minPixelPadding = x * h;
	      }, minFromRange: function minFromRange() {
	        return this.max - this.range;
	      }, setTickInterval: function setTickInterval(b) {
	        var g = this,
	            m = g.chart,
	            h = g.options,
	            k = g.isLog,
	            y = g.log2lin,
	            p = g.isDatetimeAxis,
	            E = g.isXAxis,
	            e = g.isLinked,
	            I = h.maxPadding,
	            B = h.minPadding,
	            f = h.tickInterval,
	            F = h.tickPixelInterval,
	            J = g.categories,
	            l = g.threshold,
	            n = g.softThreshold,
	            w,
	            v,
	            C,
	            D;p || J || e || this.getTickAmount();C = u(g.userMin, h.min);D = u(g.userMax, h.max);e ? (g.linkedParent = m[g.coll][h.linkedTo], m = g.linkedParent.getExtremes(), g.min = u(m.min, m.dataMin), g.max = u(m.max, m.dataMax), h.type !== g.linkedParent.options.type && a.error(11, 1)) : (!n && q(l) && (g.dataMin >= l ? (w = l, B = 0) : g.dataMax <= l && (v = l, I = 0)), g.min = u(C, w, g.dataMin), g.max = u(D, v, g.dataMax));k && (g.positiveValuesOnly && !b && 0 >= Math.min(g.min, u(g.dataMin, g.min)) && a.error(10, 1), g.min = r(y(g.min), 15), g.max = r(y(g.max), 15));g.range && q(g.max) && (g.userMin = g.min = C = Math.max(g.min, g.minFromRange()), g.userMax = D = g.max, g.range = null);z(g, "foundExtremes");g.beforePadding && g.beforePadding();g.adjustForMinRange();
	        !(J || g.axisPointRange || g.usePercentage || e) && q(g.min) && q(g.max) && (y = g.max - g.min) && (!q(C) && B && (g.min -= y * B), !q(D) && I && (g.max += y * I));x(h.softMin) && (g.min = Math.min(g.min, h.softMin));x(h.softMax) && (g.max = Math.max(g.max, h.softMax));x(h.floor) && (g.min = Math.max(g.min, h.floor));x(h.ceiling) && (g.max = Math.min(g.max, h.ceiling));n && q(g.dataMin) && (l = l || 0, !q(C) && g.min < l && g.dataMin >= l ? g.min = l : !q(D) && g.max > l && g.dataMax <= l && (g.max = l));g.tickInterval = g.min === g.max || void 0 === g.min || void 0 === g.max ? 1 : e && !f && F === g.linkedParent.options.tickPixelInterval ? f = g.linkedParent.tickInterval : u(f, this.tickAmount ? (g.max - g.min) / Math.max(this.tickAmount - 1, 1) : void 0, J ? 1 : (g.max - g.min) * F / Math.max(g.len, F));E && !b && c(g.series, function (a) {
	          a.processData(g.min !== g.oldMin || g.max !== g.oldMax);
	        });g.setAxisTranslation(!0);g.beforeSetTickPositions && g.beforeSetTickPositions();g.postProcessTickInterval && (g.tickInterval = g.postProcessTickInterval(g.tickInterval));g.pointRange && !f && (g.tickInterval = Math.max(g.pointRange, g.tickInterval));b = u(h.minTickInterval, g.isDatetimeAxis && g.closestPointRange);
	        !f && g.tickInterval < b && (g.tickInterval = b);p || k || f || (g.tickInterval = d(g.tickInterval, null, t(g.tickInterval), u(h.allowDecimals, !(.5 < g.tickInterval && 5 > g.tickInterval && 1E3 < g.max && 9999 > g.max)), !!this.tickAmount));this.tickAmount || (g.tickInterval = g.unsquish());this.setTickPositions();
	      }, setTickPositions: function setTickPositions() {
	        var a = this.options,
	            b,
	            d = a.tickPositions,
	            c = a.tickPositioner,
	            m = a.startOnTick,
	            h = a.endOnTick;this.tickmarkOffset = this.categories && "between" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;this.minorTickInterval = "auto" === a.minorTickInterval && this.tickInterval ? this.tickInterval / 5 : a.minorTickInterval;this.single = this.min === this.max && q(this.min) && !this.tickAmount && !1 !== a.allowDecimals;this.tickPositions = b = d && d.slice();!b && (b = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), b.length > this.len && (b = [b[0], b.pop()]), this.tickPositions = b, c && (c = c.apply(this, [this.min, this.max]))) && (this.tickPositions = b = c);this.paddedTicks = b.slice(0);this.trimTicks(b, m, h);this.isLinked || (this.single && (this.min -= .5, this.max += .5), d || c || this.adjustTickAmount());
	      }, trimTicks: function trimTicks(a, b, d) {
	        var g = a[0],
	            c = a[a.length - 1],
	            m = this.minPointOffset || 0;if (!this.isLinked) {
	          if (b && -Infinity !== g) this.min = g;else for (; this.min - m > a[0];) {
	            a.shift();
	          }if (d) this.max = c;else for (; this.max + m < a[a.length - 1];) {
	            a.pop();
	          }0 === a.length && q(g) && a.push((c + g) / 2);
	        }
	      }, alignToOthers: function alignToOthers() {
	        var a = {},
	            b,
	            d = this.options;!1 === this.chart.options.chart.alignTicks || !1 === d.alignTicks || this.isLog || c(this.chart[this.coll], function (g) {
	          var d = g.options,
	              d = [g.horiz ? d.left : d.top, d.width, d.height, d.pane].join();g.series.length && (a[d] ? b = !0 : a[d] = 1);
	        });return b;
	      }, getTickAmount: function getTickAmount() {
	        var a = this.options,
	            b = a.tickAmount,
	            d = a.tickPixelInterval;!q(a.tickInterval) && this.len < d && !this.isRadial && !this.isLog && a.startOnTick && a.endOnTick && (b = 2);!b && this.alignToOthers() && (b = Math.ceil(this.len / d) + 1);4 > b && (this.finalTickAmt = b, b = 5);this.tickAmount = b;
	      }, adjustTickAmount: function adjustTickAmount() {
	        var a = this.tickInterval,
	            b = this.tickPositions,
	            d = this.tickAmount,
	            c = this.finalTickAmt,
	            m = b && b.length;if (m < d) {
	          for (; b.length < d;) {
	            b.push(r(b[b.length - 1] + a));
	          }this.transA *= (m - 1) / (d - 1);this.max = b[b.length - 1];
	        } else m > d && (this.tickInterval *= 2, this.setTickPositions());if (q(c)) {
	          for (a = d = b.length; a--;) {
	            (3 === c && 1 === a % 2 || 2 >= c && 0 < a && a < d - 1) && b.splice(a, 1);
	          }this.finalTickAmt = void 0;
	        }
	      }, setScale: function setScale() {
	        var a, b;this.oldMin = this.min;this.oldMax = this.max;this.oldAxisLength = this.len;this.setAxisSize();b = this.len !== this.oldAxisLength;c(this.series, function (b) {
	          if (b.isDirtyData || b.isDirty || b.xAxis.isDirty) a = !0;
	        });b || a || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.resetStacks && this.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = b || this.min !== this.oldMin || this.max !== this.oldMax)) : this.cleanStacks && this.cleanStacks();
	      }, setExtremes: function setExtremes(a, b, d, m, h) {
	        var g = this,
	            k = g.chart;d = u(d, !0);c(g.series, function (a) {
	          delete a.kdTree;
	        });h = e(h, { min: a, max: b });z(g, "setExtremes", h, function () {
	          g.userMin = a;g.userMax = b;g.eventArgs = h;d && k.redraw(m);
	        });
	      }, zoom: function zoom(a, b) {
	        var g = this.dataMin,
	            d = this.dataMax,
	            c = this.options,
	            m = Math.min(g, u(c.min, g)),
	            c = Math.max(d, u(c.max, d));if (a !== this.min || b !== this.max) this.allowZoomOutside || (q(g) && (a < m && (a = m), a > c && (a = c)), q(d) && (b < m && (b = m), b > c && (b = c))), this.displayBtn = void 0 !== a || void 0 !== b, this.setExtremes(a, b, !1, void 0, { trigger: "zoom" });return !0;
	      }, setAxisSize: function setAxisSize() {
	        var a = this.chart,
	            b = this.options,
	            d = b.offsets || [0, 0, 0, 0],
	            c = this.horiz,
	            m = u(b.width, a.plotWidth - d[3] + d[1]),
	            h = u(b.height, a.plotHeight - d[0] + d[2]),
	            k = u(b.top, a.plotTop + d[0]),
	            b = u(b.left, a.plotLeft + d[3]),
	            d = /%$/;d.test(h) && (h = Math.round(parseFloat(h) / 100 * a.plotHeight));d.test(k) && (k = Math.round(parseFloat(k) / 100 * a.plotHeight + a.plotTop));this.left = b;this.top = k;
	        this.width = m;this.height = h;this.bottom = a.chartHeight - h - k;this.right = a.chartWidth - m - b;this.len = Math.max(c ? m : h, 0);this.pos = c ? b : k;
	      }, getExtremes: function getExtremes() {
	        var a = this.isLog,
	            b = this.lin2log;return { min: a ? r(b(this.min)) : this.min, max: a ? r(b(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
	      }, getThreshold: function getThreshold(a) {
	        var b = this.isLog,
	            g = this.lin2log,
	            d = b ? g(this.min) : this.min,
	            b = b ? g(this.max) : this.max;null === a ? a = d : d > a ? a = d : b < a && (a = b);return this.translate(a, 0, 1, 0, 1);
	      }, autoLabelAlign: function autoLabelAlign(a) {
	        a = (u(a, 0) - 90 * this.side + 720) % 360;return 15 < a && 165 > a ? "right" : 195 < a && 345 > a ? "left" : "center";
	      }, tickSize: function tickSize(a) {
	        var b = this.options,
	            g = b[a + "Length"],
	            d = u(b[a + "Width"], "tick" === a && this.isXAxis ? 1 : 0);if (d && g) return "inside" === b[a + "Position"] && (g = -g), [g, d];
	      }, labelMetrics: function labelMetrics() {
	        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[0] && this.ticks[0].label);
	      }, unsquish: function unsquish() {
	        var a = this.options.labels,
	            b = this.horiz,
	            d = this.tickInterval,
	            m = d,
	            h = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / d),
	            k,
	            y = a.rotation,
	            p = this.labelMetrics(),
	            E,
	            x = Number.MAX_VALUE,
	            t,
	            e = function e(a) {
	          a /= h || 1;a = 1 < a ? Math.ceil(a) : 1;return a * d;
	        };b ? (t = !a.staggerLines && !a.step && (q(y) ? [y] : h < u(a.autoRotationLimit, 80) && a.autoRotation)) && c(t, function (a) {
	          var b;if (a === y || a && -90 <= a && 90 >= a) E = e(Math.abs(p.h / Math.sin(n * a))), b = E + Math.abs(a / 360), b < x && (x = b, k = a, m = E);
	        }) : a.step || (m = e(p.h));this.autoRotation = t;this.labelRotation = u(k, y);return m;
	      }, getSlotWidth: function getSlotWidth() {
	        var a = this.chart,
	            b = this.horiz,
	            d = this.options.labels,
	            c = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),
	            m = a.margin[3];return b && 2 > (d.step || 0) && !d.rotation && (this.staggerLines || 1) * this.len / c || !b && (m && m - a.spacing[3] || .33 * a.chartWidth);
	      }, renderUnsquish: function renderUnsquish() {
	        var a = this.chart,
	            b = a.renderer,
	            d = this.tickPositions,
	            m = this.ticks,
	            h = this.options.labels,
	            y = this.horiz,
	            p = this.getSlotWidth(),
	            E = Math.max(1, Math.round(p - 2 * (h.padding || 5))),
	            t = {},
	            x = this.labelMetrics(),
	            e = h.style && h.style.textOverflow,
	            u,
	            I = 0,
	            B,
	            f;k(h.rotation) || (t.rotation = h.rotation || 0);c(d, function (a) {
	          (a = m[a]) && a.labelLength > I && (I = a.labelLength);
	        });this.maxLabelLength = I;if (this.autoRotation) I > E && I > x.h ? t.rotation = this.labelRotation : this.labelRotation = 0;else if (p && (u = { width: E + "px" }, !e)) for (u.textOverflow = "clip", B = d.length; !y && B--;) {
	          if (f = d[B], E = m[f].label) E.styles && "ellipsis" === E.styles.textOverflow ? E.css({ textOverflow: "clip" }) : m[f].labelLength > p && E.css({ width: p + "px" }), E.getBBox().height > this.len / d.length - (x.h - x.f) && (E.specCss = { textOverflow: "ellipsis" });
	        }t.rotation && (u = { width: (I > .5 * a.chartHeight ? .33 * a.chartHeight : a.chartHeight) + "px" }, e || (u.textOverflow = "ellipsis"));if (this.labelAlign = h.align || this.autoLabelAlign(this.labelRotation)) t.align = this.labelAlign;c(d, function (a) {
	          var b = (a = m[a]) && a.label;b && (b.attr(t), u && b.css(F(u, b.specCss)), delete b.specCss, a.rotation = t.rotation);
	        });this.tickRotCorr = b.rotCorr(x.b, this.labelRotation || 0, 0 !== this.side);
	      }, hasData: function hasData() {
	        return this.hasVisibleSeries || q(this.min) && q(this.max) && !!this.tickPositions;
	      }, addTitle: function addTitle(a) {
	        var b = this.chart.renderer,
	            g = this.horiz,
	            d = this.opposite,
	            c = this.options.title,
	            m;this.axisTitle || ((m = c.textAlign) || (m = (g ? { low: "left", middle: "center", high: "right" } : { low: d ? "right" : "left", middle: "center", high: d ? "left" : "right" })[c.align]), this.axisTitle = b.text(c.text, 0, 0, c.useHTML).attr({ zIndex: 7, rotation: c.rotation || 0, align: m }).addClass("highcharts-axis-title").css(c.style).add(this.axisGroup), this.axisTitle.isNew = !0);this.axisTitle[a ? "show" : "hide"](!0);
	      }, generateTick: function generateTick(a) {
	        var b = this.ticks;b[a] ? b[a].addLabel() : b[a] = new I(this, a);
	      }, getOffset: function getOffset() {
	        var a = this,
	            b = a.chart,
	            d = b.renderer,
	            m = a.options,
	            h = a.tickPositions,
	            k = a.ticks,
	            y = a.horiz,
	            p = a.side,
	            E = b.inverted ? [1, 0, 3, 2][p] : p,
	            t,
	            x,
	            e = 0,
	            I,
	            B = 0,
	            f = m.title,
	            z = m.labels,
	            F = 0,
	            J = b.axisOffset,
	            b = b.clipOffset,
	            l = [-1, 1, 1, -1][p],
	            n,
	            r = m.className,
	            w = a.axisParent,
	            v = this.tickSize("tick");t = a.hasData();a.showAxis = x = t || u(m.showEmpty, !0);a.staggerLines = a.horiz && z.staggerLines;a.axisGroup || (a.gridGroup = d.g("grid").attr({ zIndex: m.gridZIndex || 1 }).addClass("highcharts-" + this.coll.toLowerCase() + "-grid " + (r || "")).add(w), a.axisGroup = d.g("axis").attr({ zIndex: m.zIndex || 2 }).addClass("highcharts-" + this.coll.toLowerCase() + " " + (r || "")).add(w), a.labelGroup = d.g("axis-labels").attr({ zIndex: z.zIndex || 7 }).addClass("highcharts-" + a.coll.toLowerCase() + "-labels " + (r || "")).add(w));if (t || a.isLinked) c(h, function (b, g) {
	          a.generateTick(b, g);
	        }), a.renderUnsquish(), !1 === z.reserveSpace || 0 !== p && 2 !== p && { 1: "left", 3: "right" }[p] !== a.labelAlign && "center" !== a.labelAlign || c(h, function (a) {
	          F = Math.max(k[a].getLabelSize(), F);
	        }), a.staggerLines && (F *= a.staggerLines, a.labelOffset = F * (a.opposite ? -1 : 1));else for (n in k) {
	          k[n].destroy(), delete k[n];
	        }f && f.text && !1 !== f.enabled && (a.addTitle(x), x && (e = a.axisTitle.getBBox()[y ? "height" : "width"], I = f.offset, B = q(I) ? 0 : u(f.margin, y ? 5 : 10)));a.renderLine();a.offset = l * u(m.offset, J[p]);a.tickRotCorr = a.tickRotCorr || { x: 0, y: 0 };d = 0 === p ? -a.labelMetrics().h : 2 === p ? a.tickRotCorr.y : 0;B = Math.abs(F) + B;F && (B = B - d + l * (y ? u(z.y, a.tickRotCorr.y + 8 * l) : z.x));a.axisTitleMargin = u(I, B);J[p] = Math.max(J[p], a.axisTitleMargin + e + l * a.offset, B, t && h.length && v ? v[0] + l * a.offset : 0);m = m.offset ? 0 : 2 * Math.floor(a.axisLine.strokeWidth() / 2);b[E] = Math.max(b[E], m);
	      }, getLinePath: function getLinePath(a) {
	        var b = this.chart,
	            g = this.opposite,
	            d = this.offset,
	            c = this.horiz,
	            m = this.left + (g ? this.width : 0) + d,
	            d = b.chartHeight - this.bottom - (g ? this.height : 0) + d;g && (a *= -1);return b.renderer.crispLine(["M", c ? this.left : m, c ? d : this.top, "L", c ? b.chartWidth - this.right : m, c ? d : b.chartHeight - this.bottom], a);
	      }, renderLine: function renderLine() {
	        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
	      }, getTitlePosition: function getTitlePosition() {
	        var a = this.horiz,
	            b = this.left,
	            d = this.top,
	            c = this.len,
	            m = this.options.title,
	            h = a ? b : d,
	            k = this.opposite,
	            y = this.offset,
	            p = m.x || 0,
	            E = m.y || 0,
	            t = this.chart.renderer.fontMetrics(m.style && m.style.fontSize, this.axisTitle).f,
	            c = { low: h + (a ? 0 : c), middle: h + c / 2, high: h + (a ? c : 0) }[m.align],
	            b = (a ? d + this.height : b) + (a ? 1 : -1) * (k ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? t : 0);return { x: a ? c + p : b + (k ? this.width : 0) + y + p, y: a ? b + E - (k ? this.height : 0) + y : c + E };
	      }, renderMinorTick: function renderMinorTick(a) {
	        var b = this.chart.hasRendered && x(this.oldMin),
	            g = this.minorTicks;g[a] || (g[a] = new I(this, a, "minor"));b && g[a].isNew && g[a].render(null, !0);g[a].render(null, !1, 1);
	      }, renderTick: function renderTick(a, b) {
	        var g = this.isLinked,
	            d = this.ticks,
	            c = this.chart.hasRendered && x(this.oldMin);if (!g || a >= this.min && a <= this.max) d[a] || (d[a] = new I(this, a)), c && d[a].isNew && d[a].render(b, !0, .1), d[a].render(b);
	      }, render: function render() {
	        var a = this,
	            b = a.chart,
	            d = a.options,
	            h = a.isLog,
	            k = a.lin2log,
	            y = a.isLinked,
	            p = a.tickPositions,
	            t = a.axisTitle,
	            x = a.ticks,
	            e = a.minorTicks,
	            u = a.alternateBands,
	            B = d.stackLabels,
	            f = d.alternateGridColor,
	            z = a.tickmarkOffset,
	            F = a.axisLine,
	            J = a.showAxis,
	            l = C(b.renderer.globalAnimation),
	            n,
	            q;a.labelEdge.length = 0;a.overlap = !1;c([x, e, u], function (a) {
	          for (var b in a) {
	            a[b].isActive = !1;
	          }
	        });if (a.hasData() || y) a.minorTickInterval && !a.categories && c(a.getMinorTickPositions(), function (b) {
	          a.renderMinorTick(b);
	        }), p.length && (c(p, function (b, d) {
	          a.renderTick(b, d);
	        }), z && (0 === a.min || a.single) && (x[-1] || (x[-1] = new I(a, -1, null, !0)), x[-1].render(-1))), f && c(p, function (d, g) {
	          q = void 0 !== p[g + 1] ? p[g + 1] + z : a.max - z;0 === g % 2 && d < a.max && q <= a.max + (b.polar ? -z : z) && (u[d] || (u[d] = new m(a)), n = d + z, u[d].options = { from: h ? k(n) : n, to: h ? k(q) : q, color: f }, u[d].render(), u[d].isActive = !0);
	        }), a._addedPlotLB || (c((d.plotLines || []).concat(d.plotBands || []), function (b) {
	          a.addPlotBandOrLine(b);
	        }), a._addedPlotLB = !0);c([x, e, u], function (a) {
	          var d,
	              g,
	              c = [],
	              m = l.duration;for (d in a) {
	            a[d].isActive || (a[d].render(d, !1, 0), a[d].isActive = !1, c.push(d));
	          }E(function () {
	            for (g = c.length; g--;) {
	              a[c[g]] && !a[c[g]].isActive && (a[c[g]].destroy(), delete a[c[g]]);
	            }
	          }, a !== u && b.hasRendered && m ? m : 0);
	        });F && (F[F.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(F.strokeWidth()) }), F.isPlaced = !0, F[J ? "show" : "hide"](!0));t && J && (t[t.isNew ? "attr" : "animate"](a.getTitlePosition()), t.isNew = !1);B && B.enabled && a.renderStackTotals();a.isDirty = !1;
	      }, redraw: function redraw() {
	        this.visible && (this.render(), c(this.plotLinesAndBands, function (a) {
	          a.render();
	        }));c(this.series, function (a) {
	          a.isDirty = !0;
	        });
	      }, keepProps: "extKey hcEvents names series userMax userMin".split(" "),
	      destroy: function destroy(a) {
	        var b = this,
	            d = b.stacks,
	            g,
	            m = b.plotLinesAndBands,
	            h,
	            k;a || y(b);for (g in d) {
	          f(d[g]), d[g] = null;
	        }c([b.ticks, b.minorTicks, b.alternateBands], function (a) {
	          f(a);
	        });if (m) for (a = m.length; a--;) {
	          m[a].destroy();
	        }c("stackTotalGroup axisLine axisTitle axisGroup gridGroup labelGroup cross".split(" "), function (a) {
	          b[a] && (b[a] = b[a].destroy());
	        });for (h in b.plotLinesAndBandsGroups) {
	          b.plotLinesAndBandsGroups[h] = b.plotLinesAndBandsGroups[h].destroy();
	        }for (k in b) {
	          b.hasOwnProperty(k) && -1 === B(k, b.keepProps) && delete b[k];
	        }
	      },
	      drawCrosshair: function drawCrosshair(a, b) {
	        var d,
	            g = this.crosshair,
	            c = u(g.snap, !0),
	            m,
	            h = this.cross;a || (a = this.cross && this.cross.e);this.crosshair && !1 !== (q(b) || !c) ? (c ? q(b) && (m = this.isXAxis ? b.plotX : this.len - b.plotY) : m = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos), q(m) && (d = this.getPlotLinePath(b && (this.isXAxis ? b.x : u(b.stackY, b.y)), null, null, null, m) || null), q(d) ? (b = this.categories && !this.isRadial, h || (this.cross = h = this.chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (b ? "category " : "thin ") + g.className).attr({ zIndex: u(g.zIndex, 2) }).add(), h.attr({ stroke: g.color || (b ? l("#ccd6eb").setOpacity(.25).get() : "#cccccc"), "stroke-width": u(g.width, 1) }), g.dashStyle && h.attr({ dashstyle: g.dashStyle })), h.show().attr({ d: d }), b && !g.width && h.attr({ "stroke-width": this.transA }), this.cross.e = a) : this.hideCrosshair()) : this.hideCrosshair();
	      }, hideCrosshair: function hideCrosshair() {
	        this.cross && this.cross.hide();
	      } };e(a.Axis.prototype, v);
	  })(K);(function (a) {
	    var D = a.Axis,
	        C = a.Date,
	        G = a.dateFormat,
	        H = a.defaultOptions,
	        v = a.defined,
	        l = a.each,
	        r = a.extend,
	        w = a.getMagnitude,
	        q = a.getTZOffset,
	        n = a.normalizeTickInterval,
	        f = a.pick,
	        c = a.timeUnits;D.prototype.getTimeTicks = function (a, z, b, t) {
	      var h = [],
	          e = {},
	          p = H.global.useUTC,
	          x,
	          k = new C(z - Math.abs(q(z))),
	          F = C.hcMakeTime,
	          d = a.unitRange,
	          u = a.count,
	          m;if (v(z)) {
	        k[C.hcSetMilliseconds](d >= c.second ? 0 : u * Math.floor(k.getMilliseconds() / u));if (d >= c.second) k[C.hcSetSeconds](d >= c.minute ? 0 : u * Math.floor(k.getSeconds() / u));if (d >= c.minute) k[C.hcSetMinutes](d >= c.hour ? 0 : u * Math.floor(k[C.hcGetMinutes]() / u));if (d >= c.hour) k[C.hcSetHours](d >= c.day ? 0 : u * Math.floor(k[C.hcGetHours]() / u));if (d >= c.day) k[C.hcSetDate](d >= c.month ? 1 : u * Math.floor(k[C.hcGetDate]() / u));d >= c.month && (k[C.hcSetMonth](d >= c.year ? 0 : u * Math.floor(k[C.hcGetMonth]() / u)), x = k[C.hcGetFullYear]());if (d >= c.year) k[C.hcSetFullYear](x - x % u);if (d === c.week) k[C.hcSetDate](k[C.hcGetDate]() - k[C.hcGetDay]() + f(t, 1));x = k[C.hcGetFullYear]();t = k[C.hcGetMonth]();var y = k[C.hcGetDate](),
	            J = k[C.hcGetHours]();if (C.hcTimezoneOffset || C.hcGetTimezoneOffset) m = (!p || !!C.hcGetTimezoneOffset) && (b - z > 4 * c.month || q(z) !== q(b)), k = k.getTime(), k = new C(k + q(k));p = k.getTime();for (z = 1; p < b;) {
	          h.push(p), p = d === c.year ? F(x + z * u, 0) : d === c.month ? F(x, t + z * u) : !m || d !== c.day && d !== c.week ? m && d === c.hour ? F(x, t, y, J + z * u) : p + d * u : F(x, t, y + z * u * (d === c.day ? 1 : 7)), z++;
	        }h.push(p);d <= c.hour && 1E4 > h.length && l(h, function (a) {
	          0 === a % 18E5 && "000000000" === G("%H%M%S%L", a) && (e[a] = "day");
	        });
	      }h.info = r(a, { higherRanks: e, totalRange: d * u });return h;
	    };D.prototype.normalizeTimeTickInterval = function (a, f) {
	      var b = f || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];f = b[b.length - 1];var t = c[f[0]],
	          h = f[1],
	          e;for (e = 0; e < b.length && !(f = b[e], t = c[f[0]], h = f[1], b[e + 1] && a <= (t * h[h.length - 1] + c[b[e + 1][0]]) / 2); e++) {}t === c.year && a < 5 * t && (h = [1, 2, 5]);a = n(a / t, h, "year" === f[0] ? Math.max(w(a / t), 1) : 1);return { unitRange: t, count: a, unitName: f[0] };
	    };
	  })(K);(function (a) {
	    var D = a.Axis,
	        C = a.getMagnitude,
	        G = a.map,
	        H = a.normalizeTickInterval,
	        v = a.pick;D.prototype.getLogTickPositions = function (a, r, w, q) {
	      var n = this.options,
	          f = this.len,
	          c = this.lin2log,
	          e = this.log2lin,
	          z = [];q || (this._minorAutoInterval = null);if (.5 <= a) a = Math.round(a), z = this.getLinearTickPositions(a, r, w);else if (.08 <= a) for (var f = Math.floor(r), b, t, h, B, p, n = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; f < w + 1 && !p; f++) {
	        for (t = n.length, b = 0; b < t && !p; b++) {
	          h = e(c(f) * n[b]), h > r && (!q || B <= w) && void 0 !== B && z.push(B), B > w && (p = !0), B = h;
	        }
	      } else r = c(r), w = c(w), a = n[q ? "minorTickInterval" : "tickInterval"], a = v("auto" === a ? null : a, this._minorAutoInterval, n.tickPixelInterval / (q ? 5 : 1) * (w - r) / ((q ? f / this.tickPositions.length : f) || 1)), a = H(a, null, C(a)), z = G(this.getLinearTickPositions(a, r, w), e), q || (this._minorAutoInterval = a / 5);q || (this.tickInterval = a);return z;
	    };D.prototype.log2lin = function (a) {
	      return Math.log(a) / Math.LN10;
	    };D.prototype.lin2log = function (a) {
	      return Math.pow(10, a);
	    };
	  })(K);(function (a) {
	    var D = a.dateFormat,
	        C = a.each,
	        G = a.extend,
	        H = a.format,
	        v = a.isNumber,
	        l = a.map,
	        r = a.merge,
	        w = a.pick,
	        q = a.splat,
	        n = a.syncTimeout,
	        f = a.timeUnits;a.Tooltip = function () {
	      this.init.apply(this, arguments);
	    };a.Tooltip.prototype = { init: function init(a, e) {
	        this.chart = a;this.options = e;this.crosshairs = [];this.now = { x: 0, y: 0 };this.isHidden = !0;this.split = e.split && !a.inverted;this.shared = e.shared || this.split;
	      }, cleanSplit: function cleanSplit(a) {
	        C(this.chart.series, function (c) {
	          var e = c && c.tt;e && (!e.isActive || a ? c.tt = e.destroy() : e.isActive = !1);
	        });
	      }, getLabel: function getLabel() {
	        var a = this.chart.renderer,
	            e = this.options;this.label || (this.split ? this.label = a.g("tooltip") : (this.label = a.label("", 0, 0, e.shape || "callout", null, null, e.useHTML, null, "tooltip").attr({ padding: e.padding, r: e.borderRadius }), this.label.attr({ fill: e.backgroundColor, "stroke-width": e.borderWidth }).css(e.style).shadow(e.shadow)), this.label.attr({ zIndex: 8 }).add());return this.label;
	      }, update: function update(a) {
	        this.destroy();this.init(this.chart, r(!0, this.options, a));
	      }, destroy: function destroy() {
	        this.label && (this.label = this.label.destroy());this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());clearTimeout(this.hideTimer);clearTimeout(this.tooltipTimeout);
	      },
	      move: function move(a, e, f, b) {
	        var c = this,
	            h = c.now,
	            B = !1 !== c.options.animation && !c.isHidden && (1 < Math.abs(a - h.x) || 1 < Math.abs(e - h.y)),
	            p = c.followPointer || 1 < c.len;G(h, { x: B ? (2 * h.x + a) / 3 : a, y: B ? (h.y + e) / 2 : e, anchorX: p ? void 0 : B ? (2 * h.anchorX + f) / 3 : f, anchorY: p ? void 0 : B ? (h.anchorY + b) / 2 : b });c.getLabel().attr(h);B && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
	          c && c.move(a, e, f, b);
	        }, 32));
	      }, hide: function hide(a) {
	        var c = this;clearTimeout(this.hideTimer);a = w(a, this.options.hideDelay, 500);this.isHidden || (this.hideTimer = n(function () {
	          c.getLabel()[a ? "fadeOut" : "hide"]();c.isHidden = !0;
	        }, a));
	      }, getAnchor: function getAnchor(a, e) {
	        var c,
	            b = this.chart,
	            t = b.inverted,
	            h = b.plotTop,
	            f = b.plotLeft,
	            p = 0,
	            x = 0,
	            k,
	            F;a = q(a);c = a[0].tooltipPos;this.followPointer && e && (void 0 === e.chartX && (e = b.pointer.normalize(e)), c = [e.chartX - b.plotLeft, e.chartY - h]);c || (C(a, function (a) {
	          k = a.series.yAxis;F = a.series.xAxis;p += a.plotX + (!t && F ? F.left - f : 0);x += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!t && k ? k.top - h : 0);
	        }), p /= a.length, x /= a.length, c = [t ? b.plotWidth - x : p, this.shared && !t && 1 < a.length && e ? e.chartY - h : t ? b.plotHeight - p : x]);return l(c, Math.round);
	      }, getPosition: function getPosition(a, e, f) {
	        var b = this.chart,
	            c = this.distance,
	            h = {},
	            B = f.h || 0,
	            p,
	            x = ["y", b.chartHeight, e, f.plotY + b.plotTop, b.plotTop, b.plotTop + b.plotHeight],
	            k = ["x", b.chartWidth, a, f.plotX + b.plotLeft, b.plotLeft, b.plotLeft + b.plotWidth],
	            F = !this.followPointer && w(f.ttBelow, !b.inverted === !!f.negative),
	            d = function d(a, b, _d, g, m, k) {
	          var p = _d < g - c,
	              y = g + c + _d < b,
	              E = g - c - _d;g += c;if (F && y) h[a] = g;else if (!F && p) h[a] = E;else if (p) h[a] = Math.min(k - _d, 0 > E - B ? E : E - B);else if (y) h[a] = Math.max(m, g + B + _d > b ? g : g + B);else return !1;
	        },
	            u = function u(a, b, d, g) {
	          var m;g < c || g > b - c ? m = !1 : h[a] = g < d / 2 ? 1 : g > b - d / 2 ? b - d - 2 : g - d / 2;return m;
	        },
	            m = function m(a) {
	          var b = x;x = k;k = b;p = a;
	        },
	            y = function y() {
	          !1 !== d.apply(0, x) ? !1 !== u.apply(0, k) || p || (m(!0), y()) : p ? h.x = h.y = 0 : (m(!0), y());
	        };(b.inverted || 1 < this.len) && m();y();return h;
	      }, defaultFormatter: function defaultFormatter(a) {
	        var c = this.points || q(this),
	            f;f = [a.tooltipFooterHeaderFormatter(c[0])];f = f.concat(a.bodyFormatter(c));f.push(a.tooltipFooterHeaderFormatter(c[0], !0));return f;
	      }, refresh: function refresh(a, e) {
	        var c,
	            b = this.options,
	            t,
	            h = a,
	            f,
	            p = {},
	            x = [];c = b.formatter || this.defaultFormatter;var p = this.shared,
	            k;clearTimeout(this.hideTimer);this.followPointer = q(h)[0].series.tooltipOptions.followPointer;f = this.getAnchor(h, e);e = f[0];t = f[1];!p || h.series && h.series.noSharedTooltip ? p = h.getLabelConfig() : (C(h, function (a) {
	          a.setState("hover");x.push(a.getLabelConfig());
	        }), p = { x: h[0].category, y: h[0].y }, p.points = x, h = h[0]);this.len = x.length;p = c.call(p, this);k = h.series;this.distance = w(k.tooltipOptions.distance, 16);!1 === p ? this.hide() : (c = this.getLabel(), this.isHidden && c.attr({ opacity: 1 }).show(), this.split ? this.renderSplit(p, a) : (c.attr({ text: p && p.join ? p.join("") : p }), c.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + w(h.colorIndex, k.colorIndex)), c.attr({ stroke: b.borderColor || h.color || k.color || "#666666" }), this.updatePosition({ plotX: e, plotY: t, negative: h.negative, ttBelow: h.ttBelow, h: f[2] || 0 })), this.isHidden = !1);
	      }, renderSplit: function renderSplit(c, e) {
	        var f = this,
	            b = [],
	            t = this.chart,
	            h = t.renderer,
	            B = !0,
	            p = this.options,
	            x,
	            k = this.getLabel();
	        C(c.slice(0, e.length + 1), function (a, d) {
	          d = e[d - 1] || { isHeader: !0, plotX: e[0].plotX };var c = d.series || f,
	              m = c.tt,
	              y = d.series || {},
	              F = "highcharts-color-" + w(d.colorIndex, y.colorIndex, "none");m || (c.tt = m = h.label(null, null, null, "callout").addClass("highcharts-tooltip-box " + F).attr({ padding: p.padding, r: p.borderRadius, fill: p.backgroundColor, stroke: d.color || y.color || "#333333", "stroke-width": p.borderWidth }).add(k));m.isActive = !0;m.attr({ text: a });m.css(p.style);a = m.getBBox();y = a.width + m.strokeWidth();d.isHeader ? (x = a.height, y = Math.max(0, Math.min(d.plotX + t.plotLeft - y / 2, t.chartWidth - y))) : y = d.plotX + t.plotLeft - w(p.distance, 16) - y;0 > y && (B = !1);a = (d.series && d.series.yAxis && d.series.yAxis.pos) + (d.plotY || 0);a -= t.plotTop;b.push({ target: d.isHeader ? t.plotHeight + x : a, rank: d.isHeader ? 1 : 0, size: c.tt.getBBox().height + 1, point: d, x: y, tt: m });
	        });this.cleanSplit();a.distribute(b, t.plotHeight + x);C(b, function (a) {
	          var b = a.point,
	              c = b.series;a.tt.attr({ visibility: void 0 === a.pos ? "hidden" : "inherit", x: B || b.isHeader ? a.x : b.plotX + t.plotLeft + w(p.distance, 16), y: a.pos + t.plotTop, anchorX: b.isHeader ? b.plotX + t.plotLeft : b.plotX + c.xAxis.pos, anchorY: b.isHeader ? a.pos + t.plotTop - 15 : b.plotY + c.yAxis.pos });
	        });
	      }, updatePosition: function updatePosition(a) {
	        var c = this.chart,
	            f = this.getLabel(),
	            f = (this.options.positioner || this.getPosition).call(this, f.width, f.height, a);this.move(Math.round(f.x), Math.round(f.y || 0), a.plotX + c.plotLeft, a.plotY + c.plotTop);
	      }, getDateFormat: function getDateFormat(a, e, z, b) {
	        var c = D("%m-%d %H:%M:%S.%L", e),
	            h,
	            B,
	            p = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 },
	            x = "millisecond";for (B in f) {
	          if (a === f.week && +D("%w", e) === z && "00:00:00.000" === c.substr(6)) {
	            B = "week";break;
	          }if (f[B] > a) {
	            B = x;break;
	          }if (p[B] && c.substr(p[B]) !== "01-01 00:00:00.000".substr(p[B])) break;"week" !== B && (x = B);
	        }B && (h = b[B]);return h;
	      }, getXDateFormat: function getXDateFormat(a, e, f) {
	        e = e.dateTimeLabelFormats;var b = f && f.closestPointRange;return (b ? this.getDateFormat(b, a.x, f.options.startOfWeek, e) : e.day) || e.year;
	      }, tooltipFooterHeaderFormatter: function tooltipFooterHeaderFormatter(a, e) {
	        var c = e ? "footer" : "header";e = a.series;var b = e.tooltipOptions,
	            t = b.xDateFormat,
	            h = e.xAxis,
	            f = h && "datetime" === h.options.type && v(a.key),
	            c = b[c + "Format"];f && !t && (t = this.getXDateFormat(a, b, h));f && t && (c = c.replace("{point.key}", "{point.key:" + t + "}"));return H(c, { point: a, series: e });
	      }, bodyFormatter: function bodyFormatter(a) {
	        return l(a, function (a) {
	          var c = a.series.tooltipOptions;return (c.pointFormatter || a.point.tooltipFormatter).call(a.point, c.pointFormat);
	        });
	      } };
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.attr,
	        G = a.charts,
	        H = a.color,
	        v = a.css,
	        l = a.defined,
	        r = a.doc,
	        w = a.each,
	        q = a.extend,
	        n = a.fireEvent,
	        f = a.offset,
	        c = a.pick,
	        e = a.removeEvent,
	        z = a.splat,
	        b = a.Tooltip,
	        t = a.win;a.Pointer = function (a, b) {
	      this.init(a, b);
	    };a.Pointer.prototype = { init: function init(a, t) {
	        this.options = t;this.chart = a;this.runChartClick = t.chart.events && !!t.chart.events.click;this.pinchDown = [];this.lastValidTouch = {};b && t.tooltip.enabled && (a.tooltip = new b(a, t.tooltip), this.followTouchMove = c(t.tooltip.followTouchMove, !0));this.setDOMEvents();
	      }, zoomOption: function zoomOption(a) {
	        var b = this.chart,
	            h = b.options.chart,
	            x = h.zoomType || "",
	            b = b.inverted;/touch/.test(a.type) && (x = c(h.pinchType, x));this.zoomX = a = /x/.test(x);
	        this.zoomY = x = /y/.test(x);this.zoomHor = a && !b || x && b;this.zoomVert = x && !b || a && b;this.hasZoom = a || x;
	      }, normalize: function normalize(a, b) {
	        var c, h;a = a || t.event;a.target || (a.target = a.srcElement);h = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a;b || (this.chartPosition = b = f(this.chart.container));void 0 === h.pageX ? (c = Math.max(a.x, a.clientX - b.left), b = a.y) : (c = h.pageX - b.left, b = h.pageY - b.top);return q(a, { chartX: Math.round(c), chartY: Math.round(b) });
	      }, getCoordinates: function getCoordinates(a) {
	        var b = { xAxis: [], yAxis: [] };w(this.chart.axes, function (c) {
	          b[c.isXAxis ? "xAxis" : "yAxis"].push({ axis: c, value: c.toValue(a[c.horiz ? "chartX" : "chartY"]) });
	        });return b;
	      }, getKDPoints: function getKDPoints(a, b, p) {
	        var h = [],
	            k,
	            t,
	            d;w(a, function (a) {
	          k = a.noSharedTooltip && b;t = !b && a.directTouch;a.visible && !t && c(a.options.enableMouseTracking, !0) && (d = a.searchPoint(p, !k && 0 > a.options.findNearestPointBy.indexOf("y"))) && d.series && h.push(d);
	        });h.sort(function (a, d) {
	          var c = a.distX - d.distX,
	              m = a.dist - d.dist,
	              h = (d.series.group && d.series.group.zIndex) - (a.series.group && a.series.group.zIndex);
	          return 0 !== c && b ? c : 0 !== m ? m : 0 !== h ? h : a.series.index > d.series.index ? -1 : 1;
	        });if (b && h[0] && !h[0].series.noSharedTooltip) for (a = h.length; a--;) {
	          (h[a].x !== h[0].x || h[a].series.noSharedTooltip) && h.splice(a, 1);
	        }return h;
	      }, getPointFromEvent: function getPointFromEvent(a) {
	        a = a.target;for (var b; a && !b;) {
	          b = a.point, a = a.parentNode;
	        }return b;
	      }, getHoverData: function getHoverData(b, t, p, x, k, e) {
	        var d = b,
	            h = t,
	            m;x ? k ? (m = [], w(p, function (a) {
	          var b = a.noSharedTooltip && k,
	              h = !k && a.directTouch;a.visible && !b && !h && c(a.options.enableMouseTracking, !0) && (a = a.searchKDTree({ clientX: d.clientX,
	            plotY: d.plotY }, !b && 1 === a.kdDimensions)) && a.series && m.push(a);
	        }), 0 === m.length && (m = [d])) : m = [d] : h && !h.stickyTracking ? (k || (p = [h]), m = this.getKDPoints(p, k, e), d = a.find(m, function (a) {
	          return a.series === h;
	        })) : (b = a.grep(p, function (a) {
	          return a.stickyTracking;
	        }), m = this.getKDPoints(b, k, e), h = (d = m[0]) && d.series, k && (m = this.getKDPoints(p, k, e)));m.sort(function (a, b) {
	          return a.series.index - b.series.index;
	        });return { hoverPoint: d, hoverSeries: h, hoverPoints: m };
	      }, runPointActions: function runPointActions(b, t) {
	        var h = this.chart,
	            x = h.tooltip,
	            k = x ? x.shared : !1,
	            e = t || h.hoverPoint,
	            d = e && e.series || h.hoverSeries;t = this.getHoverData(e, d, h.series, !!t || !k && d && d.directTouch, k, b);var f,
	            m,
	            e = t.hoverPoint;f = (d = t.hoverSeries) && d.tooltipOptions.followPointer;m = (k = k && e && !e.series.noSharedTooltip) ? t.hoverPoints : e ? [e] : [];if (e && (e !== h.hoverPoint || x && x.isHidden)) {
	          w(h.hoverPoints || [], function (b) {
	            -1 === a.inArray(b, m) && b.setState();
	          });w(m || [], function (a) {
	            a.setState("hover");
	          });if (h.hoverSeries !== d) d.onMouseOver();d && !d.directTouch && (h.hoverPoint && h.hoverPoint.firePointEvent("mouseOut"), e.firePointEvent("mouseOver"));h.hoverPoints = m;h.hoverPoint = e;x && x.refresh(k ? m : e, b);
	        } else f && x && !x.isHidden && (e = x.getAnchor([{}], b), x.updatePosition({ plotX: e[0], plotY: e[1] }));this.unDocMouseMove || (this.unDocMouseMove = D(r, "mousemove", function (b) {
	          var d = G[a.hoverChartIndex];if (d) d.pointer.onDocumentMouseMove(b);
	        }));w(h.axes, function (a) {
	          c(a.crosshair.snap, !0) ? w(m, function (d) {
	            d.series[a.coll] === a && a.drawCrosshair(b, d);
	          }) : a.drawCrosshair(b);
	        });
	      }, reset: function reset(a, b) {
	        var c = this.chart,
	            h = c.hoverSeries,
	            k = c.hoverPoint,
	            t = c.hoverPoints,
	            d = c.tooltip,
	            e = d && d.shared ? t : k;a && e && w(z(e), function (b) {
	          b.series.isCartesian && void 0 === b.plotX && (a = !1);
	        });if (a) d && e && (d.refresh(e), k && (k.setState(k.state, !0), w(c.axes, function (a) {
	          a.crosshair && a.drawCrosshair(null, k);
	        })));else {
	          if (k) k.onMouseOut();t && w(t, function (a) {
	            a.setState();
	          });if (h) h.onMouseOut();d && d.hide(b);this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());w(c.axes, function (a) {
	            a.hideCrosshair();
	          });this.hoverX = c.hoverPoints = c.hoverPoint = null;
	        }
	      }, scaleGroups: function scaleGroups(a, b) {
	        var c = this.chart,
	            h;w(c.series, function (k) {
	          h = a || k.getPlotBox();k.xAxis && k.xAxis.zoomEnabled && k.group && (k.group.attr(h), k.markerGroup && (k.markerGroup.attr(h), k.markerGroup.clip(b ? c.clipRect : null)), k.dataLabelsGroup && k.dataLabelsGroup.attr(h));
	        });c.clipRect.attr(b || c.clipBox);
	      }, dragStart: function dragStart(a) {
	        var b = this.chart;b.mouseIsDown = a.type;b.cancelClick = !1;b.mouseDownX = this.mouseDownX = a.chartX;b.mouseDownY = this.mouseDownY = a.chartY;
	      }, drag: function drag(a) {
	        var b = this.chart,
	            c = b.options.chart,
	            h = a.chartX,
	            k = a.chartY,
	            t = this.zoomHor,
	            d = this.zoomVert,
	            e = b.plotLeft,
	            m = b.plotTop,
	            y = b.plotWidth,
	            f = b.plotHeight,
	            E,
	            I = this.selectionMarker,
	            g = this.mouseDownX,
	            n = this.mouseDownY,
	            z = c.panKey && a[c.panKey + "Key"];I && I.touch || (h < e ? h = e : h > e + y && (h = e + y), k < m ? k = m : k > m + f && (k = m + f), this.hasDragged = Math.sqrt(Math.pow(g - h, 2) + Math.pow(n - k, 2)), 10 < this.hasDragged && (E = b.isInsidePlot(g - e, n - m), b.hasCartesianSeries && (this.zoomX || this.zoomY) && E && !z && !I && (this.selectionMarker = I = b.renderer.rect(e, m, t ? 1 : y, d ? 1 : f, 0).attr({ fill: c.selectionMarkerFill || H("#335cad").setOpacity(.25).get(),
	          "class": "highcharts-selection-marker", zIndex: 7 }).add()), I && t && (h -= g, I.attr({ width: Math.abs(h), x: (0 < h ? 0 : h) + g })), I && d && (h = k - n, I.attr({ height: Math.abs(h), y: (0 < h ? 0 : h) + n })), E && !I && c.panning && b.pan(a, c.panning)));
	      }, drop: function drop(a) {
	        var b = this,
	            c = this.chart,
	            h = this.hasPinched;if (this.selectionMarker) {
	          var k = { originalEvent: a, xAxis: [], yAxis: [] },
	              t = this.selectionMarker,
	              d = t.attr ? t.attr("x") : t.x,
	              e = t.attr ? t.attr("y") : t.y,
	              m = t.attr ? t.attr("width") : t.width,
	              y = t.attr ? t.attr("height") : t.height,
	              f;if (this.hasDragged || h) w(c.axes, function (c) {
	            if (c.zoomEnabled && l(c.min) && (h || b[{ xAxis: "zoomX", yAxis: "zoomY" }[c.coll]])) {
	              var p = c.horiz,
	                  g = "touchend" === a.type ? c.minPixelPadding : 0,
	                  t = c.toValue((p ? d : e) + g),
	                  p = c.toValue((p ? d + m : e + y) - g);k[c.coll].push({ axis: c, min: Math.min(t, p), max: Math.max(t, p) });f = !0;
	            }
	          }), f && n(c, "selection", k, function (a) {
	            c.zoom(q(a, h ? { animation: !1 } : null));
	          });this.selectionMarker = this.selectionMarker.destroy();h && this.scaleGroups();
	        }c && (v(c.container, { cursor: c._cursor }), c.cancelClick = 10 < this.hasDragged, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);
	      }, onContainerMouseDown: function onContainerMouseDown(a) {
	        a = this.normalize(a);this.zoomOption(a);a.preventDefault && a.preventDefault();this.dragStart(a);
	      }, onDocumentMouseUp: function onDocumentMouseUp(b) {
	        G[a.hoverChartIndex] && G[a.hoverChartIndex].pointer.drop(b);
	      }, onDocumentMouseMove: function onDocumentMouseMove(a) {
	        var b = this.chart,
	            c = this.chartPosition;a = this.normalize(a, c);!c || this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset();
	      }, onContainerMouseLeave: function onContainerMouseLeave(b) {
	        var c = G[a.hoverChartIndex];c && (b.relatedTarget || b.toElement) && (c.pointer.reset(), c.pointer.chartPosition = null);
	      }, onContainerMouseMove: function onContainerMouseMove(b) {
	        var c = this.chart;l(a.hoverChartIndex) && G[a.hoverChartIndex] && G[a.hoverChartIndex].mouseIsDown || (a.hoverChartIndex = c.index);b = this.normalize(b);b.returnValue = !1;"mousedown" === c.mouseIsDown && this.drag(b);!this.inClass(b.target, "highcharts-tracker") && !c.isInsidePlot(b.chartX - c.plotLeft, b.chartY - c.plotTop) || c.openMenu || this.runPointActions(b);
	      }, inClass: function inClass(a, b) {
	        for (var c; a;) {
	          if (c = C(a, "class")) {
	            if (-1 !== c.indexOf(b)) return !0;if (-1 !== c.indexOf("highcharts-container")) return !1;
	          }a = a.parentNode;
	        }
	      }, onTrackerMouseOut: function onTrackerMouseOut(a) {
	        var b = this.chart.hoverSeries;a = a.relatedTarget || a.toElement;if (!(!b || !a || b.stickyTracking || this.inClass(a, "highcharts-tooltip") || this.inClass(a, "highcharts-series-" + b.index) && this.inClass(a, "highcharts-tracker"))) b.onMouseOut();
	      }, onContainerClick: function onContainerClick(a) {
	        var b = this.chart,
	            c = b.hoverPoint,
	            h = b.plotLeft,
	            k = b.plotTop;a = this.normalize(a);b.cancelClick || (c && this.inClass(a.target, "highcharts-tracker") ? (n(c.series, "click", q(a, { point: c })), b.hoverPoint && c.firePointEvent("click", a)) : (q(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - h, a.chartY - k) && n(b, "click", a)));
	      }, setDOMEvents: function setDOMEvents() {
	        var b = this,
	            c = b.chart.container;c.onmousedown = function (a) {
	          b.onContainerMouseDown(a);
	        };c.onmousemove = function (a) {
	          b.onContainerMouseMove(a);
	        };c.onclick = function (a) {
	          b.onContainerClick(a);
	        };D(c, "mouseleave", b.onContainerMouseLeave);1 === a.chartCount && D(r, "mouseup", b.onDocumentMouseUp);a.hasTouch && (c.ontouchstart = function (a) {
	          b.onContainerTouchStart(a);
	        }, c.ontouchmove = function (a) {
	          b.onContainerTouchMove(a);
	        }, 1 === a.chartCount && D(r, "touchend", b.onDocumentTouchEnd));
	      }, destroy: function destroy() {
	        var b;this.unDocMouseMove && this.unDocMouseMove();e(this.chart.container, "mouseleave", this.onContainerMouseLeave);a.chartCount || (e(r, "mouseup", this.onDocumentMouseUp), e(r, "touchend", this.onDocumentTouchEnd));clearInterval(this.tooltipTimeout);for (b in this) {
	          this[b] = null;
	        }
	      } };
	  })(K);(function (a) {
	    var D = a.charts,
	        C = a.each,
	        G = a.extend,
	        H = a.map,
	        v = a.noop,
	        l = a.pick;G(a.Pointer.prototype, { pinchTranslate: function pinchTranslate(a, l, q, n, f, c) {
	        this.zoomHor && this.pinchTranslateDirection(!0, a, l, q, n, f, c);this.zoomVert && this.pinchTranslateDirection(!1, a, l, q, n, f, c);
	      }, pinchTranslateDirection: function pinchTranslateDirection(a, l, q, n, f, c, e, z) {
	        var b = this.chart,
	            t = a ? "x" : "y",
	            h = a ? "X" : "Y",
	            B = "chart" + h,
	            p = a ? "width" : "height",
	            x = b["plot" + (a ? "Left" : "Top")],
	            k,
	            F,
	            d = z || 1,
	            u = b.inverted,
	            m = b.bounds[a ? "h" : "v"],
	            y = 1 === l.length,
	            J = l[0][B],
	            E = q[0][B],
	            I = !y && l[1][B],
	            g = !y && q[1][B],
	            r;q = function q() {
	          !y && 20 < Math.abs(J - I) && (d = z || Math.abs(E - g) / Math.abs(J - I));F = (x - E) / d + J;k = b["plot" + (a ? "Width" : "Height")] / d;
	        };q();l = F;l < m.min ? (l = m.min, r = !0) : l + k > m.max && (l = m.max - k, r = !0);r ? (E -= .8 * (E - e[t][0]), y || (g -= .8 * (g - e[t][1])), q()) : e[t] = [E, g];u || (c[t] = F - x, c[p] = k);c = u ? 1 / d : d;f[p] = k;f[t] = l;n[u ? a ? "scaleY" : "scaleX" : "scale" + h] = d;n["translate" + h] = c * x + (E - c * J);
	      }, pinch: function pinch(a) {
	        var r = this,
	            q = r.chart,
	            n = r.pinchDown,
	            f = a.touches,
	            c = f.length,
	            e = r.lastValidTouch,
	            z = r.hasZoom,
	            b = r.selectionMarker,
	            t = {},
	            h = 1 === c && (r.inClass(a.target, "highcharts-tracker") && q.runTrackerClick || r.runChartClick),
	            B = {};1 < c && (r.initiated = !0);z && r.initiated && !h && a.preventDefault();H(f, function (a) {
	          return r.normalize(a);
	        });"touchstart" === a.type ? (C(f, function (a, b) {
	          n[b] = { chartX: a.chartX, chartY: a.chartY };
	        }), e.x = [n[0].chartX, n[1] && n[1].chartX], e.y = [n[0].chartY, n[1] && n[1].chartY], C(q.axes, function (a) {
	          if (a.zoomEnabled) {
	            var b = q.bounds[a.horiz ? "h" : "v"],
	                c = a.minPixelPadding,
	                h = a.toPixels(l(a.options.min, a.dataMin)),
	                d = a.toPixels(l(a.options.max, a.dataMax)),
	                t = Math.max(h, d);b.min = Math.min(a.pos, Math.min(h, d) - c);b.max = Math.max(a.pos + a.len, t + c);
	          }
	        }), r.res = !0) : r.followTouchMove && 1 === c ? this.runPointActions(r.normalize(a)) : n.length && (b || (r.selectionMarker = b = G({ destroy: v, touch: !0 }, q.plotBox)), r.pinchTranslate(n, f, t, b, B, e), r.hasPinched = z, r.scaleGroups(t, B), r.res && (r.res = !1, this.reset(!1, 0)));
	      }, touch: function touch(r, v) {
	        var q = this.chart,
	            n,
	            f;if (q.index !== a.hoverChartIndex) this.onContainerMouseLeave({ relatedTarget: !0 });a.hoverChartIndex = q.index;1 === r.touches.length ? (r = this.normalize(r), (f = q.isInsidePlot(r.chartX - q.plotLeft, r.chartY - q.plotTop)) && !q.openMenu ? (v && this.runPointActions(r), "touchmove" === r.type && (v = this.pinchDown, n = v[0] ? 4 <= Math.sqrt(Math.pow(v[0].chartX - r.chartX, 2) + Math.pow(v[0].chartY - r.chartY, 2)) : !1), l(n, !0) && this.pinch(r)) : v && this.reset()) : 2 === r.touches.length && this.pinch(r);
	      }, onContainerTouchStart: function onContainerTouchStart(a) {
	        this.zoomOption(a);this.touch(a, !0);
	      }, onContainerTouchMove: function onContainerTouchMove(a) {
	        this.touch(a);
	      }, onDocumentTouchEnd: function onDocumentTouchEnd(l) {
	        D[a.hoverChartIndex] && D[a.hoverChartIndex].pointer.drop(l);
	      } });
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.charts,
	        G = a.css,
	        H = a.doc,
	        v = a.extend,
	        l = a.noop,
	        r = a.Pointer,
	        w = a.removeEvent,
	        q = a.win,
	        n = a.wrap;if (q.PointerEvent || q.MSPointerEvent) {
	      var f = {},
	          c = !!q.PointerEvent,
	          e = function e() {
	        var a,
	            c = [];c.item = function (a) {
	          return this[a];
	        };for (a in f) {
	          f.hasOwnProperty(a) && c.push({ pageX: f[a].pageX, pageY: f[a].pageY, target: f[a].target });
	        }return c;
	      },
	          z = function z(b, c, h, f) {
	        "touch" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !C[a.hoverChartIndex] || (f(b), f = C[a.hoverChartIndex].pointer, f[c]({ type: h, target: b.currentTarget,
	          preventDefault: l, touches: e() }));
	      };v(r.prototype, { onContainerPointerDown: function onContainerPointerDown(a) {
	          z(a, "onContainerTouchStart", "touchstart", function (a) {
	            f[a.pointerId] = { pageX: a.pageX, pageY: a.pageY, target: a.currentTarget };
	          });
	        }, onContainerPointerMove: function onContainerPointerMove(a) {
	          z(a, "onContainerTouchMove", "touchmove", function (a) {
	            f[a.pointerId] = { pageX: a.pageX, pageY: a.pageY };f[a.pointerId].target || (f[a.pointerId].target = a.currentTarget);
	          });
	        }, onDocumentPointerUp: function onDocumentPointerUp(a) {
	          z(a, "onDocumentTouchEnd", "touchend", function (a) {
	            delete f[a.pointerId];
	          });
	        },
	        batchMSEvents: function batchMSEvents(a) {
	          a(this.chart.container, c ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);a(this.chart.container, c ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);a(H, c ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
	        } });n(r.prototype, "init", function (a, c, h) {
	        a.call(this, c, h);this.hasZoom && G(c.container, { "-ms-touch-action": "none", "touch-action": "none" });
	      });n(r.prototype, "setDOMEvents", function (a) {
	        a.apply(this);(this.hasZoom || this.followTouchMove) && this.batchMSEvents(D);
	      });
	      n(r.prototype, "destroy", function (a) {
	        this.batchMSEvents(w);a.call(this);
	      });
	    }
	  })(K);(function (a) {
	    var D,
	        C = a.addEvent,
	        G = a.css,
	        H = a.discardElement,
	        v = a.defined,
	        l = a.each,
	        r = a.isFirefox,
	        w = a.marginNames,
	        q = a.merge,
	        n = a.pick,
	        f = a.setAnimation,
	        c = a.stableSort,
	        e = a.win,
	        z = a.wrap;D = a.Legend = function (a, c) {
	      this.init(a, c);
	    };D.prototype = { init: function init(a, c) {
	        this.chart = a;this.setOptions(c);c.enabled && (this.render(), C(this.chart, "endResize", function () {
	          this.legend.positionCheckboxes();
	        }));
	      }, setOptions: function setOptions(a) {
	        var b = n(a.padding, 8);this.options = a;this.itemStyle = a.itemStyle;this.itemHiddenStyle = q(this.itemStyle, a.itemHiddenStyle);this.itemMarginTop = a.itemMarginTop || 0;this.padding = b;this.initialItemY = b - 5;this.itemHeight = this.maxItemWidth = 0;this.symbolWidth = n(a.symbolWidth, 16);this.pages = [];
	      }, update: function update(a, c) {
	        var b = this.chart;this.setOptions(q(!0, this.options, a));this.destroy();b.isDirtyLegend = b.isDirtyBox = !0;n(c, !0) && b.redraw();
	      }, colorizeItem: function colorizeItem(a, c) {
	        a.legendGroup[c ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
	        var b = this.options,
	            e = a.legendItem,
	            p = a.legendLine,
	            t = a.legendSymbol,
	            k = this.itemHiddenStyle.color,
	            b = c ? b.itemStyle.color : k,
	            f = c ? a.color || k : k,
	            d = a.options && a.options.marker,
	            u = { fill: f },
	            m;e && e.css({ fill: b, color: b });p && p.attr({ stroke: f });if (t) {
	          if (d && t.isMarker && (u = a.pointAttribs(), !c)) for (m in u) {
	            u[m] = k;
	          }t.attr(u);
	        }
	      }, positionItem: function positionItem(a) {
	        var b = this.options,
	            c = b.symbolPadding,
	            b = !b.rtl,
	            e = a._legendItemPos,
	            p = e[0],
	            e = e[1],
	            f = a.checkbox;(a = a.legendGroup) && a.element && a.translate(b ? p : this.legendWidth - p - 2 * c - 4, e);f && (f.x = p, f.y = e);
	      }, destroyItem: function destroyItem(a) {
	        var b = a.checkbox;l(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (b) {
	          a[b] && (a[b] = a[b].destroy());
	        });b && H(a.checkbox);
	      }, destroy: function destroy() {
	        function a(a) {
	          this[a] && (this[a] = this[a].destroy());
	        }l(this.getAllItems(), function (b) {
	          l(["legendItem", "legendGroup"], a, b);
	        });l("clipRect up down pager nav box title group".split(" "), a, this);this.display = null;
	      }, positionCheckboxes: function positionCheckboxes(a) {
	        var b = this.group && this.group.alignAttr,
	            c,
	            e = this.clipHeight || this.legendHeight,
	            p = this.titleHeight;b && (c = b.translateY, l(this.allItems, function (h) {
	          var k = h.checkbox,
	              t;k && (t = c + p + k.y + (a || 0) + 3, G(k, { left: b.translateX + h.checkboxOffset + k.x - 20 + "px", top: t + "px", display: t > c - 6 && t < c + e - 6 ? "" : "none" }));
	        }));
	      }, renderTitle: function renderTitle() {
	        var a = this.padding,
	            c = this.options.title,
	            h = 0;c.text && (this.title || (this.title = this.chart.renderer.label(c.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({ zIndex: 1 }).css(c.style).add(this.group)), a = this.title.getBBox(), h = a.height, this.offsetWidth = a.width, this.contentGroup.attr({ translateY: h }));
	        this.titleHeight = h;
	      }, setText: function setText(b) {
	        var c = this.options;b.legendItem.attr({ text: c.labelFormat ? a.format(c.labelFormat, b) : c.labelFormatter.call(b) });
	      }, renderItem: function renderItem(a) {
	        var b = this.chart,
	            c = b.renderer,
	            e = this.options,
	            p = "horizontal" === e.layout,
	            f = this.symbolWidth,
	            k = e.symbolPadding,
	            l = this.itemStyle,
	            d = this.itemHiddenStyle,
	            u = this.padding,
	            m = p ? n(e.itemDistance, 20) : 0,
	            y = !e.rtl,
	            J = e.width,
	            E = e.itemMarginBottom || 0,
	            I = this.itemMarginTop,
	            g = a.legendItem,
	            z = !a.series,
	            r = !z && a.series.drawLegendSymbol ? a.series : a,
	            v = r.options,
	            v = this.createCheckboxForItem && v && v.showCheckbox,
	            w = e.useHTML,
	            P = a.options.className;g || (a.legendGroup = c.g("legend-item").addClass("highcharts-" + r.type + "-series highcharts-color-" + a.colorIndex + (P ? " " + P : "") + (z ? " highcharts-series-" + a.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), a.legendItem = g = c.text("", y ? f + k : -k, this.baseline || 0, w).css(q(a.visible ? l : d)).attr({ align: y ? "left" : "right", zIndex: 2 }).add(a.legendGroup), this.baseline || (l = l.fontSize, this.fontMetrics = c.fontMetrics(l, g), this.baseline = this.fontMetrics.f + 3 + I, g.attr("y", this.baseline)), this.symbolHeight = e.symbolHeight || this.fontMetrics.f, r.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, g, w), v && this.createCheckboxForItem(a));this.colorizeItem(a, a.visible);this.setText(a);c = g.getBBox();f = a.checkboxOffset = e.itemWidth || a.legendItemWidth || f + k + c.width + m + (v ? 20 : 0);this.itemHeight = k = Math.round(a.legendItemHeight || c.height || this.symbolHeight);p && this.itemX - u + f > (J || b.spacingBox.width - 2 * u - e.x) && (this.itemX = u, this.itemY += I + this.lastLineHeight + E, this.lastLineHeight = 0);this.maxItemWidth = Math.max(this.maxItemWidth, f);this.lastItemY = I + this.itemY + E;this.lastLineHeight = Math.max(k, this.lastLineHeight);a._legendItemPos = [this.itemX, this.itemY];p ? this.itemX += f : (this.itemY += I + k + E, this.lastLineHeight = k);this.offsetWidth = J || Math.max((p ? this.itemX - u - m : f) + u, this.offsetWidth);
	      }, getAllItems: function getAllItems() {
	        var a = [];l(this.chart.series, function (b) {
	          var c = b && b.options;b && n(c.showInLegend, v(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b)));
	        });return a;
	      }, adjustMargins: function adjustMargins(a, c) {
	        var b = this.chart,
	            e = this.options,
	            p = e.align.charAt(0) + e.verticalAlign.charAt(0) + e.layout.charAt(0);e.floating || l([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (h, k) {
	          h.test(p) && !v(a[k]) && (b[w[k]] = Math.max(b[w[k]], b.legend[(k + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][k] * e[k % 2 ? "x" : "y"] + n(e.margin, 12) + c[k]));
	        });
	      }, render: function render() {
	        var a = this,
	            e = a.chart,
	            h = e.renderer,
	            f = a.group,
	            p,
	            x,
	            k,
	            n,
	            d = a.box,
	            u = a.options,
	            m = a.padding;a.itemX = m;a.itemY = a.initialItemY;a.offsetWidth = 0;a.lastItemY = 0;f || (a.group = f = h.g("legend").attr({ zIndex: 7 }).add(), a.contentGroup = h.g().attr({ zIndex: 1 }).add(f), a.scrollGroup = h.g().add(a.contentGroup));a.renderTitle();p = a.getAllItems();c(p, function (a, b) {
	          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
	        });u.reversed && p.reverse();a.allItems = p;a.display = x = !!p.length;a.lastLineHeight = 0;l(p, function (b) {
	          a.renderItem(b);
	        });k = (u.width || a.offsetWidth) + m;n = a.lastItemY + a.lastLineHeight + a.titleHeight;
	        n = a.handleOverflow(n);n += m;d || (a.box = d = h.rect().addClass("highcharts-legend-box").attr({ r: u.borderRadius }).add(f), d.isNew = !0);d.attr({ stroke: u.borderColor, "stroke-width": u.borderWidth || 0, fill: u.backgroundColor || "none" }).shadow(u.shadow);0 < k && 0 < n && (d[d.isNew ? "attr" : "animate"](d.crisp({ x: 0, y: 0, width: k, height: n }, d.strokeWidth())), d.isNew = !1);d[x ? "show" : "hide"]();a.legendWidth = k;a.legendHeight = n;l(p, function (b) {
	          a.positionItem(b);
	        });x && f.align(q(u, { width: k, height: n }), !0, "spacingBox");e.isResizing || this.positionCheckboxes();
	      },
	      handleOverflow: function handleOverflow(a) {
	        var b = this,
	            c = this.chart,
	            e = c.renderer,
	            p = this.options,
	            f = p.y,
	            k = this.padding,
	            c = c.spacingBox.height + ("top" === p.verticalAlign ? -f : f) - k,
	            f = p.maxHeight,
	            z,
	            d = this.clipRect,
	            u = p.navigation,
	            m = n(u.animation, !0),
	            y = u.arrowSize || 12,
	            J = this.nav,
	            E = this.pages,
	            I,
	            g = this.allItems,
	            q = function q(a) {
	          a ? d.attr({ height: a }) : d && (b.clipRect = d.destroy(), b.contentGroup.clip());b.contentGroup.div && (b.contentGroup.div.style.clip = a ? "rect(" + k + "px,9999px," + (k + a) + "px,0)" : "auto");
	        };"horizontal" !== p.layout || "middle" === p.verticalAlign || p.floating || (c /= 2);f && (c = Math.min(c, f));E.length = 0;a > c && !1 !== u.enabled ? (this.clipHeight = z = Math.max(c - 20 - this.titleHeight - k, 0), this.currentPage = n(this.currentPage, 1), this.fullHeight = a, l(g, function (a, b) {
	          var c = a._legendItemPos[1];a = Math.round(a.legendItem.getBBox().height);var d = E.length;if (!d || c - E[d - 1] > z && (I || c) !== E[d - 1]) E.push(I || c), d++;b === g.length - 1 && c + a - E[d - 1] > z && E.push(c);c !== I && (I = c);
	        }), d || (d = b.clipRect = e.clipRect(0, k, 9999, 0), b.contentGroup.clip(d)), q(z), J || (this.nav = J = e.g().attr({ zIndex: 1 }).add(this.group), this.up = e.symbol("triangle", 0, 0, y, y).on("click", function () {
	          b.scroll(-1, m);
	        }).add(J), this.pager = e.text("", 15, 10).addClass("highcharts-legend-navigation").css(u.style).add(J), this.down = e.symbol("triangle-down", 0, 0, y, y).on("click", function () {
	          b.scroll(1, m);
	        }).add(J)), b.scroll(0), a = c) : J && (q(), this.nav = J.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0);return a;
	      }, scroll: function scroll(a, c) {
	        var b = this.pages,
	            e = b.length;a = this.currentPage + a;var p = this.clipHeight,
	            t = this.options.navigation,
	            k = this.pager,
	            n = this.padding;a > e && (a = e);0 < a && (void 0 !== c && f(c, this.chart), this.nav.attr({ translateX: n, translateY: p + this.padding + 7 + this.titleHeight, visibility: "visible" }), this.up.attr({ "class": 1 === a ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }), k.attr({ text: a + "/" + e }), this.down.attr({ x: 18 + this.pager.getBBox().width, "class": a === e ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" }), this.up.attr({ fill: 1 === a ? t.inactiveColor : t.activeColor }).css({ cursor: 1 === a ? "default" : "pointer" }), this.down.attr({ fill: a === e ? t.inactiveColor : t.activeColor }).css({ cursor: a === e ? "default" : "pointer" }), c = -b[a - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: c }), this.currentPage = a, this.positionCheckboxes(c));
	      } };a.LegendSymbolMixin = { drawRectangle: function drawRectangle(a, c) {
	        var b = a.symbolHeight,
	            e = a.options.squareSymbol;c.legendSymbol = this.chart.renderer.rect(e ? (a.symbolWidth - b) / 2 : 0, a.baseline - b + 1, e ? b : a.symbolWidth, b, n(a.options.symbolRadius, b / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(c.legendGroup);
	      }, drawLineMarker: function drawLineMarker(a) {
	        var b = this.options,
	            c = b.marker,
	            e = a.symbolWidth,
	            p = a.symbolHeight,
	            f = p / 2,
	            k = this.chart.renderer,
	            l = this.legendGroup;a = a.baseline - Math.round(.3 * a.fontMetrics.b);var d;d = { "stroke-width": b.lineWidth || 0 };b.dashStyle && (d.dashstyle = b.dashStyle);this.legendLine = k.path(["M", 0, a, "L", e, a]).addClass("highcharts-graph").attr(d).add(l);c && !1 !== c.enabled && (b = Math.min(n(c.radius, f), f), 0 === this.symbol.indexOf("url") && (c = q(c, { width: p, height: p }), b = 0), this.legendSymbol = c = k.symbol(this.symbol, e / 2 - b, a - b, 2 * b, 2 * b, c).addClass("highcharts-point").add(l), c.isMarker = !0);
	      } };(/Trident\/7\.0/.test(e.navigator.userAgent) || r) && z(D.prototype, "positionItem", function (a, c) {
	      var b = this,
	          e = function e() {
	        c._legendItemPos && a.call(b, c);
	      };e();setTimeout(e);
	    });
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.animate,
	        G = a.animObject,
	        H = a.attr,
	        v = a.doc,
	        l = a.Axis,
	        r = a.createElement,
	        w = a.defaultOptions,
	        q = a.discardElement,
	        n = a.charts,
	        f = a.css,
	        c = a.defined,
	        e = a.each,
	        z = a.extend,
	        b = a.find,
	        t = a.fireEvent,
	        h = a.getStyle,
	        B = a.grep,
	        p = a.isNumber,
	        x = a.isObject,
	        k = a.isString,
	        F = a.Legend,
	        d = a.marginNames,
	        u = a.merge,
	        m = a.Pointer,
	        y = a.pick,
	        J = a.pInt,
	        E = a.removeEvent,
	        I = a.seriesTypes,
	        g = a.splat,
	        L = a.svg,
	        R = a.syncTimeout,
	        O = a.win,
	        M = a.Renderer,
	        P = a.Chart = function () {
	      this.getArgs.apply(this, arguments);
	    };a.chart = function (a, b, c) {
	      return new P(a, b, c);
	    };P.prototype = { callbacks: [], getArgs: function getArgs() {
	        var a = [].slice.call(arguments);if (k(a[0]) || a[0].nodeName) this.renderTo = a.shift();this.init(a[0], a[1]);
	      }, init: function init(b, c) {
	        var d,
	            g = b.series;b.series = null;d = u(w, b);d.series = b.series = g;this.userOptions = b;b = d.chart;g = b.events;this.margin = [];
	        this.spacing = [];this.bounds = { h: {}, v: {} };this.callback = c;this.isResizing = 0;this.options = d;this.axes = [];this.series = [];this.hasCartesianSeries = b.showAxes;var m;this.index = n.length;n.push(this);a.chartCount++;if (g) for (m in g) {
	          D(this, m, g[m]);
	        }this.xAxis = [];this.yAxis = [];this.pointCount = this.colorCounter = this.symbolCounter = 0;this.firstRender();
	      }, initSeries: function initSeries(b) {
	        var c = this.options.chart;(c = I[b.type || c.type || c.defaultSeriesType]) || a.error(17, !0);c = new c();c.init(this, b);return c;
	      }, orderSeries: function orderSeries(a) {
	        var b = this.series;for (a = a || 0; a < b.length; a++) {
	          b[a] && (b[a].index = a, b[a].name = b[a].name || "Series " + (b[a].index + 1));
	        }
	      }, isInsidePlot: function isInsidePlot(a, b, c) {
	        var d = c ? b : a;a = c ? a : b;return 0 <= d && d <= this.plotWidth && 0 <= a && a <= this.plotHeight;
	      }, redraw: function redraw(b) {
	        var c = this.axes,
	            d = this.series,
	            g = this.pointer,
	            m = this.legend,
	            k = this.isDirtyLegend,
	            h,
	            y,
	            p = this.hasCartesianSeries,
	            f = this.isDirtyBox,
	            E,
	            x = this.renderer,
	            u = x.isHidden(),
	            I = [];this.setResponsive && this.setResponsive(!1);a.setAnimation(b, this);u && this.cloneRenderTo();this.layOutTitles();
	        for (b = d.length; b--;) {
	          if (E = d[b], E.options.stacking && (h = !0, E.isDirty)) {
	            y = !0;break;
	          }
	        }if (y) for (b = d.length; b--;) {
	          E = d[b], E.options.stacking && (E.isDirty = !0);
	        }e(d, function (a) {
	          a.isDirty && "point" === a.options.legendType && (a.updateTotals && a.updateTotals(), k = !0);a.isDirtyData && t(a, "updatedData");
	        });k && m.options.enabled && (m.render(), this.isDirtyLegend = !1);h && this.getStacks();p && e(c, function (a) {
	          a.updateNames();a.setScale();
	        });this.getMargins();p && (e(c, function (a) {
	          a.isDirty && (f = !0);
	        }), e(c, function (a) {
	          var b = a.min + "," + a.max;
	          a.extKey !== b && (a.extKey = b, I.push(function () {
	            t(a, "afterSetExtremes", z(a.eventArgs, a.getExtremes()));delete a.eventArgs;
	          }));(f || h) && a.redraw();
	        }));f && this.drawChartBox();t(this, "predraw");e(d, function (a) {
	          (f || a.isDirty) && a.visible && a.redraw();a.isDirtyData = !1;
	        });g && g.reset(!0);x.draw();t(this, "redraw");t(this, "render");u && this.cloneRenderTo(!0);e(I, function (a) {
	          a.call();
	        });
	      }, get: function get(a) {
	        function c(b) {
	          return b.id === a || b.options && b.options.id === a;
	        }var d,
	            g = this.series,
	            m;d = b(this.axes, c) || b(this.series, c);
	        for (m = 0; !d && m < g.length; m++) {
	          d = b(g[m].points || [], c);
	        }return d;
	      }, getAxes: function getAxes() {
	        var a = this,
	            b = this.options,
	            c = b.xAxis = g(b.xAxis || {}),
	            b = b.yAxis = g(b.yAxis || {});e(c, function (a, b) {
	          a.index = b;a.isX = !0;
	        });e(b, function (a, b) {
	          a.index = b;
	        });c = c.concat(b);e(c, function (b) {
	          new l(a, b);
	        });
	      }, getSelectedPoints: function getSelectedPoints() {
	        var a = [];e(this.series, function (b) {
	          a = a.concat(B(b.points || [], function (a) {
	            return a.selected;
	          }));
	        });return a;
	      }, getSelectedSeries: function getSelectedSeries() {
	        return B(this.series, function (a) {
	          return a.selected;
	        });
	      }, setTitle: function setTitle(a, b, c) {
	        var d = this,
	            g = d.options,
	            m;m = g.title = u({ style: { color: "#333333", fontSize: g.isStock ? "16px" : "18px" } }, g.title, a);g = g.subtitle = u({ style: { color: "#666666" } }, g.subtitle, b);e([["title", a, m], ["subtitle", b, g]], function (a, b) {
	          var c = a[0],
	              g = d[c],
	              m = a[1];a = a[2];g && m && (d[c] = g = g.destroy());a && a.text && !g && (d[c] = d.renderer.text(a.text, 0, 0, a.useHTML).attr({ align: a.align, "class": "highcharts-" + c, zIndex: a.zIndex || 4 }).add(), d[c].update = function (a) {
	            d.setTitle(!b && a, b && a);
	          }, d[c].css(a.style));
	        });d.layOutTitles(c);
	      }, layOutTitles: function layOutTitles(a) {
	        var b = 0,
	            c,
	            d = this.renderer,
	            g = this.spacingBox;e(["title", "subtitle"], function (a) {
	          var c = this[a],
	              m = this.options[a],
	              k;c && (k = m.style.fontSize, k = d.fontMetrics(k, c).b, c.css({ width: (m.width || g.width + m.widthAdjust) + "px" }).align(z({ y: b + k + ("title" === a ? -3 : 2) }, m), !1, "spacingBox"), m.floating || m.verticalAlign || (b = Math.ceil(b + c.getBBox(m.useHTML).height)));
	        }, this);c = this.titleOffset !== b;this.titleOffset = b;!this.isDirtyBox && c && (this.isDirtyBox = c, this.hasRendered && y(a, !0) && this.isDirtyBox && this.redraw());
	      }, getChartSize: function getChartSize() {
	        var b = this.options.chart,
	            d = b.width,
	            b = b.height,
	            g = this.renderToClone || this.renderTo;c(d) || (this.containerWidth = h(g, "width"));c(b) || (this.containerHeight = h(g, "height"));this.chartWidth = Math.max(0, d || this.containerWidth || 600);this.chartHeight = Math.max(0, a.relativeLength(b, this.chartWidth) || this.containerHeight || 400);
	      }, cloneRenderTo: function cloneRenderTo(a) {
	        var b = this.renderToClone,
	            c = this.container;if (a) {
	          if (b) {
	            for (; b.childNodes.length;) {
	              this.renderTo.appendChild(b.firstChild);
	            }q(b);delete this.renderToClone;
	          }
	        } else c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), f(b, { position: "absolute", top: "-9999px", display: "block" }), b.style.setProperty && b.style.setProperty("display", "block", "important"), v.body.appendChild(b), c && b.appendChild(c);
	      }, setClassName: function setClassName(a) {
	        this.container.className = "highcharts-container " + (a || "");
	      }, getContainer: function getContainer() {
	        var b,
	            c = this.options,
	            d = c.chart,
	            g,
	            m;b = this.renderTo;var h = a.uniqueKey(),
	            y;b || (this.renderTo = b = d.renderTo);k(b) && (this.renderTo = b = v.getElementById(b));
	        b || a.error(13, !0);g = J(H(b, "data-highcharts-chart"));p(g) && n[g] && n[g].hasRendered && n[g].destroy();H(b, "data-highcharts-chart", this.index);b.innerHTML = "";d.skipClone || b.offsetWidth || this.cloneRenderTo();this.getChartSize();g = this.chartWidth;m = this.chartHeight;y = z({ position: "relative", overflow: "hidden", width: g + "px", height: m + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }, d.style);this.container = b = r("div", { id: h }, y, this.renderToClone || b);this._cursor = b.style.cursor;
	        this.renderer = new (a[d.renderer] || M)(b, g, m, null, d.forExport, c.exporting && c.exporting.allowHTML);this.setClassName(d.className);this.renderer.setStyle(d.style);this.renderer.chartIndex = this.index;
	      }, getMargins: function getMargins(a) {
	        var b = this.spacing,
	            d = this.margin,
	            g = this.titleOffset;this.resetMargins();g && !c(d[0]) && (this.plotTop = Math.max(this.plotTop, g + this.options.title.margin + b[0]));this.legend.display && this.legend.adjustMargins(d, b);this.extraMargin && (this[this.extraMargin.type] = (this[this.extraMargin.type] || 0) + this.extraMargin.value);this.extraTopMargin && (this.plotTop += this.extraTopMargin);a || this.getAxisMargins();
	      }, getAxisMargins: function getAxisMargins() {
	        var a = this,
	            b = a.axisOffset = [0, 0, 0, 0],
	            g = a.margin;a.hasCartesianSeries && e(a.axes, function (a) {
	          a.visible && a.getOffset();
	        });e(d, function (d, m) {
	          c(g[m]) || (a[d] += b[m]);
	        });a.setChartSize();
	      }, reflow: function reflow(a) {
	        var b = this,
	            d = b.options.chart,
	            g = b.renderTo,
	            m = c(d.width),
	            k = d.width || h(g, "width"),
	            d = d.height || h(g, "height"),
	            g = a ? a.target : O;if (!m && !b.isPrinting && k && d && (g === O || g === v)) {
	          if (k !== b.containerWidth || d !== b.containerHeight) clearTimeout(b.reflowTimeout), b.reflowTimeout = R(function () {
	            b.container && b.setSize(void 0, void 0, !1);
	          }, a ? 100 : 0);b.containerWidth = k;b.containerHeight = d;
	        }
	      }, initReflow: function initReflow() {
	        var a = this,
	            b;b = D(O, "resize", function (b) {
	          a.reflow(b);
	        });D(a, "destroy", b);
	      }, setSize: function setSize(b, c, d) {
	        var g = this,
	            m = g.renderer;g.isResizing += 1;a.setAnimation(d, g);g.oldChartHeight = g.chartHeight;g.oldChartWidth = g.chartWidth;void 0 !== b && (g.options.chart.width = b);void 0 !== c && (g.options.chart.height = c);g.getChartSize();b = m.globalAnimation;(b ? C : f)(g.container, { width: g.chartWidth + "px", height: g.chartHeight + "px" }, b);g.setChartSize(!0);m.setSize(g.chartWidth, g.chartHeight, d);e(g.axes, function (a) {
	          a.isDirty = !0;a.setScale();
	        });g.isDirtyLegend = !0;g.isDirtyBox = !0;g.layOutTitles();g.getMargins();g.redraw(d);g.oldChartHeight = null;t(g, "resize");R(function () {
	          g && t(g, "endResize", null, function () {
	            --g.isResizing;
	          });
	        }, G(b).duration);
	      }, setChartSize: function setChartSize(a) {
	        var b = this.inverted,
	            c = this.renderer,
	            d = this.chartWidth,
	            g = this.chartHeight,
	            m = this.options.chart,
	            k = this.spacing,
	            h = this.clipOffset,
	            y,
	            p,
	            f,
	            E;this.plotLeft = y = Math.round(this.plotLeft);this.plotTop = p = Math.round(this.plotTop);this.plotWidth = f = Math.max(0, Math.round(d - y - this.marginRight));this.plotHeight = E = Math.max(0, Math.round(g - p - this.marginBottom));this.plotSizeX = b ? E : f;this.plotSizeY = b ? f : E;this.plotBorderWidth = m.plotBorderWidth || 0;this.spacingBox = c.spacingBox = { x: k[3], y: k[0], width: d - k[3] - k[1], height: g - k[0] - k[2] };this.plotBox = c.plotBox = { x: y, y: p, width: f, height: E };
	        d = 2 * Math.floor(this.plotBorderWidth / 2);b = Math.ceil(Math.max(d, h[3]) / 2);c = Math.ceil(Math.max(d, h[0]) / 2);this.clipBox = { x: b, y: c, width: Math.floor(this.plotSizeX - Math.max(d, h[1]) / 2 - b), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d, h[2]) / 2 - c)) };a || e(this.axes, function (a) {
	          a.setAxisSize();a.setAxisTranslation();
	        });
	      }, resetMargins: function resetMargins() {
	        var a = this,
	            b = a.options.chart;e(["margin", "spacing"], function (c) {
	          var d = b[c],
	              g = x(d) ? d : [d, d, d, d];e(["Top", "Right", "Bottom", "Left"], function (d, m) {
	            a[c][m] = y(b[c + d], g[m]);
	          });
	        });
	        e(d, function (b, c) {
	          a[b] = y(a.margin[c], a.spacing[c]);
	        });a.axisOffset = [0, 0, 0, 0];a.clipOffset = [0, 0, 0, 0];
	      }, drawChartBox: function drawChartBox() {
	        var a = this.options.chart,
	            b = this.renderer,
	            c = this.chartWidth,
	            d = this.chartHeight,
	            g = this.chartBackground,
	            m = this.plotBackground,
	            k = this.plotBorder,
	            h,
	            y = this.plotBGImage,
	            e = a.backgroundColor,
	            p = a.plotBackgroundColor,
	            f = a.plotBackgroundImage,
	            E,
	            t = this.plotLeft,
	            x = this.plotTop,
	            u = this.plotWidth,
	            I = this.plotHeight,
	            n = this.plotBox,
	            l = this.clipRect,
	            z = this.clipBox,
	            J = "animate";g || (this.chartBackground = g = b.rect().addClass("highcharts-background").add(), J = "attr");h = a.borderWidth || 0;E = h + (a.shadow ? 8 : 0);e = { fill: e || "none" };if (h || g["stroke-width"]) e.stroke = a.borderColor, e["stroke-width"] = h;g.attr(e).shadow(a.shadow);g[J]({ x: E / 2, y: E / 2, width: c - E - h % 2, height: d - E - h % 2, r: a.borderRadius });J = "animate";m || (J = "attr", this.plotBackground = m = b.rect().addClass("highcharts-plot-background").add());m[J](n);m.attr({ fill: p || "none" }).shadow(a.plotShadow);f && (y ? y.animate(n) : this.plotBGImage = b.image(f, t, x, u, I).add());l ? l.animate({ width: z.width,
	          height: z.height }) : this.clipRect = b.clipRect(z);J = "animate";k || (J = "attr", this.plotBorder = k = b.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add());k.attr({ stroke: a.plotBorderColor, "stroke-width": a.plotBorderWidth || 0, fill: "none" });k[J](k.crisp({ x: t, y: x, width: u, height: I }, -k.strokeWidth()));this.isDirtyBox = !1;
	      }, propFromSeries: function propFromSeries() {
	        var a = this,
	            b = a.options.chart,
	            c,
	            d = a.options.series,
	            g,
	            m;e(["inverted", "angular", "polar"], function (k) {
	          c = I[b.type || b.defaultSeriesType];m = b[k] || c && c.prototype[k];
	          for (g = d && d.length; !m && g--;) {
	            (c = I[d[g].type]) && c.prototype[k] && (m = !0);
	          }a[k] = m;
	        });
	      }, linkSeries: function linkSeries() {
	        var a = this,
	            b = a.series;e(b, function (a) {
	          a.linkedSeries.length = 0;
	        });e(b, function (b) {
	          var c = b.options.linkedTo;k(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, b.visible = y(b.options.visible, c.options.visible, b.visible));
	        });
	      }, renderSeries: function renderSeries() {
	        e(this.series, function (a) {
	          a.translate();a.render();
	        });
	      }, renderLabels: function renderLabels() {
	        var a = this,
	            b = a.options.labels;
	        b.items && e(b.items, function (c) {
	          var d = z(b.style, c.style),
	              g = J(d.left) + a.plotLeft,
	              m = J(d.top) + a.plotTop + 12;delete d.left;delete d.top;a.renderer.text(c.html, g, m).attr({ zIndex: 2 }).css(d).add();
	        });
	      }, render: function render() {
	        var a = this.axes,
	            b = this.renderer,
	            c = this.options,
	            d,
	            g,
	            m;this.setTitle();this.legend = new F(this, c.legend);this.getStacks && this.getStacks();this.getMargins(!0);this.setChartSize();c = this.plotWidth;d = this.plotHeight -= 21;e(a, function (a) {
	          a.setScale();
	        });this.getAxisMargins();g = 1.1 < c / this.plotWidth;m = 1.05 < d / this.plotHeight;if (g || m) e(a, function (a) {
	          (a.horiz && g || !a.horiz && m) && a.setTickInterval(!0);
	        }), this.getMargins();this.drawChartBox();this.hasCartesianSeries && e(a, function (a) {
	          a.visible && a.render();
	        });this.seriesGroup || (this.seriesGroup = b.g("series-group").attr({ zIndex: 3 }).add());this.renderSeries();this.renderLabels();this.addCredits();this.setResponsive && this.setResponsive();this.hasRendered = !0;
	      }, addCredits: function addCredits(a) {
	        var b = this;a = u(!0, this.options.credits, a);a.enabled && !this.credits && (this.credits = this.renderer.text(a.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function () {
	          a.href && (O.location.href = a.href);
	        }).attr({ align: a.position.align, zIndex: 8 }).css(a.style).add().align(a.position), this.credits.update = function (a) {
	          b.credits = b.credits.destroy();b.addCredits(a);
	        });
	      }, destroy: function destroy() {
	        var b = this,
	            c = b.axes,
	            d = b.series,
	            g = b.container,
	            m,
	            k = g && g.parentNode;t(b, "destroy");n[b.index] = void 0;a.chartCount--;b.renderTo.removeAttribute("data-highcharts-chart");E(b);for (m = c.length; m--;) {
	          c[m] = c[m].destroy();
	        }this.scroller && this.scroller.destroy && this.scroller.destroy();for (m = d.length; m--;) {
	          d[m] = d[m].destroy();
	        }e("title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" "), function (a) {
	          var c = b[a];c && c.destroy && (b[a] = c.destroy());
	        });g && (g.innerHTML = "", E(g), k && q(g));for (m in b) {
	          delete b[m];
	        }
	      }, isReadyToRender: function isReadyToRender() {
	        var a = this;return L || O != O.top || "complete" === v.readyState ? !0 : (v.attachEvent("onreadystatechange", function () {
	          v.detachEvent("onreadystatechange", a.firstRender);"complete" === v.readyState && a.firstRender();
	        }), !1);
	      }, firstRender: function firstRender() {
	        var a = this,
	            b = a.options;if (a.isReadyToRender()) {
	          a.getContainer();t(a, "init");a.resetMargins();a.setChartSize();a.propFromSeries();a.getAxes();e(b.series || [], function (b) {
	            a.initSeries(b);
	          });a.linkSeries();t(a, "beforeRender");m && (a.pointer = new m(a, b));a.render();if (!a.renderer.imgCount && a.onload) a.onload();a.cloneRenderTo(!0);
	        }
	      }, onload: function onload() {
	        e([this.callback].concat(this.callbacks), function (a) {
	          a && void 0 !== this.index && a.apply(this, [this]);
	        }, this);t(this, "load");t(this, "render");c(this.index) && !1 !== this.options.chart.reflow && this.initReflow();this.onload = null;
	      } };
	  })(K);(function (a) {
	    var D,
	        C = a.each,
	        G = a.extend,
	        H = a.erase,
	        v = a.fireEvent,
	        l = a.format,
	        r = a.isArray,
	        w = a.isNumber,
	        q = a.pick,
	        n = a.removeEvent;D = a.Point = function () {};D.prototype = { init: function init(a, c, e) {
	        this.series = a;this.color = a.color;this.applyOptions(c, e);a.options.colorByPoint ? (c = a.options.colors || a.chart.options.colors, this.color = this.color || c[a.colorCounter], c = c.length, e = a.colorCounter, a.colorCounter++, a.colorCounter === c && (a.colorCounter = 0)) : e = a.colorIndex;this.colorIndex = q(this.colorIndex, e);a.chart.pointCount++;return this;
	      }, applyOptions: function applyOptions(a, c) {
	        var e = this.series,
	            f = e.options.pointValKey || e.pointValKey;a = D.prototype.optionsToObject.call(this, a);G(this, a);this.options = this.options ? G(this.options, a) : a;a.group && delete this.group;f && (this.y = this[f]);this.isNull = q(this.isValid && !this.isValid(), null === this.x || !w(this.y, !0));this.selected && (this.state = "select");"name" in this && void 0 === c && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));void 0 === this.x && e && (this.x = void 0 === c ? e.autoIncrement(this) : c);return this;
	      }, optionsToObject: function optionsToObject(a) {
	        var c = {},
	            e = this.series,
	            f = e.options.keys,
	            b = f || e.pointArrayMap || ["y"],
	            t = b.length,
	            h = 0,
	            n = 0;if (w(a) || null === a) c[b[0]] = a;else if (r(a)) for (!f && a.length > t && (e = (0, _typeof3.default)(a[0]), "string" === e ? c.name = a[0] : "number" === e && (c.x = a[0]), h++); n < t;) {
	          f && void 0 === a[h] || (c[b[n]] = a[h]), h++, n++;
	        } else "object" === (typeof a === "undefined" ? "undefined" : (0, _typeof3.default)(a)) && (c = a, a.dataLabels && (e._hasPointLabels = !0), a.marker && (e._hasPointMarkers = !0));return c;
	      }, getClassName: function getClassName() {
	        return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (void 0 !== this.colorIndex ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
	      }, getZone: function getZone() {
	        var a = this.series,
	            c = a.zones,
	            a = a.zoneAxis || "y",
	            e = 0,
	            n;for (n = c[e]; this[a] >= n.value;) {
	          n = c[++e];
	        }n && n.color && !this.options.color && (this.color = n.color);return n;
	      }, destroy: function destroy() {
	        var a = this.series.chart,
	            c = a.hoverPoints,
	            e;a.pointCount--;c && (this.setState(), H(c, this), c.length || (a.hoverPoints = null));if (this === a.hoverPoint) this.onMouseOut();if (this.graphic || this.dataLabel) n(this), this.destroyElements();this.legendItem && a.legend.destroyItem(this);for (e in this) {
	          this[e] = null;
	        }
	      }, destroyElements: function destroyElements() {
	        for (var a = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"], c, e = 6; e--;) {
	          c = a[e], this[c] && (this[c] = this[c].destroy());
	        }
	      }, getLabelConfig: function getLabelConfig() {
	        return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };
	      }, tooltipFormatter: function tooltipFormatter(a) {
	        var c = this.series,
	            e = c.tooltipOptions,
	            f = q(e.valueDecimals, ""),
	            b = e.valuePrefix || "",
	            t = e.valueSuffix || "";C(c.pointArrayMap || ["y"], function (c) {
	          c = "{point." + c;if (b || t) a = a.replace(c + "}", b + c + "}" + t);a = a.replace(c + "}", c + ":,." + f + "f}");
	        });return l(a, { point: this, series: this.series });
	      }, firePointEvent: function firePointEvent(a, c, e) {
	        var f = this,
	            b = this.series.options;(b.point.events[a] || f.options && f.options.events && f.options.events[a]) && this.importEvents();"click" === a && b.allowPointSelect && (e = function e(a) {
	          f.select && f.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
	        });v(this, a, c, e);
	      }, visible: !0 };
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.animObject,
	        G = a.arrayMax,
	        H = a.arrayMin,
	        v = a.correctFloat,
	        l = a.Date,
	        r = a.defaultOptions,
	        w = a.defaultPlotOptions,
	        q = a.defined,
	        n = a.each,
	        f = a.erase,
	        c = a.extend,
	        e = a.fireEvent,
	        z = a.grep,
	        b = a.isArray,
	        t = a.isNumber,
	        h = a.isString,
	        B = a.merge,
	        p = a.pick,
	        x = a.removeEvent,
	        k = a.splat,
	        F = a.SVGElement,
	        d = a.syncTimeout,
	        u = a.win;a.Series = a.seriesType("line", null, { lineWidth: 2, allowPointSelect: !1, showCheckbox: !1, animation: { duration: 1E3 }, events: {}, marker: { lineWidth: 0, lineColor: "#ffffff", radius: 4, states: { hover: { animation: { duration: 50 }, enabled: !0, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc",
	            lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { align: "center", formatter: function formatter() {
	          return null === this.y ? "" : a.numberFormat(this.y, -1);
	        }, style: { fontSize: "11px", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0, padding: 5 }, cropThreshold: 300, pointRange: 0, softThreshold: !0, states: { hover: { animation: { duration: 50 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: .25 } }, select: { marker: {} } }, stickyTracking: !0, turboThreshold: 1E3, findNearestPointBy: "x" }, { isCartesian: !0, pointClass: a.Point, sorted: !0, requireSorting: !0, directTouch: !1, axisTypes: ["xAxis", "yAxis"], colorCounter: 0, parallelArrays: ["x", "y"], coll: "series", init: function init(a, b) {
	        var d = this,
	            m,
	            k,
	            g = a.series,
	            h;d.chart = a;d.options = b = d.setOptions(b);d.linkedSeries = [];d.bindAxes();c(d, { name: b.name, state: "", visible: !1 !== b.visible, selected: !0 === b.selected });k = b.events;for (m in k) {
	          D(d, m, k[m]);
	        }if (k && k.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) a.runTrackerClick = !0;d.getColor();
	        d.getSymbol();n(d.parallelArrays, function (a) {
	          d[a + "Data"] = [];
	        });d.setData(b.data, !1);d.isCartesian && (a.hasCartesianSeries = !0);g.length && (h = g[g.length - 1]);d._i = p(h && h._i, -1) + 1;a.orderSeries(this.insert(g));
	      }, insert: function insert(a) {
	        var b = this.options.index,
	            c;if (t(b)) {
	          for (c = a.length; c--;) {
	            if (b >= p(a[c].options.index, a[c]._i)) {
	              a.splice(c + 1, 0, this);break;
	            }
	          }-1 === c && a.unshift(this);c += 1;
	        } else a.push(this);return p(c, a.length - 1);
	      }, bindAxes: function bindAxes() {
	        var b = this,
	            c = b.options,
	            d = b.chart,
	            k;n(b.axisTypes || [], function (m) {
	          n(d[m], function (a) {
	            k = a.options;if (c[m] === k.index || void 0 !== c[m] && c[m] === k.id || void 0 === c[m] && 0 === k.index) b.insert(a.series), b[m] = a, a.isDirty = !0;
	          });b[m] || b.optionalAxis === m || a.error(18, !0);
	        });
	      }, updateParallelArrays: function updateParallelArrays(a, b) {
	        var c = a.series,
	            d = arguments,
	            m = t(b) ? function (d) {
	          var g = "y" === d && c.toYData ? c.toYData(a) : a[d];c[d + "Data"][b] = g;
	        } : function (a) {
	          Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2));
	        };n(c.parallelArrays, m);
	      }, autoIncrement: function autoIncrement() {
	        var a = this.options,
	            b = this.xIncrement,
	            c,
	            d = a.pointIntervalUnit,
	            b = p(b, a.pointStart, 0);this.pointInterval = c = p(this.pointInterval, a.pointInterval, 1);d && (a = new l(b), "day" === d ? a = +a[l.hcSetDate](a[l.hcGetDate]() + c) : "month" === d ? a = +a[l.hcSetMonth](a[l.hcGetMonth]() + c) : "year" === d && (a = +a[l.hcSetFullYear](a[l.hcGetFullYear]() + c)), c = a - b);this.xIncrement = b + c;return b;
	      }, setOptions: function setOptions(a) {
	        var b = this.chart,
	            c = b.options.plotOptions,
	            b = b.userOptions || {},
	            d = b.plotOptions || {},
	            m = c[this.type];this.userOptions = a;c = B(m, c.series, a);this.tooltipOptions = B(r.tooltip, r.plotOptions[this.type].tooltip, b.tooltip, d.series && d.series.tooltip, d[this.type] && d[this.type].tooltip, a.tooltip);this.stickyTracking = p(a.stickyTracking, d[this.type] && d[this.type].stickyTracking, d.series && d.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : c.stickyTracking);null === m.marker && delete c.marker;this.zoneAxis = c.zoneAxis;a = this.zones = (c.zones || []).slice();!c.negativeColor && !c.negativeFillColor || c.zones || a.push({ value: c[this.zoneAxis + "Threshold"] || c.threshold || 0, className: "highcharts-negative",
	          color: c.negativeColor, fillColor: c.negativeFillColor });a.length && q(a[a.length - 1].value) && a.push({ color: this.color, fillColor: this.fillColor });return c;
	      }, getCyclic: function getCyclic(a, b, c) {
	        var d,
	            m = this.chart,
	            g = this.userOptions,
	            k = a + "Index",
	            h = a + "Counter",
	            e = c ? c.length : p(m.options.chart[a + "Count"], m[a + "Count"]);b || (d = p(g[k], g["_" + k]), q(d) || (m.series.length || (m[h] = 0), g["_" + k] = d = m[h] % e, m[h] += 1), c && (b = c[d]));void 0 !== d && (this[k] = d);this[a] = b;
	      }, getColor: function getColor() {
	        this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || w[this.type].color, this.chart.options.colors);
	      }, getSymbol: function getSymbol() {
	        this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
	      }, drawLegendSymbol: a.LegendSymbolMixin.drawLineMarker, setData: function setData(c, d, k, e) {
	        var m = this,
	            g = m.points,
	            y = g && g.length || 0,
	            E,
	            f = m.options,
	            x = m.chart,
	            u = null,
	            l = m.xAxis,
	            z = f.turboThreshold,
	            F = this.xData,
	            q = this.yData,
	            r = (E = m.pointArrayMap) && E.length;c = c || [];E = c.length;d = p(d, !0);if (!1 !== e && E && y === E && !m.cropped && !m.hasGroupedData && m.visible) n(c, function (a, b) {
	          g[b].update && a !== f.data[b] && g[b].update(a, !1, null, !1);
	        });else {
	          m.xIncrement = null;m.colorCounter = 0;n(this.parallelArrays, function (a) {
	            m[a + "Data"].length = 0;
	          });if (z && E > z) {
	            for (k = 0; null === u && k < E;) {
	              u = c[k], k++;
	            }if (t(u)) for (k = 0; k < E; k++) {
	              F[k] = this.autoIncrement(), q[k] = c[k];
	            } else if (b(u)) {
	              if (r) for (k = 0; k < E; k++) {
	                u = c[k], F[k] = u[0], q[k] = u.slice(1, r + 1);
	              } else for (k = 0; k < E; k++) {
	                u = c[k], F[k] = u[0], q[k] = u[1];
	              }
	            } else a.error(12);
	          } else for (k = 0; k < E; k++) {
	            void 0 !== c[k] && (u = { series: m }, m.pointClass.prototype.applyOptions.apply(u, [c[k]]), m.updateParallelArrays(u, k));
	          }h(q[0]) && a.error(14, !0);m.data = [];m.options.data = m.userOptions.data = c;for (k = y; k--;) {
	            g[k] && g[k].destroy && g[k].destroy();
	          }l && (l.minRange = l.userMinRange);m.isDirty = x.isDirtyBox = !0;m.isDirtyData = !!g;k = !1;
	        }"point" === f.legendType && (this.processData(), this.generatePoints());d && x.redraw(k);
	      }, processData: function processData(b) {
	        var c = this.xData,
	            d = this.yData,
	            m = c.length,
	            k;k = 0;var g,
	            h,
	            e = this.xAxis,
	            p,
	            f = this.options;p = f.cropThreshold;var t = this.getExtremesFromAll || f.getExtremesFromAll,
	            u = this.isCartesian,
	            f = e && e.val2lin,
	            x = e && e.isLog,
	            n,
	            l;if (u && !this.isDirty && !e.isDirty && !this.yAxis.isDirty && !b) return !1;e && (b = e.getExtremes(), n = b.min, l = b.max);if (u && this.sorted && !t && (!p || m > p || this.forceCrop)) if (c[m - 1] < n || c[0] > l) c = [], d = [];else if (c[0] < n || c[m - 1] > l) k = this.cropData(this.xData, this.yData, n, l), c = k.xData, d = k.yData, k = k.start, g = !0;for (p = c.length || 1; --p;) {
	          m = x ? f(c[p]) - f(c[p - 1]) : c[p] - c[p - 1], 0 < m && (void 0 === h || m < h) ? h = m : 0 > m && this.requireSorting && a.error(15);
	        }this.cropped = g;this.cropStart = k;this.processedXData = c;this.processedYData = d;this.closestPointRange = h;
	      }, cropData: function cropData(a, b, c, d) {
	        var m = a.length,
	            g = 0,
	            k = m,
	            h = p(this.cropShoulder, 1),
	            e;for (e = 0; e < m; e++) {
	          if (a[e] >= c) {
	            g = Math.max(0, e - h);break;
	          }
	        }for (c = e; c < m; c++) {
	          if (a[c] > d) {
	            k = c + h;break;
	          }
	        }return { xData: a.slice(g, k), yData: b.slice(g, k), start: g, end: k };
	      }, generatePoints: function generatePoints() {
	        var a = this.options.data,
	            b = this.data,
	            c,
	            d = this.processedXData,
	            h = this.processedYData,
	            g = this.pointClass,
	            e = d.length,
	            p = this.cropStart || 0,
	            f,
	            t = this.hasGroupedData,
	            u,
	            x = [],
	            n;b || t || (b = [], b.length = a.length, b = this.data = b);for (n = 0; n < e; n++) {
	          f = p + n, t ? (u = new g().init(this, [d[n]].concat(k(h[n]))), u.dataGroup = this.groupMap[n]) : (u = b[f]) || void 0 === a[f] || (b[f] = u = new g().init(this, a[f], d[n])), u && (u.index = f, x[n] = u);
	        }if (b && (e !== (c = b.length) || t)) for (n = 0; n < c; n++) {
	          n !== p || t || (n += e), b[n] && (b[n].destroyElements(), b[n].plotX = void 0);
	        }this.data = b;this.points = x;
	      }, getExtremes: function getExtremes(a) {
	        var c = this.yAxis,
	            d = this.processedXData,
	            m,
	            k = [],
	            g = 0;m = this.xAxis.getExtremes();var h = m.min,
	            e = m.max,
	            p,
	            f,
	            u,
	            x;a = a || this.stackedYData || this.processedYData || [];m = a.length;for (x = 0; x < m; x++) {
	          if (f = d[x], u = a[x], p = (t(u, !0) || b(u)) && (!c.positiveValuesOnly || u.length || 0 < u), f = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (d[x] || f) >= h && (d[x] || f) <= e, p && f) if (p = u.length) for (; p--;) {
	            null !== u[p] && (k[g++] = u[p]);
	          } else k[g++] = u;
	        }this.dataMin = H(k);this.dataMax = G(k);
	      }, translate: function translate() {
	        this.processedXData || this.processData();this.generatePoints();var a = this.options,
	            b = a.stacking,
	            c = this.xAxis,
	            d = c.categories,
	            k = this.yAxis,
	            g = this.points,
	            h = g.length,
	            e = !!this.modifyValue,
	            f = a.pointPlacement,
	            u = "between" === f || t(f),
	            x = a.threshold,
	            n = a.startFromThreshold ? x : 0,
	            l,
	            z,
	            F,
	            r,
	            B = Number.MAX_VALUE;"between" === f && (f = .5);t(f) && (f *= p(a.pointRange || c.pointRange));for (a = 0; a < h; a++) {
	          var w = g[a],
	              C = w.x,
	              D = w.y;z = w.low;var G = b && k.stacks[(this.negStacks && D < (n ? 0 : x) ? "-" : "") + this.stackKey],
	              H;k.positiveValuesOnly && null !== D && 0 >= D && (w.isNull = !0);w.plotX = l = v(Math.min(Math.max(-1E5, c.translate(C, 0, 0, 0, 1, f, "flags" === this.type)), 1E5));b && this.visible && !w.isNull && G && G[C] && (r = this.getStackIndicator(r, C, this.index), H = G[C], D = H.points[r.key], z = D[0], D = D[1], z === n && r.key === G[C].base && (z = p(x, k.min)), k.positiveValuesOnly && 0 >= z && (z = null), w.total = w.stackTotal = H.total, w.percentage = H.total && w.y / H.total * 100, w.stackY = D, H.setOffset(this.pointXOffset || 0, this.barW || 0));w.yBottom = q(z) ? k.translate(z, 0, 1, 0, 1) : null;e && (D = this.modifyValue(D, w));w.plotY = z = "number" === typeof D && Infinity !== D ? Math.min(Math.max(-1E5, k.translate(D, 0, 1, 0, 1)), 1E5) : void 0;w.isInside = void 0 !== z && 0 <= z && z <= k.len && 0 <= l && l <= c.len;w.clientX = u ? v(c.translate(C, 0, 0, 0, 1, f)) : l;w.negative = w.y < (x || 0);
	          w.category = d && void 0 !== d[w.x] ? d[w.x] : w.x;w.isNull || (void 0 !== F && (B = Math.min(B, Math.abs(l - F))), F = l);w.zone = this.zones.length && w.getZone();
	        }this.closestPointRangePx = B;
	      }, getValidPoints: function getValidPoints(a, b) {
	        var c = this.chart;return z(a || this.points || [], function (a) {
	          return b && !c.isInsidePlot(a.plotX, a.plotY, c.inverted) ? !1 : !a.isNull;
	        });
	      }, setClip: function setClip(a) {
	        var b = this.chart,
	            c = this.options,
	            d = b.renderer,
	            m = b.inverted,
	            g = this.clipBox,
	            k = g || b.clipBox,
	            h = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, k.height, c.xAxis, c.yAxis].join(),
	            e = b[h],
	            p = b[h + "m"];e || (a && (k.width = 0, b[h + "m"] = p = d.clipRect(-99, m ? -b.plotLeft : -b.plotTop, 99, m ? b.chartWidth : b.chartHeight)), b[h] = e = d.clipRect(k), e.count = { length: 0 });a && !e.count[this.index] && (e.count[this.index] = !0, e.count.length += 1);!1 !== c.clip && (this.group.clip(a || g ? e : b.clipRect), this.markerGroup.clip(p), this.sharedClipKey = h);a || (e.count[this.index] && (delete e.count[this.index], --e.count.length), 0 === e.count.length && h && b[h] && (g || (b[h] = b[h].destroy()), b[h + "m"] && (b[h + "m"] = b[h + "m"].destroy())));
	      },
	      animate: function animate(a) {
	        var b = this.chart,
	            c = C(this.options.animation),
	            d;a ? this.setClip(c) : (d = this.sharedClipKey, (a = b[d]) && a.animate({ width: b.plotSizeX }, c), b[d + "m"] && b[d + "m"].animate({ width: b.plotSizeX + 99 }, c), this.animate = null);
	      }, afterAnimate: function afterAnimate() {
	        this.setClip();e(this, "afterAnimate");
	      }, drawPoints: function drawPoints() {
	        var a = this.points,
	            b = this.chart,
	            c,
	            d,
	            k,
	            g,
	            h = this.options.marker,
	            e,
	            f,
	            u,
	            x,
	            n = this.markerGroup,
	            l = p(h.enabled, this.xAxis.isRadial ? !0 : null, this.closestPointRangePx >= 2 * h.radius);if (!1 !== h.enabled || this._hasPointMarkers) for (d = 0; d < a.length; d++) {
	          k = a[d], c = k.plotY, g = k.graphic, e = k.marker || {}, f = !!k.marker, u = l && void 0 === e.enabled || e.enabled, x = k.isInside, u && t(c) && null !== k.y ? (c = p(e.symbol, this.symbol), k.hasImage = 0 === c.indexOf("url"), u = this.markerAttribs(k, k.selected && "select"), g ? g[x ? "show" : "hide"](!0).animate(u) : x && (0 < u.width || k.hasImage) && (k.graphic = g = b.renderer.symbol(c, u.x, u.y, u.width, u.height, f ? e : h).add(n)), g && g.attr(this.pointAttribs(k, k.selected && "select")), g && g.addClass(k.getClassName(), !0)) : g && (k.graphic = g.destroy());
	        }
	      }, markerAttribs: function markerAttribs(a, b) {
	        var c = this.options.marker,
	            d = a.marker || {},
	            m = p(d.radius, c.radius);b && (c = c.states[b], b = d.states && d.states[b], m = p(b && b.radius, c && c.radius, m + (c && c.radiusPlus || 0)));a.hasImage && (m = 0);a = { x: Math.floor(a.plotX) - m, y: a.plotY - m };m && (a.width = a.height = 2 * m);return a;
	      }, pointAttribs: function pointAttribs(a, b) {
	        var c = this.options.marker,
	            d = a && a.options,
	            m = d && d.marker || {},
	            g = this.color,
	            k = d && d.color,
	            h = a && a.color,
	            d = p(m.lineWidth, c.lineWidth);a = a && a.zone && a.zone.color;g = k || a || h || g;a = m.fillColor || c.fillColor || g;g = m.lineColor || c.lineColor || g;b && (c = c.states[b], b = m.states && m.states[b] || {}, d = p(b.lineWidth, c.lineWidth, d + p(b.lineWidthPlus, c.lineWidthPlus, 0)), a = b.fillColor || c.fillColor || a, g = b.lineColor || c.lineColor || g);return { stroke: g, "stroke-width": d, fill: a };
	      }, destroy: function destroy() {
	        var a = this,
	            b = a.chart,
	            c = /AppleWebKit\/533/.test(u.navigator.userAgent),
	            d,
	            k = a.data || [],
	            g,
	            h,
	            p;e(a, "destroy");x(a);n(a.axisTypes || [], function (b) {
	          (p = a[b]) && p.series && (f(p.series, a), p.isDirty = p.forceRedraw = !0);
	        });a.legendItem && a.chart.legend.destroyItem(a);for (d = k.length; d--;) {
	          (g = k[d]) && g.destroy && g.destroy();
	        }a.points = null;clearTimeout(a.animationTimeout);for (h in a) {
	          a[h] instanceof F && !a[h].survive && (d = c && "group" === h ? "hide" : "destroy", a[h][d]());
	        }b.hoverSeries === a && (b.hoverSeries = null);f(b.series, a);b.orderSeries();for (h in a) {
	          delete a[h];
	        }
	      }, getGraphPath: function getGraphPath(a, b, c) {
	        var d = this,
	            m = d.options,
	            g = m.step,
	            k,
	            h = [],
	            e = [],
	            p;a = a || d.points;(k = a.reversed) && a.reverse();(g = { right: 1, center: 2 }[g] || g && 3) && k && (g = 4 - g);!m.connectNulls || b || c || (a = this.getValidPoints(a));n(a, function (k, f) {
	          var u = k.plotX,
	              x = k.plotY,
	              t = a[f - 1];(k.leftCliff || t && t.rightCliff) && !c && (p = !0);k.isNull && !q(b) && 0 < f ? p = !m.connectNulls : k.isNull && !b ? p = !0 : (0 === f || p ? f = ["M", k.plotX, k.plotY] : d.getPointSpline ? f = d.getPointSpline(a, k, f) : g ? (f = 1 === g ? ["L", t.plotX, x] : 2 === g ? ["L", (t.plotX + u) / 2, t.plotY, "L", (t.plotX + u) / 2, x] : ["L", u, t.plotY], f.push("L", u, x)) : f = ["L", u, x], e.push(k.x), g && e.push(k.x), h.push.apply(h, f), p = !1);
	        });h.xMap = e;return d.graphPath = h;
	      }, drawGraph: function drawGraph() {
	        var a = this,
	            b = this.options,
	            c = (this.gappedPath || this.getGraphPath).call(this),
	            d = [["graph", "highcharts-graph", b.lineColor || this.color, b.dashStyle]];n(this.zones, function (c, g) {
	          d.push(["zone-graph-" + g, "highcharts-graph highcharts-zone-graph-" + g + " " + (c.className || ""), c.color || a.color, c.dashStyle || b.dashStyle]);
	        });n(d, function (d, g) {
	          var k = d[0],
	              m = a[k];m ? (m.endX = c.xMap, m.animate({ d: c })) : c.length && (a[k] = a.chart.renderer.path(c).addClass(d[1]).attr({ zIndex: 1 }).add(a.group), m = { stroke: d[2], "stroke-width": b.lineWidth, fill: a.fillGraph && a.color || "none" }, d[3] ? m.dashstyle = d[3] : "square" !== b.linecap && (m["stroke-linecap"] = m["stroke-linejoin"] = "round"), m = a[k].attr(m).shadow(2 > g && b.shadow));m && (m.startX = c.xMap, m.isArea = c.isArea);
	        });
	      }, applyZones: function applyZones() {
	        var a = this,
	            b = this.chart,
	            c = b.renderer,
	            d = this.zones,
	            k,
	            g,
	            h = this.clips || [],
	            e,
	            f = this.graph,
	            u = this.area,
	            x = Math.max(b.chartWidth, b.chartHeight),
	            t = this[(this.zoneAxis || "y") + "Axis"],
	            l,
	            z,
	            F = b.inverted,
	            q,
	            r,
	            B,
	            w,
	            v = !1;d.length && (f || u) && t && void 0 !== t.min && (z = t.reversed, q = t.horiz, f && f.hide(), u && u.hide(), l = t.getExtremes(), n(d, function (d, m) {
	          k = z ? q ? b.plotWidth : 0 : q ? 0 : t.toPixels(l.min);k = Math.min(Math.max(p(g, k), 0), x);g = Math.min(Math.max(Math.round(t.toPixels(p(d.value, l.max), !0)), 0), x);v && (k = g = t.toPixels(l.max));r = Math.abs(k - g);B = Math.min(k, g);w = Math.max(k, g);t.isXAxis ? (e = { x: F ? w : B, y: 0, width: r, height: x }, q || (e.x = b.plotHeight - e.x)) : (e = { x: 0, y: F ? w : B, width: x, height: r }, q && (e.y = b.plotWidth - e.y));F && c.isVML && (e = t.isXAxis ? { x: 0, y: z ? B : w, height: e.width, width: b.chartWidth } : { x: e.y - b.plotLeft - b.spacingBox.x, y: 0, width: e.height, height: b.chartHeight });h[m] ? h[m].animate(e) : (h[m] = c.clipRect(e), f && a["zone-graph-" + m].clip(h[m]), u && a["zone-area-" + m].clip(h[m]));v = d.value > l.max;
	        }), this.clips = h);
	      }, invertGroups: function invertGroups(a) {
	        function b() {
	          n(["group", "markerGroup"], function (b) {
	            c[b] && (d.renderer.isVML && c[b].attr({ width: c.yAxis.len, height: c.xAxis.len }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(a));
	          });
	        }var c = this,
	            d = c.chart,
	            k;c.xAxis && (k = D(d, "resize", b), D(c, "destroy", k), b(a), c.invertGroups = b);
	      }, plotGroup: function plotGroup(a, b, c, d, k) {
	        var g = this[a],
	            m = !g;m && (this[a] = g = this.chart.renderer.g(b).attr({ zIndex: d || .1 }).add(k), g.addClass("highcharts-series-" + this.index + " highcharts-" + this.type + "-series highcharts-color-" + this.colorIndex + " " + (this.options.className || "")));g.attr({ visibility: c })[m ? "attr" : "animate"](this.getPlotBox());return g;
	      }, getPlotBox: function getPlotBox() {
	        var a = this.chart,
	            b = this.xAxis,
	            c = this.yAxis;a.inverted && (b = c, c = this.xAxis);return { translateX: b ? b.left : a.plotLeft, translateY: c ? c.top : a.plotTop, scaleX: 1, scaleY: 1 };
	      }, render: function render() {
	        var a = this,
	            b = a.chart,
	            c,
	            k = a.options,
	            h = !!a.animate && b.renderer.isSVG && C(k.animation).duration,
	            g = a.visible ? "inherit" : "hidden",
	            e = k.zIndex,
	            p = a.hasRendered,
	            f = b.seriesGroup,
	            u = b.inverted;c = a.plotGroup("group", "series", g, e, f);a.markerGroup = a.plotGroup("markerGroup", "markers", g, e, f);h && a.animate(!0);c.inverted = a.isCartesian ? u : !1;a.drawGraph && (a.drawGraph(), a.applyZones());a.drawDataLabels && a.drawDataLabels();a.visible && a.drawPoints();a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();a.invertGroups(u);!1 === k.clip || a.sharedClipKey || p || c.clip(b.clipRect);h && a.animate();p || (a.animationTimeout = d(function () {
	          a.afterAnimate();
	        }, h));a.isDirty = !1;a.hasRendered = !0;
	      }, redraw: function redraw() {
	        var a = this.chart,
	            b = this.isDirty || this.isDirtyData,
	            c = this.group,
	            d = this.xAxis,
	            k = this.yAxis;c && (a.inverted && c.attr({ width: a.plotWidth, height: a.plotHeight }), c.animate({ translateX: p(d && d.left, a.plotLeft), translateY: p(k && k.top, a.plotTop) }));this.translate();this.render();b && delete this.kdTree;
	      }, kdAxisArray: ["clientX", "plotY"], searchPoint: function searchPoint(a, b) {
	        var c = this.xAxis,
	            d = this.yAxis,
	            k = this.chart.inverted;return this.searchKDTree({ clientX: k ? c.len - a.chartY + c.pos : a.chartX - c.pos, plotY: k ? d.len - a.chartX + d.pos : a.chartY - d.pos }, b);
	      }, buildKDTree: function buildKDTree() {
	        function a(c, d, g) {
	          var k, m;if (m = c && c.length) return k = b.kdAxisArray[d % g], c.sort(function (a, b) {
	            return a[k] - b[k];
	          }), m = Math.floor(m / 2), { point: c[m], left: a(c.slice(0, m), d + 1, g), right: a(c.slice(m + 1), d + 1, g) };
	        }this.buildingKdTree = !0;var b = this,
	            c = -1 < b.options.findNearestPointBy.indexOf("y") ? 2 : 1;delete b.kdTree;d(function () {
	          b.kdTree = a(b.getValidPoints(null, !b.directTouch), c, c);b.buildingKdTree = !1;
	        }, b.options.kdNow ? 0 : 1);
	      }, searchKDTree: function searchKDTree(a, b) {
	        function c(a, b, h, e) {
	          var p = b.point,
	              f = d.kdAxisArray[h % e],
	              u,
	              t,
	              x = p;t = q(a[k]) && q(p[k]) ? Math.pow(a[k] - p[k], 2) : null;u = q(a[g]) && q(p[g]) ? Math.pow(a[g] - p[g], 2) : null;u = (t || 0) + (u || 0);p.dist = q(u) ? Math.sqrt(u) : Number.MAX_VALUE;p.distX = q(t) ? Math.sqrt(t) : Number.MAX_VALUE;f = a[f] - p[f];u = 0 > f ? "left" : "right";t = 0 > f ? "right" : "left";b[u] && (u = c(a, b[u], h + 1, e), x = u[m] < x[m] ? u : p);b[t] && Math.sqrt(f * f) < x[m] && (a = c(a, b[t], h + 1, e), x = a[m] < x[m] ? a : x);return x;
	        }var d = this,
	            k = this.kdAxisArray[0],
	            g = this.kdAxisArray[1],
	            m = b ? "distX" : "dist";b = -1 < d.options.findNearestPointBy.indexOf("y") ? 2 : 1;this.kdTree || this.buildingKdTree || this.buildKDTree();if (this.kdTree) return c(a, this.kdTree, b, b);
	      } });
	  })(K);(function (a) {
	    function D(a, f, c, e, l) {
	      var b = a.chart.inverted;this.axis = a;this.isNegative = c;this.options = f;this.x = e;this.total = null;this.points = {};this.stack = l;this.rightCliff = this.leftCliff = 0;this.alignOptions = { align: f.align || (b ? c ? "left" : "right" : "center"), verticalAlign: f.verticalAlign || (b ? "middle" : c ? "bottom" : "top"), y: q(f.y, b ? 4 : c ? 14 : -6), x: q(f.x, b ? c ? -6 : 6 : 0) };this.textAlign = f.textAlign || (b ? c ? "right" : "left" : "center");
	    }var C = a.Axis,
	        G = a.Chart,
	        H = a.correctFloat,
	        v = a.defined,
	        l = a.destroyObjectProperties,
	        r = a.each,
	        w = a.format,
	        q = a.pick;a = a.Series;D.prototype = { destroy: function destroy() {
	        l(this, this.axis);
	      }, render: function render(a) {
	        var f = this.options,
	            c = f.format,
	            c = c ? w(c, this) : f.formatter.call(this);this.label ? this.label.attr({ text: c, visibility: "hidden" }) : this.label = this.axis.chart.renderer.text(c, null, null, f.useHTML).css(f.style).attr({ align: this.textAlign,
	          rotation: f.rotation, visibility: "hidden" }).add(a);
	      }, setOffset: function setOffset(a, f) {
	        var c = this.axis,
	            e = c.chart,
	            n = e.inverted,
	            b = c.reversed,
	            b = this.isNegative && !b || !this.isNegative && b,
	            t = c.translate(c.usePercentage ? 100 : this.total, 0, 0, 0, 1),
	            c = c.translate(0),
	            c = Math.abs(t - c);a = e.xAxis[0].translate(this.x) + a;var h = e.plotHeight,
	            n = { x: n ? b ? t : t - c : a, y: n ? h - a - f : b ? h - t - c : h - t, width: n ? c : f, height: n ? f : c };if (f = this.label) f.align(this.alignOptions, null, n), n = f.alignAttr, f[!1 === this.options.crop || e.isInsidePlot(n.x, n.y) ? "show" : "hide"](!0);
	      } };
	    G.prototype.getStacks = function () {
	      var a = this;r(a.yAxis, function (a) {
	        a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);
	      });r(a.series, function (f) {
	        !f.options.stacking || !0 !== f.visible && !1 !== a.options.chart.ignoreHiddenSeries || (f.stackKey = f.type + q(f.options.stack, ""));
	      });
	    };C.prototype.buildStacks = function () {
	      var a = this.series,
	          f,
	          c = q(this.options.reversedStacks, !0),
	          e = a.length,
	          l;if (!this.isXAxis) {
	        this.usePercentage = !1;for (l = e; l--;) {
	          a[c ? l : e - l - 1].setStackedPoints();
	        }for (l = e; l--;) {
	          f = a[c ? l : e - l - 1], f.setStackCliffs && f.setStackCliffs();
	        }if (this.usePercentage) for (l = 0; l < e; l++) {
	          a[l].setPercentStacks();
	        }
	      }
	    };C.prototype.renderStackTotals = function () {
	      var a = this.chart,
	          f = a.renderer,
	          c = this.stacks,
	          e,
	          l,
	          b = this.stackTotalGroup;b || (this.stackTotalGroup = b = f.g("stack-labels").attr({ visibility: "visible", zIndex: 6 }).add());b.translate(a.plotLeft, a.plotTop);for (e in c) {
	        for (l in a = c[e], a) {
	          a[l].render(b);
	        }
	      }
	    };C.prototype.resetStacks = function () {
	      var a = this.stacks,
	          f,
	          c;if (!this.isXAxis) for (f in a) {
	        for (c in a[f]) {
	          a[f][c].touched < this.stacksTouched ? (a[f][c].destroy(), delete a[f][c]) : (a[f][c].total = null, a[f][c].cum = null);
	        }
	      }
	    };C.prototype.cleanStacks = function () {
	      var a, f, c;if (!this.isXAxis) for (f in this.oldStacks && (a = this.stacks = this.oldStacks), a) {
	        for (c in a[f]) {
	          a[f][c].cum = a[f][c].total;
	        }
	      }
	    };a.prototype.setStackedPoints = function () {
	      if (this.options.stacking && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {
	        var a = this.processedXData,
	            f = this.processedYData,
	            c = [],
	            e = f.length,
	            l = this.options,
	            b = l.threshold,
	            t = l.startFromThreshold ? b : 0,
	            h = l.stack,
	            l = l.stacking,
	            r = this.stackKey,
	            p = "-" + r,
	            x = this.negStacks,
	            k = this.yAxis,
	            F = k.stacks,
	            d = k.oldStacks,
	            u,
	            m,
	            y,
	            w,
	            E,
	            I,
	            g;k.stacksTouched += 1;for (E = 0; E < e; E++) {
	          I = a[E], g = f[E], u = this.getStackIndicator(u, I, this.index), w = u.key, y = (m = x && g < (t ? 0 : b)) ? p : r, F[y] || (F[y] = {}), F[y][I] || (d[y] && d[y][I] ? (F[y][I] = d[y][I], F[y][I].total = null) : F[y][I] = new D(k, k.options.stackLabels, m, I, h)), y = F[y][I], null !== g && (y.points[w] = y.points[this.index] = [q(y.cum, t)], v(y.cum) || (y.base = w), y.touched = k.stacksTouched, 0 < u.index && !1 === this.singleStacks && (y.points[w][0] = y.points[this.index + "," + I + ",0"][0])), "percent" === l ? (m = m ? r : p, x && F[m] && F[m][I] ? (m = F[m][I], y.total = m.total = Math.max(m.total, y.total) + Math.abs(g) || 0) : y.total = H(y.total + (Math.abs(g) || 0))) : y.total = H(y.total + (g || 0)), y.cum = q(y.cum, t) + (g || 0), null !== g && (y.points[w].push(y.cum), c[E] = y.cum);
	        }"percent" === l && (k.usePercentage = !0);this.stackedYData = c;k.oldStacks = {};
	      }
	    };a.prototype.setPercentStacks = function () {
	      var a = this,
	          f = a.stackKey,
	          c = a.yAxis.stacks,
	          e = a.processedXData,
	          l;r([f, "-" + f], function (b) {
	        for (var f = e.length, h, n; f--;) {
	          if (h = e[f], l = a.getStackIndicator(l, h, a.index, b), h = (n = c[b] && c[b][h]) && n.points[l.key]) n = n.total ? 100 / n.total : 0, h[0] = H(h[0] * n), h[1] = H(h[1] * n), a.stackedYData[f] = h[1];
	        }
	      });
	    };a.prototype.getStackIndicator = function (a, f, c, e) {
	      !v(a) || a.x !== f || e && a.key !== e ? a = { x: f, index: 0, key: e } : a.index++;a.key = [c, f, a.index].join();return a;
	    };
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.animate,
	        G = a.Axis,
	        H = a.createElement,
	        v = a.css,
	        l = a.defined,
	        r = a.each,
	        w = a.erase,
	        q = a.extend,
	        n = a.fireEvent,
	        f = a.inArray,
	        c = a.isNumber,
	        e = a.isObject,
	        z = a.merge,
	        b = a.pick,
	        t = a.Point,
	        h = a.Series,
	        B = a.seriesTypes,
	        p = a.setAnimation,
	        x = a.splat;q(a.Chart.prototype, { addSeries: function addSeries(a, c, d) {
	        var k,
	            m = this;a && (c = b(c, !0), n(m, "addSeries", { options: a }, function () {
	          k = m.initSeries(a);m.isDirtyLegend = !0;m.linkSeries();c && m.redraw(d);
	        }));return k;
	      }, addAxis: function addAxis(a, c, d, h) {
	        var k = c ? "xAxis" : "yAxis",
	            e = this.options;a = z(a, { index: this[k].length, isX: c });new G(this, a);e[k] = x(e[k] || {});e[k].push(a);b(d, !0) && this.redraw(h);
	      }, showLoading: function showLoading(a) {
	        var b = this,
	            c = b.options,
	            k = b.loadingDiv,
	            m = c.loading,
	            h = function h() {
	          k && v(k, { left: b.plotLeft + "px", top: b.plotTop + "px", width: b.plotWidth + "px", height: b.plotHeight + "px" });
	        };k || (b.loadingDiv = k = H("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, b.container), b.loadingSpan = H("span", { className: "highcharts-loading-inner" }, null, k), D(b, "redraw", h));k.className = "highcharts-loading";b.loadingSpan.innerHTML = a || c.lang.loading;v(k, q(m.style, { zIndex: 10 }));v(b.loadingSpan, m.labelStyle);b.loadingShown || (v(k, { opacity: 0, display: "" }), C(k, { opacity: m.style.opacity || .5 }, { duration: m.showDuration || 0 }));b.loadingShown = !0;h();
	      }, hideLoading: function hideLoading() {
	        var a = this.options,
	            b = this.loadingDiv;b && (b.className = "highcharts-loading highcharts-loading-hidden", C(b, { opacity: 0 }, { duration: a.loading.hideDuration || 100, complete: function complete() {
	            v(b, { display: "none" });
	          } }));this.loadingShown = !1;
	      }, propsRequireDirtyBox: "backgroundColor borderColor borderWidth margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
	      propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions".split(" "), update: function update(a, h) {
	        var d,
	            k = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle" },
	            m = a.chart,
	            e,
	            p;if (m) {
	          z(!0, this.options.chart, m);"className" in m && this.setClassName(m.className);if ("inverted" in m || "polar" in m) this.propFromSeries(), e = !0;"alignTicks" in m && (e = !0);for (d in m) {
	            m.hasOwnProperty(d) && (-1 !== f("chart." + d, this.propsRequireUpdateSeries) && (p = !0), -1 !== f(d, this.propsRequireDirtyBox) && (this.isDirtyBox = !0));
	          }"style" in m && this.renderer.setStyle(m.style);
	        }for (d in a) {
	          if (this[d] && "function" === typeof this[d].update) this[d].update(a[d], !1);else if ("function" === typeof this[k[d]]) this[k[d]](a[d]);"chart" !== d && -1 !== f(d, this.propsRequireUpdateSeries) && (p = !0);
	        }a.colors && (this.options.colors = a.colors);a.plotOptions && z(!0, this.options.plotOptions, a.plotOptions);r(["xAxis", "yAxis", "series", "colorAxis", "pane"], function (b) {
	          a[b] && r(x(a[b]), function (a, c) {
	            (c = l(a.id) && this.get(a.id) || this[b][c]) && c.coll === b && c.update(a, !1);
	          }, this);
	        }, this);e && r(this.axes, function (a) {
	          a.update({}, !1);
	        });p && r(this.series, function (a) {
	          a.update({}, !1);
	        });a.loading && z(!0, this.options.loading, a.loading);d = m && m.width;m = m && m.height;c(d) && d !== this.chartWidth || c(m) && m !== this.chartHeight ? this.setSize(d, m) : b(h, !0) && this.redraw();
	      }, setSubtitle: function setSubtitle(a) {
	        this.setTitle(void 0, a);
	      } });q(t.prototype, { update: function update(a, c, d, h) {
	        function k() {
	          p.applyOptions(a);null === p.y && u && (p.graphic = u.destroy());e(a, !0) && (u && u.element && a && a.marker && a.marker.symbol && (p.graphic = u.destroy()), a && a.dataLabels && p.dataLabel && (p.dataLabel = p.dataLabel.destroy()));x = p.index;f.updateParallelArrays(p, x);t.data[x] = e(t.data[x], !0) || e(a, !0) ? p.options : a;f.isDirty = f.isDirtyData = !0;!f.fixedBox && f.hasCartesianSeries && (g.isDirtyBox = !0);"point" === t.legendType && (g.isDirtyLegend = !0);c && g.redraw(d);
	        }var p = this,
	            f = p.series,
	            u = p.graphic,
	            x,
	            g = f.chart,
	            t = f.options;c = b(c, !0);!1 === h ? k() : p.firePointEvent("update", { options: a }, k);
	      }, remove: function remove(a, b) {
	        this.series.removePoint(f(this, this.series.data), a, b);
	      } });q(h.prototype, { addPoint: function addPoint(a, c, d, h) {
	        var k = this.options,
	            e = this.data,
	            p = this.chart,
	            f = this.xAxis,
	            f = f && f.hasNames && f.names,
	            u = k.data,
	            g,
	            x,
	            t = this.xData,
	            l,
	            n;c = b(c, !0);g = { series: this };this.pointClass.prototype.applyOptions.apply(g, [a]);n = g.x;l = t.length;if (this.requireSorting && n < t[l - 1]) for (x = !0; l && t[l - 1] > n;) {
	          l--;
	        }this.updateParallelArrays(g, "splice", l, 0, 0);this.updateParallelArrays(g, l);f && g.name && (f[n] = g.name);u.splice(l, 0, a);x && (this.data.splice(l, 0, null), this.processData());"point" === k.legendType && this.generatePoints();d && (e[0] && e[0].remove ? e[0].remove(!1) : (e.shift(), this.updateParallelArrays(g, "shift"), u.shift()));this.isDirtyData = this.isDirty = !0;c && p.redraw(h);
	      }, removePoint: function removePoint(a, c, d) {
	        var k = this,
	            m = k.data,
	            h = m[a],
	            e = k.points,
	            f = k.chart,
	            x = function x() {
	          e && e.length === m.length && e.splice(a, 1);m.splice(a, 1);k.options.data.splice(a, 1);k.updateParallelArrays(h || { series: k }, "splice", a, 1);h && h.destroy();k.isDirty = !0;k.isDirtyData = !0;c && f.redraw();
	        };p(d, f);c = b(c, !0);h ? h.firePointEvent("remove", null, x) : x();
	      }, remove: function remove(a, c, d) {
	        function k() {
	          m.destroy();h.isDirtyLegend = h.isDirtyBox = !0;h.linkSeries();b(a, !0) && h.redraw(c);
	        }var m = this,
	            h = m.chart;!1 !== d ? n(m, "remove", null, k) : k();
	      }, update: function update(a, c) {
	        var d = this,
	            k = this.chart,
	            m = this.userOptions,
	            h = this.oldType || this.type,
	            e = a.type || m.type || k.options.chart.type,
	            p = B[h].prototype,
	            f = ["group", "markerGroup", "dataLabelsGroup"],
	            g;if (e && e !== h || void 0 !== a.zIndex) f.length = 0;r(f, function (a) {
	          f[a] = d[a];delete d[a];
	        });a = z(m, { animation: !1, index: this.index, pointStart: this.xData[0] }, { data: this.options.data }, a);this.remove(!1, null, !1);for (g in p) {
	          this[g] = void 0;
	        }q(this, B[e || h].prototype);r(f, function (a) {
	          d[a] = f[a];
	        });this.init(k, a);this.oldType = h;k.linkSeries();b(c, !0) && k.redraw(!1);
	      } });q(G.prototype, { update: function update(a, c) {
	        var d = this.chart;a = d.options[this.coll][this.options.index] = z(this.userOptions, a);this.destroy(!0);this.init(d, q(a, { events: void 0 }));d.isDirtyBox = !0;b(c, !0) && d.redraw();
	      }, remove: function remove(a) {
	        for (var c = this.chart, d = this.coll, k = this.series, m = k.length; m--;) {
	          k[m] && k[m].remove(!1);
	        }w(c.axes, this);w(c[d], this);c.options[d].splice(this.options.index, 1);r(c[d], function (a, b) {
	          a.options.index = b;
	        });this.destroy();c.isDirtyBox = !0;b(a, !0) && c.redraw();
	      }, setTitle: function setTitle(a, b) {
	        this.update({ title: a }, b);
	      }, setCategories: function setCategories(a, b) {
	        this.update({ categories: a }, b);
	      } });
	  })(K);(function (a) {
	    var D = a.color,
	        C = a.each,
	        G = a.map,
	        H = a.pick,
	        v = a.Series,
	        l = a.seriesType;l("area", "line", { softThreshold: !1, threshold: 0 }, { singleStacks: !1, getStackPoints: function getStackPoints() {
	        var a = [],
	            l = [],
	            q = this.xAxis,
	            n = this.yAxis,
	            f = n.stacks[this.stackKey],
	            c = {},
	            e = this.points,
	            z = this.index,
	            b = n.series,
	            t = b.length,
	            h,
	            B = H(n.options.reversedStacks, !0) ? 1 : -1,
	            p,
	            x;if (this.options.stacking) {
	          for (p = 0; p < e.length; p++) {
	            c[e[p].x] = e[p];
	          }for (x in f) {
	            null !== f[x].total && l.push(x);
	          }l.sort(function (a, b) {
	            return a - b;
	          });h = G(b, function () {
	            return this.visible;
	          });C(l, function (b, e) {
	            var d = 0,
	                k,
	                m;if (c[b] && !c[b].isNull) a.push(c[b]), C([-1, 1], function (a) {
	              var d = 1 === a ? "rightNull" : "leftNull",
	                  x = 0,
	                  u = f[l[e + a]];if (u) for (p = z; 0 <= p && p < t;) {
	                k = u.points[p], k || (p === z ? c[b][d] = !0 : h[p] && (m = f[b].points[p]) && (x -= m[1] - m[0])), p += B;
	              }c[b][1 === a ? "rightCliff" : "leftCliff"] = x;
	            });else {
	              for (p = z; 0 <= p && p < t;) {
	                if (k = f[b].points[p]) {
	                  d = k[1];break;
	                }p += B;
	              }d = n.translate(d, 0, 1, 0, 1);a.push({ isNull: !0, plotX: q.translate(b, 0, 0, 0, 1), x: b, plotY: d, yBottom: d });
	            }
	          });
	        }return a;
	      }, getGraphPath: function getGraphPath(a) {
	        var l = v.prototype.getGraphPath,
	            q = this.options,
	            n = q.stacking,
	            f = this.yAxis,
	            c,
	            e,
	            z = [],
	            b = [],
	            t = this.index,
	            h,
	            r = f.stacks[this.stackKey],
	            p = q.threshold,
	            x = f.getThreshold(q.threshold),
	            k,
	            q = q.connectNulls || "percent" === n,
	            F = function F(c, k, m) {
	          var d = a[c];c = n && r[d.x].points[t];
	          var e = d[m + "Null"] || 0;m = d[m + "Cliff"] || 0;var u,
	              l,
	              d = !0;m || e ? (u = (e ? c[0] : c[1]) + m, l = c[0] + m, d = !!e) : !n && a[k] && a[k].isNull && (u = l = p);void 0 !== u && (b.push({ plotX: h, plotY: null === u ? x : f.getThreshold(u), isNull: d, isCliff: !0 }), z.push({ plotX: h, plotY: null === l ? x : f.getThreshold(l), doCurve: !1 }));
	        };a = a || this.points;n && (a = this.getStackPoints());for (c = 0; c < a.length; c++) {
	          if (e = a[c].isNull, h = H(a[c].rectPlotX, a[c].plotX), k = H(a[c].yBottom, x), !e || q) q || F(c, c - 1, "left"), e && !n && q || (b.push(a[c]), z.push({ x: c, plotX: h, plotY: k })), q || F(c, c + 1, "right");
	        }c = l.call(this, b, !0, !0);z.reversed = !0;e = l.call(this, z, !0, !0);e.length && (e[0] = "L");e = c.concat(e);l = l.call(this, b, !1, q);e.xMap = c.xMap;this.areaPath = e;return l;
	      }, drawGraph: function drawGraph() {
	        this.areaPath = [];v.prototype.drawGraph.apply(this);var a = this,
	            l = this.areaPath,
	            q = this.options,
	            n = [["area", "highcharts-area", this.color, q.fillColor]];C(this.zones, function (f, c) {
	          n.push(["zone-area-" + c, "highcharts-area highcharts-zone-area-" + c + " " + f.className, f.color || a.color, f.fillColor || q.fillColor]);
	        });C(n, function (f) {
	          var c = f[0],
	              e = a[c];e ? (e.endX = l.xMap, e.animate({ d: l })) : (e = a[c] = a.chart.renderer.path(l).addClass(f[1]).attr({ fill: H(f[3], D(f[2]).setOpacity(H(q.fillOpacity, .75)).get()), zIndex: 0 }).add(a.group), e.isArea = !0);e.startX = l.xMap;e.shiftUnit = q.step ? 2 : 1;
	        });
	      }, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle });
	  })(K);(function (a) {
	    var D = a.pick;a = a.seriesType;a("spline", "line", {}, { getPointSpline: function getPointSpline(a, G, H) {
	        var v = G.plotX,
	            l = G.plotY,
	            r = a[H - 1];H = a[H + 1];var w, q, n, f;if (r && !r.isNull && !1 !== r.doCurve && !G.isCliff && H && !H.isNull && !1 !== H.doCurve && !G.isCliff) {
	          a = r.plotY;n = H.plotX;H = H.plotY;var c = 0;w = (1.5 * v + r.plotX) / 2.5;q = (1.5 * l + a) / 2.5;n = (1.5 * v + n) / 2.5;f = (1.5 * l + H) / 2.5;n !== w && (c = (f - q) * (n - v) / (n - w) + l - f);q += c;f += c;q > a && q > l ? (q = Math.max(a, l), f = 2 * l - q) : q < a && q < l && (q = Math.min(a, l), f = 2 * l - q);f > H && f > l ? (f = Math.max(H, l), q = 2 * l - f) : f < H && f < l && (f = Math.min(H, l), q = 2 * l - f);G.rightContX = n;G.rightContY = f;
	        }G = ["C", D(r.rightContX, r.plotX), D(r.rightContY, r.plotY), D(w, v), D(q, l), v, l];r.rightContX = r.rightContY = null;return G;
	      } });
	  })(K);(function (a) {
	    var D = a.seriesTypes.area.prototype,
	        C = a.seriesType;C("areaspline", "spline", a.defaultPlotOptions.area, { getStackPoints: D.getStackPoints, getGraphPath: D.getGraphPath, setStackCliffs: D.setStackCliffs, drawGraph: D.drawGraph, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle });
	  })(K);(function (a) {
	    var D = a.animObject,
	        C = a.color,
	        G = a.each,
	        H = a.extend,
	        v = a.isNumber,
	        l = a.merge,
	        r = a.pick,
	        w = a.Series,
	        q = a.seriesType,
	        n = a.svg;q("column", "line", { borderRadius: 0, crisp: !0, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null,
	      states: { hover: { halo: !1, brightness: .1, shadow: !1 }, select: { color: "#cccccc", borderColor: "#000000", shadow: !1 } }, dataLabels: { align: null, verticalAlign: null, y: null }, softThreshold: !1, startFromThreshold: !0, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0, borderColor: "#ffffff" }, { cropShoulder: 0, directTouch: !0, trackerGroups: ["group", "dataLabelsGroup"], negStacks: !0, init: function init() {
	        w.prototype.init.apply(this, arguments);var a = this,
	            c = a.chart;c.hasRendered && G(c.series, function (c) {
	          c.type === a.type && (c.isDirty = !0);
	        });
	      },
	      getColumnMetrics: function getColumnMetrics() {
	        var a = this,
	            c = a.options,
	            e = a.xAxis,
	            l = a.yAxis,
	            b = e.reversed,
	            t,
	            h = {},
	            n = 0;!1 === c.grouping ? n = 1 : G(a.chart.series, function (b) {
	          var c = b.options,
	              k = b.yAxis,
	              m;b.type === a.type && b.visible && l.len === k.len && l.pos === k.pos && (c.stacking ? (t = b.stackKey, void 0 === h[t] && (h[t] = n++), m = h[t]) : !1 !== c.grouping && (m = n++), b.columnIndex = m);
	        });var p = Math.min(Math.abs(e.transA) * (e.ordinalSlope || c.pointRange || e.closestPointRange || e.tickInterval || 1), e.len),
	            x = p * c.groupPadding,
	            k = (p - 2 * x) / (n || 1),
	            c = Math.min(c.maxPointWidth || e.len, r(c.pointWidth, k * (1 - 2 * c.pointPadding)));a.columnMetrics = { width: c, offset: (k - c) / 2 + (x + ((a.columnIndex || 0) + (b ? 1 : 0)) * k - p / 2) * (b ? -1 : 1) };return a.columnMetrics;
	      }, crispCol: function crispCol(a, c, e, l) {
	        var b = this.chart,
	            f = this.borderWidth,
	            h = -(f % 2 ? .5 : 0),
	            f = f % 2 ? .5 : 1;b.inverted && b.renderer.isVML && (f += 1);this.options.crisp && (e = Math.round(a + e) + h, a = Math.round(a) + h, e -= a);l = Math.round(c + l) + f;h = .5 >= Math.abs(c) && .5 < l;c = Math.round(c) + f;l -= c;h && l && (--c, l += 1);return { x: a, y: c, width: e, height: l };
	      }, translate: function translate() {
	        var a = this,
	            c = a.chart,
	            e = a.options,
	            l = a.dense = 2 > a.closestPointRange * a.xAxis.transA,
	            l = a.borderWidth = r(e.borderWidth, l ? 0 : 1),
	            b = a.yAxis,
	            t = a.translatedThreshold = b.getThreshold(e.threshold),
	            h = r(e.minPointLength, 5),
	            n = a.getColumnMetrics(),
	            p = n.width,
	            x = a.barW = Math.max(p, 1 + 2 * l),
	            k = a.pointXOffset = n.offset;c.inverted && (t -= .5);e.pointPadding && (x = Math.ceil(x));w.prototype.translate.apply(a);G(a.points, function (e) {
	          var d = r(e.yBottom, t),
	              f = 999 + Math.abs(d),
	              f = Math.min(Math.max(-f, e.plotY), b.len + f),
	              m = e.plotX + k,
	              l = x,
	              n = Math.min(f, d),
	              E,
	              q = Math.max(f, d) - n;Math.abs(q) < h && h && (q = h, E = !b.reversed && !e.negative || b.reversed && e.negative, n = Math.abs(n - t) > h ? d - h : t - (E ? h : 0));e.barX = m;e.pointWidth = p;e.tooltipPos = c.inverted ? [b.len + b.pos - c.plotLeft - f, a.xAxis.len - m - l / 2, q] : [m + l / 2, f + b.pos - c.plotTop, q];e.shapeType = "rect";e.shapeArgs = a.crispCol.apply(a, e.isNull ? [e.plotX, b.len / 2, 0, 0] : [m, n, l, q]);
	        });
	      }, getSymbol: a.noop, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle, drawGraph: function drawGraph() {
	        this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
	      },
	      pointAttribs: function pointAttribs(a, c) {
	        var e = this.options,
	            f,
	            b = this.pointAttrToOptions || {};f = b.stroke || "borderColor";var t = b["stroke-width"] || "borderWidth",
	            h = a && a.color || this.color,
	            n = a[f] || e[f] || this.color || h,
	            p = a[t] || e[t] || this[t] || 0,
	            b = e.dashStyle;a && this.zones.length && (h = (h = a.getZone()) && h.color || a.options.color || this.color);c && (a = l(e.states[c], a.options.states && a.options.states[c] || {}), c = a.brightness, h = a.color || void 0 !== c && C(h).brighten(a.brightness).get() || h, n = a[f] || n, p = a[t] || p, b = a.dashStyle || b);f = { fill: h,
	          stroke: n, "stroke-width": p };e.borderRadius && (f.r = e.borderRadius);b && (f.dashstyle = b);return f;
	      }, drawPoints: function drawPoints() {
	        var a = this,
	            c = this.chart,
	            e = a.options,
	            n = c.renderer,
	            b = e.animationLimit || 250,
	            t;G(a.points, function (h) {
	          var f = h.graphic;if (v(h.plotY) && null !== h.y) {
	            t = h.shapeArgs;if (f) f[c.pointCount < b ? "animate" : "attr"](l(t));else h.graphic = f = n[h.shapeType](t).add(h.group || a.group);f.attr(a.pointAttribs(h, h.selected && "select")).shadow(e.shadow, null, e.stacking && !e.borderRadius);f.addClass(h.getClassName(), !0);
	          } else f && (h.graphic = f.destroy());
	        });
	      }, animate: function animate(a) {
	        var c = this,
	            e = this.yAxis,
	            f = c.options,
	            b = this.chart.inverted,
	            t = {};n && (a ? (t.scaleY = .001, a = Math.min(e.pos + e.len, Math.max(e.pos, e.toPixels(f.threshold))), b ? t.translateX = a - e.len : t.translateY = a, c.group.attr(t)) : (t[b ? "translateX" : "translateY"] = e.pos, c.group.animate(t, H(D(c.options.animation), { step: function step(a, b) {
	            c.group.attr({ scaleY: Math.max(.001, b.pos) });
	          } })), c.animate = null));
	      }, remove: function remove() {
	        var a = this,
	            c = a.chart;c.hasRendered && G(c.series, function (c) {
	          c.type === a.type && (c.isDirty = !0);
	        });w.prototype.remove.apply(a, arguments);
	      } });
	  })(K);(function (a) {
	    a = a.seriesType;a("bar", "column", null, { inverted: !0 });
	  })(K);(function (a) {
	    var D = a.Series;a = a.seriesType;a("scatter", "line", { lineWidth: 0, findNearestPointBy: "xy", marker: { enabled: !0 }, tooltip: { headerFormat: "<span style=\"color:{point.color}\">\u25CF</span> <span style=\"font-size: 0.85em\"> {series.name}</span><br/>", pointFormat: "x: \x3cb\x3e{point.x}\x3c/b\x3e\x3cbr/\x3ey: \x3cb\x3e{point.y}\x3c/b\x3e\x3cbr/\x3e" } }, { sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], takeOrdinalPosition: !1, drawGraph: function drawGraph() {
	        this.options.lineWidth && D.prototype.drawGraph.call(this);
	      } });
	  })(K);(function (a) {
	    var D = a.pick,
	        C = a.relativeLength;a.CenteredSeriesMixin = { getCenter: function getCenter() {
	        var a = this.options,
	            H = this.chart,
	            v = 2 * (a.slicedOffset || 0),
	            l = H.plotWidth - 2 * v,
	            H = H.plotHeight - 2 * v,
	            r = a.center,
	            r = [D(r[0], "50%"), D(r[1], "50%"), a.size || "100%", a.innerSize || 0],
	            w = Math.min(l, H),
	            q,
	            n;for (q = 0; 4 > q; ++q) {
	          n = r[q], a = 2 > q || 2 === q && /%$/.test(n), r[q] = C(n, [l, H, w, r[2]][q]) + (a ? v : 0);
	        }r[3] > r[2] && (r[3] = r[2]);return r;
	      } };
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.defined,
	        G = a.each,
	        H = a.extend,
	        v = a.inArray,
	        l = a.noop,
	        r = a.pick,
	        w = a.Point,
	        q = a.Series,
	        n = a.seriesType,
	        f = a.setAnimation;n("pie", "line", { center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { distance: 30, enabled: !0, formatter: function formatter() {
	          return null === this.y ? void 0 : this.point.name;
	        }, x: 0 }, ignoreHiddenPoint: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10,
	      stickyTracking: !1, tooltip: { followPointer: !0 }, borderColor: "#ffffff", borderWidth: 1, states: { hover: { brightness: .1, shadow: !1 } } }, { isCartesian: !1, requireSorting: !1, directTouch: !0, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], axisTypes: [], pointAttribs: a.seriesTypes.column.prototype.pointAttribs, animate: function animate(a) {
	        var c = this,
	            f = c.points,
	            b = c.startAngleRad;a || (G(f, function (a) {
	          var h = a.graphic,
	              e = a.shapeArgs;h && (h.attr({ r: a.startR || c.center[3] / 2, start: b, end: b }), h.animate({ r: e.r, start: e.start, end: e.end }, c.options.animation));
	        }), c.animate = null);
	      }, updateTotals: function updateTotals() {
	        var a,
	            e = 0,
	            f = this.points,
	            b = f.length,
	            t,
	            h = this.options.ignoreHiddenPoint;for (a = 0; a < b; a++) {
	          t = f[a], 0 > t.y && (t.y = null), e += h && !t.visible ? 0 : t.y;
	        }this.total = e;for (a = 0; a < b; a++) {
	          t = f[a], t.percentage = 0 < e && (t.visible || !h) ? t.y / e * 100 : 0, t.total = e;
	        }
	      }, generatePoints: function generatePoints() {
	        q.prototype.generatePoints.call(this);this.updateTotals();
	      }, translate: function translate(a) {
	        this.generatePoints();var c = 0,
	            f = this.options,
	            b = f.slicedOffset,
	            t = b + (f.borderWidth || 0),
	            h,
	            l,
	            p,
	            x = f.startAngle || 0,
	            k = this.startAngleRad = Math.PI / 180 * (x - 90),
	            x = (this.endAngleRad = Math.PI / 180 * (r(f.endAngle, x + 360) - 90)) - k,
	            n = this.points,
	            d = f.dataLabels.distance,
	            f = f.ignoreHiddenPoint,
	            u,
	            m = n.length,
	            y;a || (this.center = a = this.getCenter());this.getX = function (b, c) {
	          p = Math.asin(Math.min((b - a[1]) / (a[2] / 2 + d), 1));return a[0] + (c ? -1 : 1) * Math.cos(p) * (a[2] / 2 + d);
	        };for (u = 0; u < m; u++) {
	          y = n[u];h = k + c * x;if (!f || y.visible) c += y.percentage / 100;l = k + c * x;y.shapeType = "arc";y.shapeArgs = { x: a[0], y: a[1], r: a[2] / 2, innerR: a[3] / 2, start: Math.round(1E3 * h) / 1E3, end: Math.round(1E3 * l) / 1E3 };p = (l + h) / 2;p > 1.5 * Math.PI ? p -= 2 * Math.PI : p < -Math.PI / 2 && (p += 2 * Math.PI);y.slicedTranslation = { translateX: Math.round(Math.cos(p) * b), translateY: Math.round(Math.sin(p) * b) };h = Math.cos(p) * a[2] / 2;l = Math.sin(p) * a[2] / 2;y.tooltipPos = [a[0] + .7 * h, a[1] + .7 * l];y.half = p < -Math.PI / 2 || p > Math.PI / 2 ? 1 : 0;y.angle = p;t = Math.min(t, d / 5);y.labelPos = [a[0] + h + Math.cos(p) * d, a[1] + l + Math.sin(p) * d, a[0] + h + Math.cos(p) * t, a[1] + l + Math.sin(p) * t, a[0] + h, a[1] + l, 0 > d ? "center" : y.half ? "right" : "left", p];
	        }
	      }, drawGraph: null, drawPoints: function drawPoints() {
	        var a = this,
	            e = a.chart.renderer,
	            f,
	            b,
	            t,
	            h,
	            l = a.options.shadow;l && !a.shadowGroup && (a.shadowGroup = e.g("shadow").add(a.group));G(a.points, function (c) {
	          if (null !== c.y) {
	            b = c.graphic;h = c.shapeArgs;f = c.getTranslate();var p = c.shadowGroup;l && !p && (p = c.shadowGroup = e.g("shadow").add(a.shadowGroup));p && p.attr(f);t = a.pointAttribs(c, c.selected && "select");b ? b.setRadialReference(a.center).attr(t).animate(H(h, f)) : (c.graphic = b = e[c.shapeType](h).setRadialReference(a.center).attr(f).add(a.group), c.visible || b.attr({ visibility: "hidden" }), b.attr(t).attr({ "stroke-linejoin": "round" }).shadow(l, p));b.addClass(c.getClassName());
	          }
	        });
	      }, searchPoint: l, sortByAngle: function sortByAngle(a, e) {
	        a.sort(function (a, b) {
	          return void 0 !== a.angle && (b.angle - a.angle) * e;
	        });
	      }, drawLegendSymbol: a.LegendSymbolMixin.drawRectangle, getCenter: a.CenteredSeriesMixin.getCenter, getSymbol: l }, { init: function init() {
	        w.prototype.init.apply(this, arguments);var a = this,
	            e;a.name = r(a.name, "Slice");e = function e(c) {
	          a.slice("select" === c.type);
	        };D(a, "select", e);D(a, "unselect", e);return a;
	      }, setVisible: function setVisible(a, e) {
	        var c = this,
	            b = c.series,
	            f = b.chart,
	            h = b.options.ignoreHiddenPoint;e = r(e, h);a !== c.visible && (c.visible = c.options.visible = a = void 0 === a ? !c.visible : a, b.options.data[v(c, b.data)] = c.options, G(["graphic", "dataLabel", "connector", "shadowGroup"], function (b) {
	          if (c[b]) c[b][a ? "show" : "hide"](!0);
	        }), c.legendItem && f.legend.colorizeItem(c, a), a || "hover" !== c.state || c.setState(""), h && (b.isDirty = !0), e && f.redraw());
	      }, slice: function slice(a, e, l) {
	        var b = this.series;f(l, b.chart);r(e, !0);this.sliced = this.options.sliced = C(a) ? a : !this.sliced;
	        b.options.data[v(this, b.data)] = this.options;this.graphic.animate(this.getTranslate());this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
	      }, getTranslate: function getTranslate() {
	        return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 };
	      }, haloPath: function haloPath(a) {
	        var c = this.shapeArgs;return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a, c.r + a, { innerR: this.shapeArgs.r, start: c.start, end: c.end });
	      } });
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.arrayMax,
	        G = a.defined,
	        H = a.each,
	        v = a.extend,
	        l = a.format,
	        r = a.map,
	        w = a.merge,
	        q = a.noop,
	        n = a.pick,
	        f = a.relativeLength,
	        c = a.Series,
	        e = a.seriesTypes,
	        z = a.stableSort;a.distribute = function (a, c) {
	      function b(a, b) {
	        return a.target - b.target;
	      }var e,
	          p = !0,
	          f = a,
	          k = [],
	          l;l = 0;for (e = a.length; e--;) {
	        l += a[e].size;
	      }if (l > c) {
	        z(a, function (a, b) {
	          return (b.rank || 0) - (a.rank || 0);
	        });for (l = e = 0; l <= c;) {
	          l += a[e].size, e++;
	        }k = a.splice(e - 1, a.length);
	      }z(a, b);for (a = r(a, function (a) {
	        return { size: a.size, targets: [a.target] };
	      }); p;) {
	        for (e = a.length; e--;) {
	          p = a[e], l = (Math.min.apply(0, p.targets) + Math.max.apply(0, p.targets)) / 2, p.pos = Math.min(Math.max(0, l - p.size / 2), c - p.size);
	        }e = a.length;for (p = !1; e--;) {
	          0 < e && a[e - 1].pos + a[e - 1].size > a[e].pos && (a[e - 1].size += a[e].size, a[e - 1].targets = a[e - 1].targets.concat(a[e].targets), a[e - 1].pos + a[e - 1].size > c && (a[e - 1].pos = c - a[e - 1].size), a.splice(e, 1), p = !0);
	        }
	      }e = 0;H(a, function (a) {
	        var b = 0;H(a.targets, function () {
	          f[e].pos = a.pos + b;b += f[e].size;e++;
	        });
	      });f.push.apply(f, k);z(f, b);
	    };c.prototype.drawDataLabels = function () {
	      var a = this,
	          c = a.options,
	          h = c.dataLabels,
	          e = a.points,
	          p,
	          f,
	          k = a.hasRendered || 0,
	          q,
	          d,
	          u = n(h.defer, !0),
	          m = a.chart.renderer;if (h.enabled || a._hasPointLabels) a.dlProcessOptions && a.dlProcessOptions(h), d = a.plotGroup("dataLabelsGroup", "data-labels", u && !k ? "hidden" : "visible", h.zIndex || 6), u && (d.attr({ opacity: +k }), k || D(a, "afterAnimate", function () {
	        a.visible && d.show(!0);d[c.animation ? "animate" : "attr"]({ opacity: 1 }, { duration: 200 });
	      })), f = h, H(e, function (b) {
	        var k,
	            e = b.dataLabel,
	            x,
	            g,
	            t,
	            u = b.connector,
	            y = !e,
	            r;p = b.dlOptions || b.options && b.options.dataLabels;if (k = n(p && p.enabled, f.enabled) && null !== b.y) for (g in h = w(f, p), x = b.getLabelConfig(), q = h.format ? l(h.format, x) : h.formatter.call(x, h), r = h.style, t = h.rotation, r.color = n(h.color, r.color, a.color, "#000000"), "contrast" === r.color && (b.contrastColor = m.getContrast(b.color || a.color), r.color = h.inside || 0 > h.distance || c.stacking ? b.contrastColor : "#000000"), c.cursor && (r.cursor = c.cursor), x = { fill: h.backgroundColor, stroke: h.borderColor, "stroke-width": h.borderWidth, r: h.borderRadius || 0, rotation: t, padding: h.padding, zIndex: 1 }, x) {
	          void 0 === x[g] && delete x[g];
	        }!e || k && G(q) ? k && G(q) && (e ? x.text = q : (e = b.dataLabel = m[t ? "text" : "label"](q, 0, -9999, h.shape, null, null, h.useHTML, null, "data-label"), e.addClass("highcharts-data-label-color-" + b.colorIndex + " " + (h.className || "") + (h.useHTML ? "highcharts-tracker" : ""))), e.attr(x), e.css(r).shadow(h.shadow), e.added || e.add(d), a.alignDataLabel(b, e, h, null, y)) : (b.dataLabel = e.destroy(), u && (b.connector = u.destroy()));
	      });
	    };c.prototype.alignDataLabel = function (a, c, h, e, p) {
	      var b = this.chart,
	          k = b.inverted,
	          f = n(a.plotX, -9999),
	          d = n(a.plotY, -9999),
	          l = c.getBBox(),
	          m,
	          t = h.rotation,
	          q = h.align,
	          E = this.visible && (a.series.forceDL || b.isInsidePlot(f, Math.round(d), k) || e && b.isInsidePlot(f, k ? e.x + 1 : e.y + e.height - 1, k)),
	          r = "justify" === n(h.overflow, "justify");E && (m = h.style.fontSize, m = b.renderer.fontMetrics(m, c).b, e = v({ x: k ? b.plotWidth - d : f, y: Math.round(k ? b.plotHeight - f : d), width: 0, height: 0 }, e), v(h, { width: l.width, height: l.height }), t ? (r = !1, k = b.renderer.rotCorr(m, t), k = { x: e.x + h.x + e.width / 2 + k.x, y: e.y + h.y + { top: 0, middle: .5, bottom: 1 }[h.verticalAlign] * e.height }, c[p ? "attr" : "animate"](k).attr({ align: q }), f = (t + 720) % 360, f = 180 < f && 360 > f, "left" === q ? k.y -= f ? l.height : 0 : "center" === q ? (k.x -= l.width / 2, k.y -= l.height / 2) : "right" === q && (k.x -= l.width, k.y -= f ? 0 : l.height)) : (c.align(h, null, e), k = c.alignAttr), r ? a.isLabelJustified = this.justifyDataLabel(c, h, k, l, e, p) : n(h.crop, !0) && (E = b.isInsidePlot(k.x, k.y) && b.isInsidePlot(k.x + l.width, k.y + l.height)), h.shape && !t && c.attr({ anchorX: a.plotX, anchorY: a.plotY }));E || (c.attr({ y: -9999 }), c.placed = !1);
	    };c.prototype.justifyDataLabel = function (a, c, e, f, p, l) {
	      var b = this.chart,
	          h = c.align,
	          d = c.verticalAlign,
	          x,
	          m,
	          t = a.box ? 0 : a.padding || 0;x = e.x + t;0 > x && ("right" === h ? c.align = "left" : c.x = -x, m = !0);x = e.x + f.width - t;x > b.plotWidth && ("left" === h ? c.align = "right" : c.x = b.plotWidth - x, m = !0);x = e.y + t;0 > x && ("bottom" === d ? c.verticalAlign = "top" : c.y = -x, m = !0);x = e.y + f.height - t;x > b.plotHeight && ("top" === d ? c.verticalAlign = "bottom" : c.y = b.plotHeight - x, m = !0);m && (a.placed = !l, a.align(c, null, p));return m;
	    };e.pie && (e.pie.prototype.drawDataLabels = function () {
	      var b = this,
	          e = b.data,
	          h,
	          f = b.chart,
	          p = b.options.dataLabels,
	          x = n(p.connectorPadding, 10),
	          k = n(p.connectorWidth, 1),
	          l = f.plotWidth,
	          d = f.plotHeight,
	          u,
	          m = p.distance,
	          y = b.center,
	          q = y[2] / 2,
	          E = y[1],
	          z = 0 < m,
	          g,
	          v,
	          w,
	          D,
	          M = [[], []],
	          G,
	          A,
	          Q,
	          S,
	          N = [0, 0, 0, 0];b.visible && (p.enabled || b._hasPointLabels) && (H(e, function (a) {
	        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), a.dataLabel.shortened = !1);
	      }), c.prototype.drawDataLabels.apply(b), H(e, function (a) {
	        a.dataLabel && a.visible && (M[a.half].push(a), a.dataLabel._pos = null);
	      }), H(M, function (c, k) {
	        var e,
	            t,
	            u = c.length,
	            n,
	            z,
	            I;if (u) for (b.sortByAngle(c, k - .5), 0 < m && (e = Math.max(0, E - q - m), t = Math.min(E + q + m, f.plotHeight), n = r(c, function (a) {
	          if (a.dataLabel) return I = a.dataLabel.getBBox().height || 21, { target: a.labelPos[1] - e + I / 2, size: I, rank: a.y };
	        }), a.distribute(n, t + I - e)), S = 0; S < u; S++) {
	          h = c[S], w = h.labelPos, g = h.dataLabel, Q = !1 === h.visible ? "hidden" : "inherit", z = w[1], n ? void 0 === n[S].pos ? Q = "hidden" : (D = n[S].size, A = e + n[S].pos) : A = z, G = p.justify ? y[0] + (k ? -1 : 1) * (q + m) : b.getX(A < e + 2 || A > t - 2 ? z : A, k), g._attr = { visibility: Q, align: w[6] }, g._pos = { x: G + p.x + ({ left: x, right: -x }[w[6]] || 0), y: A + p.y - 10 }, w.x = G, w.y = A, null === b.options.size && (v = g.getBBox().width, z = null, G - v < x ? (z = Math.round(v - G + x), N[3] = Math.max(z, N[3])) : G + v > l - x && (z = Math.round(G + v - l + x), N[1] = Math.max(z, N[1])), 0 > A - D / 2 ? N[0] = Math.max(Math.round(-A + D / 2), N[0]) : A + D / 2 > d && (N[2] = Math.max(Math.round(A + D / 2 - d), N[2])), g.sideOverflow = z);
	        }
	      }), 0 === C(N) || this.verifyDataLabelOverflow(N)) && (this.placeDataLabels(), z && k && H(this.points, function (a) {
	        var c;u = a.connector;if ((g = a.dataLabel) && g._pos && a.visible) {
	          Q = g._attr.visibility;if (c = !u) a.connector = u = f.renderer.path().addClass("highcharts-data-label-connector highcharts-color-" + a.colorIndex).add(b.dataLabelsGroup), u.attr({ "stroke-width": k, stroke: p.connectorColor || a.color || "#666666" });u[c ? "attr" : "animate"]({ d: b.connectorPath(a.labelPos) });u.attr("visibility", Q);
	        } else u && (a.connector = u.destroy());
	      }));
	    }, e.pie.prototype.connectorPath = function (a) {
	      var b = a.x,
	          c = a.y;return n(this.options.dataLabels.softConnector, !0) ? ["M", b + ("left" === a[6] ? 5 : -5), c, "C", b, c, 2 * a[2] - a[4], 2 * a[3] - a[5], a[2], a[3], "L", a[4], a[5]] : ["M", b + ("left" === a[6] ? 5 : -5), c, "L", a[2], a[3], "L", a[4], a[5]];
	    }, e.pie.prototype.placeDataLabels = function () {
	      H(this.points, function (a) {
	        var b = a.dataLabel;b && a.visible && ((a = b._pos) ? (b.sideOverflow && (b._attr.width = b.getBBox().width - b.sideOverflow, b.css({ width: b._attr.width + "px", textOverflow: "ellipsis" }), b.shortened = !0), b.attr(b._attr), b[b.moved ? "animate" : "attr"](a), b.moved = !0) : b && b.attr({ y: -9999 }));
	      }, this);
	    }, e.pie.prototype.alignDataLabel = q, e.pie.prototype.verifyDataLabelOverflow = function (a) {
	      var b = this.center,
	          c = this.options,
	          e = c.center,
	          p = c.minSize || 80,
	          l,
	          k;null !== e[0] ? l = Math.max(b[2] - Math.max(a[1], a[3]), p) : (l = Math.max(b[2] - a[1] - a[3], p), b[0] += (a[3] - a[1]) / 2);null !== e[1] ? l = Math.max(Math.min(l, b[2] - Math.max(a[0], a[2])), p) : (l = Math.max(Math.min(l, b[2] - a[0] - a[2]), p), b[1] += (a[0] - a[2]) / 2);l < b[2] ? (b[2] = l, b[3] = Math.min(f(c.innerSize || 0, l), l), this.translate(b), this.drawDataLabels && this.drawDataLabels()) : k = !0;return k;
	    });e.column && (e.column.prototype.alignDataLabel = function (a, e, h, f, p) {
	      var b = this.chart.inverted,
	          k = a.series,
	          l = a.dlBox || a.shapeArgs,
	          d = n(a.below, a.plotY > n(this.translatedThreshold, k.yAxis.len)),
	          u = n(h.inside, !!this.options.stacking);l && (f = w(l), 0 > f.y && (f.height += f.y, f.y = 0), l = f.y + f.height - k.yAxis.len, 0 < l && (f.height -= l), b && (f = { x: k.yAxis.len - f.y - f.height, y: k.xAxis.len - f.x - f.width, width: f.height, height: f.width }), u || (b ? (f.x += d ? 0 : f.width, f.width = 0) : (f.y += d ? f.height : 0, f.height = 0)));h.align = n(h.align, !b || u ? "center" : d ? "right" : "left");h.verticalAlign = n(h.verticalAlign, b || u ? "middle" : d ? "top" : "bottom");c.prototype.alignDataLabel.call(this, a, e, h, f, p);a.isLabelJustified && a.contrastColor && a.dataLabel.css({ color: a.contrastColor });
	    });
	  })(K);
	  (function (a) {
	    var D = a.Chart,
	        C = a.each,
	        G = a.pick,
	        H = a.addEvent;D.prototype.callbacks.push(function (a) {
	      function l() {
	        var l = [];C(a.series || [], function (a) {
	          var q = a.options.dataLabels,
	              n = a.dataLabelCollections || ["dataLabel"];(q.enabled || a._hasPointLabels) && !q.allowOverlap && a.visible && C(n, function (f) {
	            C(a.points, function (a) {
	              a[f] && (a[f].labelrank = G(a.labelrank, a.shapeArgs && a.shapeArgs.height), l.push(a[f]));
	            });
	          });
	        });a.hideOverlappingLabels(l);
	      }l();H(a, "redraw", l);
	    });D.prototype.hideOverlappingLabels = function (a) {
	      var l = a.length,
	          r,
	          w,
	          q,
	          n,
	          f,
	          c,
	          e,
	          z,
	          b,
	          t = function t(a, b, c, e, k, f, d, l) {
	        return !(k > a + c || k + d < a || f > b + e || f + l < b);
	      };for (w = 0; w < l; w++) {
	        if (r = a[w]) r.oldOpacity = r.opacity, r.newOpacity = 1;
	      }a.sort(function (a, b) {
	        return (b.labelrank || 0) - (a.labelrank || 0);
	      });for (w = 0; w < l; w++) {
	        for (q = a[w], r = w + 1; r < l; ++r) {
	          if (n = a[r], q && n && q !== n && q.placed && n.placed && 0 !== q.newOpacity && 0 !== n.newOpacity && (f = q.alignAttr, c = n.alignAttr, e = q.parentGroup, z = n.parentGroup, b = 2 * (q.box ? 0 : q.padding), f = t(f.x + e.translateX, f.y + e.translateY, q.width - b, q.height - b, c.x + z.translateX, c.y + z.translateY, n.width - b, n.height - b))) (q.labelrank < n.labelrank ? q : n).newOpacity = 0;
	        }
	      }C(a, function (a) {
	        var b, c;a && (c = a.newOpacity, a.oldOpacity !== c && a.placed && (c ? a.show(!0) : b = function b() {
	          a.hide();
	        }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b)), a.isOld = !0);
	      });
	    };
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.Chart,
	        G = a.createElement,
	        H = a.css,
	        v = a.defaultOptions,
	        l = a.defaultPlotOptions,
	        r = a.each,
	        w = a.extend,
	        q = a.fireEvent,
	        n = a.hasTouch,
	        f = a.inArray,
	        c = a.isObject,
	        e = a.Legend,
	        z = a.merge,
	        b = a.pick,
	        t = a.Point,
	        h = a.Series,
	        B = a.seriesTypes,
	        p = a.svg;a = a.TrackerMixin = { drawTrackerPoint: function drawTrackerPoint() {
	        var a = this,
	            b = a.chart.pointer,
	            c = function c(a) {
	          var c = b.getPointFromEvent(a);if (void 0 !== c) c.onMouseOver(a);
	        };r(a.points, function (a) {
	          a.graphic && (a.graphic.element.point = a);a.dataLabel && (a.dataLabel.div ? a.dataLabel.div.point = a : a.dataLabel.element.point = a);
	        });a._hasTracking || (r(a.trackerGroups, function (d) {
	          if (a[d]) {
	            a[d].addClass("highcharts-tracker").on("mouseover", c).on("mouseout", function (a) {
	              b.onTrackerMouseOut(a);
	            });if (n) a[d].on("touchstart", c);a.options.cursor && a[d].css(H).css({ cursor: a.options.cursor });
	          }
	        }), a._hasTracking = !0);
	      }, drawTrackerGraph: function drawTrackerGraph() {
	        var a = this,
	            b = a.options,
	            c = b.trackByArea,
	            d = [].concat(c ? a.areaPath : a.graphPath),
	            e = d.length,
	            m = a.chart,
	            h = m.pointer,
	            f = m.renderer,
	            l = m.options.tooltip.snap,
	            t = a.tracker,
	            g,
	            q = function q() {
	          if (m.hoverSeries !== a) a.onMouseOver();
	        },
	            z = "rgba(192,192,192," + (p ? .0001 : .002) + ")";if (e && !c) for (g = e + 1; g--;) {
	          "M" === d[g] && d.splice(g + 1, 0, d[g + 1] - l, d[g + 2], "L"), (g && "M" === d[g] || g === e) && d.splice(g, 0, "L", d[g - 2] + l, d[g - 1]);
	        }t ? t.attr({ d: d }) : a.graph && (a.tracker = f.path(d).attr({ "stroke-linejoin": "round", visibility: a.visible ? "visible" : "hidden", stroke: z, fill: c ? z : "none", "stroke-width": a.graph.strokeWidth() + (c ? 0 : 2 * l), zIndex: 2 }).add(a.group), r([a.tracker, a.markerGroup], function (a) {
	          a.addClass("highcharts-tracker").on("mouseover", q).on("mouseout", function (a) {
	            h.onTrackerMouseOut(a);
	          });b.cursor && a.css({ cursor: b.cursor });if (n) a.on("touchstart", q);
	        }));
	      } };B.column && (B.column.prototype.drawTracker = a.drawTrackerPoint);B.pie && (B.pie.prototype.drawTracker = a.drawTrackerPoint);B.scatter && (B.scatter.prototype.drawTracker = a.drawTrackerPoint);w(e.prototype, { setItemEvents: function setItemEvents(a, b, c) {
	        var d = this,
	            k = d.chart.renderer.boxWrapper,
	            e = "highcharts-legend-" + (a.series ? "point" : "series") + "-active";(c ? b : a.legendGroup).on("mouseover", function () {
	          a.setState("hover");k.addClass(e);b.css(d.options.itemHoverStyle);
	        }).on("mouseout", function () {
	          b.css(a.visible ? d.itemStyle : d.itemHiddenStyle);k.removeClass(e);a.setState();
	        }).on("click", function (b) {
	          var c = function c() {
	            a.setVisible && a.setVisible();
	          };b = { browserEvent: b };a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : q(a, "legendItemClick", b, c);
	        });
	      }, createCheckboxForItem: function createCheckboxForItem(a) {
	        a.checkbox = G("input", { type: "checkbox", checked: a.selected, defaultChecked: a.selected }, this.options.itemCheckboxStyle, this.chart.container);D(a.checkbox, "click", function (b) {
	          q(a.series || a, "checkboxClick", { checked: b.target.checked, item: a }, function () {
	            a.select();
	          });
	        });
	      } });v.legend.itemStyle.cursor = "pointer";w(C.prototype, { showResetZoom: function showResetZoom() {
	        var a = this,
	            b = v.lang,
	            c = a.options.chart.resetZoomButton,
	            d = c.theme,
	            e = d.states,
	            m = "chart" === c.relativeTo ? null : "plotBox";this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function () {
	          a.zoomOut();
	        }, d, e && e.hover).attr({ align: c.position.align, title: b.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(c.position, !1, m);
	      }, zoomOut: function zoomOut() {
	        var a = this;q(a, "selection", { resetSelection: !0 }, function () {
	          a.zoom();
	        });
	      }, zoom: function zoom(a) {
	        var k,
	            e = this.pointer,
	            d = !1,
	            h;!a || a.resetSelection ? r(this.axes, function (a) {
	          k = a.zoom();
	        }) : r(a.xAxis.concat(a.yAxis), function (a) {
	          var b = a.axis;e[b.isXAxis ? "zoomX" : "zoomY"] && (k = b.zoom(a.min, a.max), b.displayBtn && (d = !0));
	        });h = this.resetZoomButton;d && !h ? this.showResetZoom() : !d && c(h) && (this.resetZoomButton = h.destroy());k && this.redraw(b(this.options.chart.animation, a && a.animation, 100 > this.pointCount));
	      }, pan: function pan(a, b) {
	        var c = this,
	            d = c.hoverPoints,
	            k;d && r(d, function (a) {
	          a.setState();
	        });r("xy" === b ? [1, 0] : [1], function (b) {
	          b = c[b ? "xAxis" : "yAxis"][0];var d = b.horiz,
	              e = a[d ? "chartX" : "chartY"],
	              d = d ? "mouseDownX" : "mouseDownY",
	              m = c[d],
	              h = (b.pointRange || 0) / 2,
	              g = b.getExtremes(),
	              f = b.toValue(m - e, !0) + h,
	              h = b.toValue(m + b.len - e, !0) - h,
	              p = h < f,
	              m = p ? h : f,
	              f = p ? f : h,
	              p = b.toValue(b.toPixels(g.min) - b.minPixelPadding),
	              h = b.toValue(b.toPixels(g.max) + b.minPixelPadding),
	              p = Math.min(g.dataMin, p) - m,
	              g = f - Math.max(g.dataMax, h);b.series.length && 0 > p && 0 > g && (b.setExtremes(m, f, !1, !1, { trigger: "pan" }), k = !0);c[d] = e;
	        });k && c.redraw(!1);H(c.container, { cursor: "move" });
	      } });w(t.prototype, { select: function select(a, c) {
	        var k = this,
	            d = k.series,
	            e = d.chart;a = b(a, !k.selected);k.firePointEvent(a ? "select" : "unselect", { accumulate: c }, function () {
	          k.selected = k.options.selected = a;d.options.data[f(k, d.data)] = k.options;k.setState(a && "select");c || r(e.getSelectedPoints(), function (a) {
	            a.selected && a !== k && (a.selected = a.options.selected = !1, d.options.data[f(a, d.data)] = a.options, a.setState(""), a.firePointEvent("unselect"));
	          });
	        });
	      }, onMouseOver: function onMouseOver(a) {
	        var b = this.series.chart.pointer;this.firePointEvent("mouseOver");b.runPointActions(a, this);
	      }, onMouseOut: function onMouseOut() {
	        var a = this.series.chart;
	        this.firePointEvent("mouseOut");r(a.hoverPoints || [], function (a) {
	          a.setState();
	        });a.hoverPoints = a.hoverPoint = null;
	      }, importEvents: function importEvents() {
	        if (!this.hasImportedEvents) {
	          var a = z(this.series.options.point, this.options).events,
	              b;this.events = a;for (b in a) {
	            D(this, b, a[b]);
	          }this.hasImportedEvents = !0;
	        }
	      }, setState: function setState(a, c) {
	        var k = Math.floor(this.plotX),
	            d = this.plotY,
	            e = this.series,
	            h = e.options.states[a] || {},
	            f = l[e.type].marker && e.options.marker,
	            p = f && !1 === f.enabled,
	            t = f && f.states && f.states[a] || {},
	            n = !1 === t.enabled,
	            g = e.stateMarkerGraphic,
	            x = this.marker || {},
	            q = e.chart,
	            r = e.halo,
	            z,
	            v = f && e.markerAttribs;a = a || "";if (!(a === this.state && !c || this.selected && "select" !== a || !1 === h.enabled || a && (n || p && !1 === t.enabled) || a && x.states && x.states[a] && !1 === x.states[a].enabled)) {
	          v && (z = e.markerAttribs(this, a));if (this.graphic) this.state && this.graphic.removeClass("highcharts-point-" + this.state), a && this.graphic.addClass("highcharts-point-" + a), this.graphic.attr(e.pointAttribs(this, a)), z && this.graphic.animate(z, b(q.options.chart.animation, t.animation, f.animation)), g && g.hide();else {
	            if (a && t) {
	              f = x.symbol || e.symbol;g && g.currentSymbol !== f && (g = g.destroy());if (g) g[c ? "animate" : "attr"]({ x: z.x, y: z.y });else f && (e.stateMarkerGraphic = g = q.renderer.symbol(f, z.x, z.y, z.width, z.height).add(e.markerGroup), g.currentSymbol = f);g && g.attr(e.pointAttribs(this, a));
	            }g && (g[a && q.isInsidePlot(k, d, q.inverted) ? "show" : "hide"](), g.element.point = this);
	          }(k = h.halo) && k.size ? (r || (e.halo = r = q.renderer.path().add(v ? e.markerGroup : e.group)), r[c ? "animate" : "attr"]({ d: this.haloPath(k.size) }), r.attr({ "class": "highcharts-halo highcharts-color-" + b(this.colorIndex, e.colorIndex) }), r.point = this, r.attr(w({ fill: this.color || e.color, "fill-opacity": k.opacity, zIndex: -1 }, k.attributes))) : r && r.point && r.point.haloPath && r.animate({ d: r.point.haloPath(0) });this.state = a;
	        }
	      }, haloPath: function haloPath(a) {
	        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);
	      } });w(h.prototype, { onMouseOver: function onMouseOver() {
	        var a = this.chart,
	            b = a.hoverSeries;if (b && b !== this) b.onMouseOut();this.options.events.mouseOver && q(this, "mouseOver");this.setState("hover");a.hoverSeries = this;
	      }, onMouseOut: function onMouseOut() {
	        var a = this.options,
	            b = this.chart,
	            c = b.tooltip,
	            d = b.hoverPoint;b.hoverSeries = null;if (d) d.onMouseOut();this && a.events.mouseOut && q(this, "mouseOut");!c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();this.setState();
	      }, setState: function setState(a) {
	        var c = this,
	            e = c.options,
	            d = c.graph,
	            h = e.states,
	            m = e.lineWidth,
	            e = 0;a = a || "";if (c.state !== a && (r([c.group, c.markerGroup, c.dataLabelsGroup], function (b) {
	          b && (c.state && b.removeClass("highcharts-series-" + c.state), a && b.addClass("highcharts-series-" + a));
	        }), c.state = a, !h[a] || !1 !== h[a].enabled) && (a && (m = h[a].lineWidth || m + (h[a].lineWidthPlus || 0)), d && !d.dashstyle)) for (m = { "stroke-width": m }, d.animate(m, b(c.chart.options.chart.animation, h[a] && h[a].animation)); c["zone-graph-" + e];) {
	          c["zone-graph-" + e].attr(m), e += 1;
	        }
	      }, setVisible: function setVisible(a, b) {
	        var c = this,
	            d = c.chart,
	            e = c.legendItem,
	            k,
	            h = d.options.chart.ignoreHiddenSeries,
	            f = c.visible;k = (c.visible = a = c.options.visible = c.userOptions.visible = void 0 === a ? !f : a) ? "show" : "hide";r(["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"], function (a) {
	          if (c[a]) c[a][k]();
	        });if (d.hoverSeries === c || (d.hoverPoint && d.hoverPoint.series) === c) c.onMouseOut();e && d.legend.colorizeItem(c, a);c.isDirty = !0;c.options.stacking && r(d.series, function (a) {
	          a.options.stacking && a.visible && (a.isDirty = !0);
	        });r(c.linkedSeries, function (b) {
	          b.setVisible(a, !1);
	        });h && (d.isDirtyBox = !0);!1 !== b && d.redraw();q(c, k);
	      }, show: function show() {
	        this.setVisible(!0);
	      }, hide: function hide() {
	        this.setVisible(!1);
	      }, select: function select(a) {
	        this.selected = a = void 0 === a ? !this.selected : a;this.checkbox && (this.checkbox.checked = a);q(this, a ? "select" : "unselect");
	      }, drawTracker: a.drawTrackerGraph });
	  })(K);(function (a) {
	    var D = a.Chart,
	        C = a.each,
	        G = a.inArray,
	        H = a.isArray,
	        v = a.isObject,
	        l = a.pick,
	        r = a.splat;D.prototype.setResponsive = function (l) {
	      var q = this.options.responsive,
	          n = [],
	          f = this.currentResponsive;q && q.rules && C(q.rules, function (c) {
	        void 0 === c._id && (c._id = a.uniqueKey());this.matchResponsiveRule(c, n, l);
	      }, this);var c = a.merge.apply(0, a.map(n, function (c) {
	        return a.find(q.rules, function (a) {
	          return a._id === c;
	        }).chartOptions;
	      })),
	          n = n.toString() || void 0;n !== (f && f.ruleIds) && (f && this.update(f.undoOptions, l), n ? (this.currentResponsive = { ruleIds: n, mergedOptions: c, undoOptions: this.currentOptions(c) }, this.update(c, l)) : this.currentResponsive = void 0);
	    };D.prototype.matchResponsiveRule = function (a, q) {
	      var n = a.condition;(n.callback || function () {
	        return this.chartWidth <= l(n.maxWidth, Number.MAX_VALUE) && this.chartHeight <= l(n.maxHeight, Number.MAX_VALUE) && this.chartWidth >= l(n.minWidth, 0) && this.chartHeight >= l(n.minHeight, 0);
	      }).call(this) && q.push(a._id);
	    };D.prototype.currentOptions = function (a) {
	      function l(a, c, e, n) {
	        var b, f;for (b in a) {
	          if (!n && -1 < G(b, ["series", "xAxis", "yAxis"])) for (a[b] = r(a[b]), e[b] = [], f = 0; f < a[b].length; f++) {
	            c[b][f] && (e[b][f] = {}, l(a[b][f], c[b][f], e[b][f], n + 1));
	          } else v(a[b]) ? (e[b] = H(a[b]) ? [] : {}, l(a[b], c[b] || {}, e[b], n + 1)) : e[b] = c[b] || null;
	        }
	      }var n = {};l(a, this.options, n, 0);return n;
	    };
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.Axis,
	        G = a.Chart,
	        H = a.css,
	        v = a.dateFormat,
	        l = a.defined,
	        r = a.each,
	        w = a.extend,
	        q = a.noop,
	        n = a.Series,
	        f = a.timeUnits;a = a.wrap;
	    a(n.prototype, "init", function (a) {
	      var c;a.apply(this, Array.prototype.slice.call(arguments, 1));(c = this.xAxis) && c.options.ordinal && D(this, "updatedData", function () {
	        delete c.ordinalIndex;
	      });
	    });a(C.prototype, "getTimeTicks", function (a, e, n, b, t, h, q, p) {
	      var c = 0,
	          k,
	          r,
	          d = {},
	          u,
	          m,
	          y,
	          z = [],
	          E = -Number.MAX_VALUE,
	          w = this.options.tickPixelInterval;if (!this.options.ordinal && !this.options.breaks || !h || 3 > h.length || void 0 === n) return a.call(this, e, n, b, t);m = h.length;for (k = 0; k < m; k++) {
	        y = k && h[k - 1] > b;h[k] < n && (c = k);if (k === m - 1 || h[k + 1] - h[k] > 5 * q || y) {
	          if (h[k] > E) {
	            for (r = a.call(this, e, h[c], h[k], t); r.length && r[0] <= E;) {
	              r.shift();
	            }r.length && (E = r[r.length - 1]);z = z.concat(r);
	          }c = k + 1;
	        }if (y) break;
	      }a = r.info;if (p && a.unitRange <= f.hour) {
	        k = z.length - 1;for (c = 1; c < k; c++) {
	          v("%d", z[c]) !== v("%d", z[c - 1]) && (d[z[c]] = "day", u = !0);
	        }u && (d[z[0]] = "day");a.higherRanks = d;
	      }z.info = a;if (p && l(w)) {
	        p = a = z.length;k = [];var g;for (u = []; p--;) {
	          c = this.translate(z[p]), g && (u[p] = g - c), k[p] = g = c;
	        }u.sort();u = u[Math.floor(u.length / 2)];u < .6 * w && (u = null);p = z[a - 1] > b ? a - 1 : a;for (g = void 0; p--;) {
	          c = k[p], b = Math.abs(g - c), g && b < .8 * w && (null === u || b < .8 * u) ? (d[z[p]] && !d[z[p + 1]] ? (b = p + 1, g = c) : b = p, z.splice(b, 1)) : g = c;
	        }
	      }return z;
	    });w(C.prototype, { beforeSetTickPositions: function beforeSetTickPositions() {
	        var a,
	            e = [],
	            f = !1,
	            b,
	            l = this.getExtremes(),
	            h = l.min,
	            n = l.max,
	            p,
	            x = this.isXAxis && !!this.options.breaks,
	            l = this.options.ordinal,
	            k = this.chart.options.chart.ignoreHiddenSeries;if (l || x) {
	          r(this.series, function (b, c) {
	            if (!(k && !1 === b.visible || !1 === b.takeOrdinalPosition && !x) && (e = e.concat(b.processedXData), a = e.length, e.sort(function (a, b) {
	              return a - b;
	            }), a)) for (c = a - 1; c--;) {
	              e[c] === e[c + 1] && e.splice(c, 1);
	            }
	          });a = e.length;if (2 < a) {
	            b = e[1] - e[0];for (p = a - 1; p-- && !f;) {
	              e[p + 1] - e[p] !== b && (f = !0);
	            }!this.options.keepOrdinalPadding && (e[0] - h > b || n - e[e.length - 1] > b) && (f = !0);
	          }f ? (this.ordinalPositions = e, b = this.ordinal2lin(Math.max(h, e[0]), !0), p = Math.max(this.ordinal2lin(Math.min(n, e[e.length - 1]), !0), 1), this.ordinalSlope = n = (n - h) / (p - b), this.ordinalOffset = h - b * n) : this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = void 0;
	        }this.isOrdinal = l && f;this.groupIntervalFactor = null;
	      }, val2lin: function val2lin(a, e) {
	        var c = this.ordinalPositions;if (c) {
	          var b = c.length,
	              f,
	              h;for (f = b; f--;) {
	            if (c[f] === a) {
	              h = f;break;
	            }
	          }for (f = b - 1; f--;) {
	            if (a > c[f] || 0 === f) {
	              a = (a - c[f]) / (c[f + 1] - c[f]);h = f + a;break;
	            }
	          }e = e ? h : this.ordinalSlope * (h || 0) + this.ordinalOffset;
	        } else e = a;return e;
	      }, lin2val: function lin2val(a, e) {
	        var c = this.ordinalPositions;if (c) {
	          var b = this.ordinalSlope,
	              f = this.ordinalOffset,
	              h = c.length - 1,
	              l;if (e) 0 > a ? a = c[0] : a > h ? a = c[h] : (h = Math.floor(a), l = a - h);else for (; h--;) {
	            if (e = b * h + f, a >= e) {
	              b = b * (h + 1) + f;l = (a - e) / (b - e);break;
	            }
	          }return void 0 !== l && void 0 !== c[h] ? c[h] + (l ? l * (c[h + 1] - c[h]) : 0) : a;
	        }return a;
	      }, getExtendedPositions: function getExtendedPositions() {
	        var a = this.chart,
	            e = this.series[0].currentDataGrouping,
	            f = this.ordinalIndex,
	            b = e ? e.count + e.unitName : "raw",
	            l = this.getExtremes(),
	            h,
	            n;f || (f = this.ordinalIndex = {});f[b] || (h = { series: [], chart: a, getExtremes: function getExtremes() {
	            return { min: l.dataMin, max: l.dataMax };
	          }, options: { ordinal: !0 }, val2lin: C.prototype.val2lin, ordinal2lin: C.prototype.ordinal2lin }, r(this.series, function (b) {
	          n = { xAxis: h, xData: b.xData, chart: a, destroyGroupedData: q };n.options = { dataGrouping: e ? { enabled: !0,
	              forced: !0, approximation: "open", units: [[e.unitName, [e.count]]] } : { enabled: !1 } };b.processData.apply(n);h.series.push(n);
	        }), this.beforeSetTickPositions.apply(h), f[b] = h.ordinalPositions);return f[b];
	      }, getGroupIntervalFactor: function getGroupIntervalFactor(a, e, f) {
	        var b;f = f.processedXData;var c = f.length,
	            h = [];b = this.groupIntervalFactor;if (!b) {
	          for (b = 0; b < c - 1; b++) {
	            h[b] = f[b + 1] - f[b];
	          }h.sort(function (a, b) {
	            return a - b;
	          });h = h[Math.floor(c / 2)];a = Math.max(a, f[0]);e = Math.min(e, f[c - 1]);this.groupIntervalFactor = b = c * h / (e - a);
	        }return b;
	      }, postProcessTickInterval: function postProcessTickInterval(a) {
	        var c = this.ordinalSlope;return c ? this.options.breaks ? this.closestPointRange : a / (c / this.closestPointRange) : a;
	      } });C.prototype.ordinal2lin = C.prototype.val2lin;a(G.prototype, "pan", function (a, e) {
	      var c = this.xAxis[0],
	          b = e.chartX,
	          f = !1;if (c.options.ordinal && c.series.length) {
	        var h = this.mouseDownX,
	            l = c.getExtremes(),
	            p = l.dataMax,
	            n = l.min,
	            k = l.max,
	            q = this.hoverPoints,
	            d = c.closestPointRange,
	            h = (h - b) / (c.translationSlope * (c.ordinalSlope || d)),
	            u = { ordinalPositions: c.getExtendedPositions() },
	            d = c.lin2val,
	            m = c.val2lin,
	            y;u.ordinalPositions ? 1 < Math.abs(h) && (q && r(q, function (a) {
	          a.setState();
	        }), 0 > h ? (q = u, y = c.ordinalPositions ? c : u) : (q = c.ordinalPositions ? c : u, y = u), u = y.ordinalPositions, p > u[u.length - 1] && u.push(p), this.fixedRange = k - n, h = c.toFixedRange(null, null, d.apply(q, [m.apply(q, [n, !0]) + h, !0]), d.apply(y, [m.apply(y, [k, !0]) + h, !0])), h.min >= Math.min(l.dataMin, n) && h.max <= Math.max(p, k) && c.setExtremes(h.min, h.max, !0, !1, { trigger: "pan" }), this.mouseDownX = b, H(this.container, { cursor: "move" })) : f = !0;
	      } else f = !0;f && a.apply(this, Array.prototype.slice.call(arguments, 1));
	    });n.prototype.gappedPath = function () {
	      var a = this.options.gapSize,
	          e = this.points.slice(),
	          f = e.length - 1;if (a && 0 < f) for (; f--;) {
	        e[f + 1].x - e[f].x > this.closestPointRange * a && e.splice(f + 1, 0, { isNull: !0 });
	      }return this.getGraphPath(e);
	    };
	  })(K);(function (a) {
	    function D() {
	      return Array.prototype.slice.call(arguments, 1);
	    }function C(a) {
	      a.apply(this);this.drawBreaks(this.xAxis, ["x"]);this.drawBreaks(this.yAxis, G(this.pointArrayMap, ["y"]));
	    }var G = a.pick,
	        H = a.wrap,
	        v = a.each,
	        l = a.extend,
	        r = a.isArray,
	        w = a.fireEvent,
	        q = a.Axis,
	        n = a.Series;
	    l(q.prototype, { isInBreak: function isInBreak(a, c) {
	        var e = a.repeat || Infinity,
	            f = a.from,
	            b = a.to - a.from;c = c >= f ? (c - f) % e : e - (f - c) % e;return a.inclusive ? c <= b : c < b && 0 !== c;
	      }, isInAnyBreak: function isInAnyBreak(a, c) {
	        var e = this.options.breaks,
	            f = e && e.length,
	            b,
	            l,
	            h;if (f) {
	          for (; f--;) {
	            this.isInBreak(e[f], a) && (b = !0, l || (l = G(e[f].showPoints, this.isXAxis ? !1 : !0)));
	          }h = b && c ? b && !l : b;
	        }return h;
	      } });H(q.prototype, "setTickPositions", function (a) {
	      a.apply(this, Array.prototype.slice.call(arguments, 1));if (this.options.breaks) {
	        var c = this.tickPositions,
	            e = this.tickPositions.info,
	            f = [],
	            b;for (b = 0; b < c.length; b++) {
	          this.isInAnyBreak(c[b]) || f.push(c[b]);
	        }this.tickPositions = f;this.tickPositions.info = e;
	      }
	    });H(q.prototype, "init", function (a, c, e) {
	      var f = this;e.breaks && e.breaks.length && (e.ordinal = !1);a.call(this, c, e);a = this.options.breaks;f.isBroken = r(a) && !!a.length;f.isBroken && (f.val2lin = function (a) {
	        var b = a,
	            c,
	            e;for (e = 0; e < f.breakArray.length; e++) {
	          if (c = f.breakArray[e], c.to <= a) b -= c.len;else if (c.from >= a) break;else if (f.isInBreak(c, a)) {
	            b -= a - c.from;break;
	          }
	        }return b;
	      }, f.lin2val = function (a) {
	        var b, c;
	        for (c = 0; c < f.breakArray.length && !(b = f.breakArray[c], b.from >= a); c++) {
	          b.to < a ? a += b.len : f.isInBreak(b, a) && (a += b.len);
	        }return a;
	      }, f.setExtremes = function (a, c, e, f, p) {
	        for (; this.isInAnyBreak(a);) {
	          a -= this.closestPointRange;
	        }for (; this.isInAnyBreak(c);) {
	          c -= this.closestPointRange;
	        }q.prototype.setExtremes.call(this, a, c, e, f, p);
	      }, f.setAxisTranslation = function (a) {
	        q.prototype.setAxisTranslation.call(this, a);var b = f.options.breaks;a = [];var c = [],
	            e = 0,
	            p,
	            l,
	            k = f.userMin || f.min,
	            n = f.userMax || f.max,
	            d = G(f.pointRangePadding, 0),
	            u,
	            m;for (m in b) {
	          l = b[m], p = l.repeat || Infinity, f.isInBreak(l, k) && (k += l.to % p - k % p), f.isInBreak(l, n) && (n -= n % p - l.from % p);
	        }for (m in b) {
	          l = b[m];u = l.from;for (p = l.repeat || Infinity; u - p > k;) {
	            u -= p;
	          }for (; u < k;) {
	            u += p;
	          }for (; u < n; u += p) {
	            a.push({ value: u, move: "in" }), a.push({ value: u + (l.to - l.from), move: "out", size: l.breakSize });
	          }
	        }a.sort(function (a, b) {
	          return a.value === b.value ? ("in" === a.move ? 0 : 1) - ("in" === b.move ? 0 : 1) : a.value - b.value;
	        });b = 0;u = k;for (m in a) {
	          l = a[m], b += "in" === l.move ? 1 : -1, 1 === b && "in" === l.move && (u = l.value), 0 === b && (c.push({ from: u, to: l.value, len: l.value - u - (l.size || 0) }), e += l.value - u - (l.size || 0));
	        }f.breakArray = c;f.unitLength = n - k - e + d;w(f, "afterBreaks");f.transA = f.options.staticScale ? f.options.staticScale : (n - f.min + d) / f.unitLength * f.transA;d && (f.minPixelPadding = f.transA * f.minPointOffset);f.min = k;f.max = n;
	      });
	    });H(n.prototype, "generatePoints", function (a) {
	      a.apply(this, D(arguments));var c = this.xAxis,
	          e = this.yAxis,
	          f = this.points,
	          b,
	          l = f.length,
	          h = this.options.connectNulls,
	          n;if (c && e && (c.options.breaks || e.options.breaks)) for (; l--;) {
	        b = f[l], n = null === b.y && !1 === h, n || !c.isInAnyBreak(b.x, !0) && !e.isInAnyBreak(b.y, !0) || (f.splice(l, 1), this.data[l] && this.data[l].destroyElements());
	      }
	    });a.Series.prototype.drawBreaks = function (a, c) {
	      var e = this,
	          f = e.points,
	          b,
	          l,
	          h,
	          n;a && v(c, function (c) {
	        b = a.breakArray || [];l = a.isXAxis ? a.min : G(e.options.threshold, a.min);v(f, function (e) {
	          n = G(e["stack" + c.toUpperCase()], e[c]);v(b, function (b) {
	            h = !1;if (l < b.from && n > b.to || l > b.from && n < b.from) h = "pointBreak";else if (l < b.from && n > b.from && n < b.to || l > b.from && n > b.to && n < b.from) h = "pointInBreak";h && w(a, h, { point: e, brk: b });
	          });
	        });
	      });
	    };H(a.seriesTypes.column.prototype, "drawPoints", C);H(a.Series.prototype, "drawPoints", C);
	  })(K);(function (a) {
	    var D = a.arrayMax,
	        C = a.arrayMin,
	        G = a.Axis,
	        H = a.defaultPlotOptions,
	        v = a.defined,
	        l = a.each,
	        r = a.extend,
	        w = a.format,
	        q = a.isNumber,
	        n = a.merge,
	        f = a.pick,
	        c = a.Point,
	        e = a.Tooltip,
	        z = a.wrap,
	        b = a.Series.prototype,
	        t = b.processData,
	        h = b.generatePoints,
	        B = b.destroy,
	        p = { approximation: "average", groupPixelWidth: 2, dateTimeLabelFormats: { millisecond: ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"], second: ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"], minute: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], hour: ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], day: ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], week: ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], month: ["%B %Y", "%B", "-%B %Y"], year: ["%Y", "%Y", "-%Y"] } },
	        x = { line: {}, spline: {}, area: {}, areaspline: {}, column: { approximation: "sum", groupPixelWidth: 10 }, arearange: { approximation: "range" }, areasplinerange: { approximation: "range" }, columnrange: { approximation: "range", groupPixelWidth: 10 },
	      candlestick: { approximation: "ohlc", groupPixelWidth: 10 }, ohlc: { approximation: "ohlc", groupPixelWidth: 5 } },
	        k = a.defaultDataGroupingUnits = [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]],
	        F = { sum: function sum(a) {
	        var b = a.length,
	            c;if (!b && a.hasNulls) c = null;else if (b) for (c = 0; b--;) {
	          c += a[b];
	        }return c;
	      }, average: function average(a) {
	        var b = a.length;a = F.sum(a);q(a) && b && (a /= b);return a;
	      }, open: function open(a) {
	        return a.length ? a[0] : a.hasNulls ? null : void 0;
	      }, high: function high(a) {
	        return a.length ? D(a) : a.hasNulls ? null : void 0;
	      }, low: function low(a) {
	        return a.length ? C(a) : a.hasNulls ? null : void 0;
	      }, close: function close(a) {
	        return a.length ? a[a.length - 1] : a.hasNulls ? null : void 0;
	      }, ohlc: function ohlc(a, b, c, e) {
	        a = F.open(a);b = F.high(b);c = F.low(c);e = F.close(e);if (q(a) || q(b) || q(c) || q(e)) return [a, b, c, e];
	      }, range: function range(a, b) {
	        a = F.low(a);b = F.high(b);if (q(a) || q(b)) return [a, b];
	      } };b.groupData = function (a, b, c, e) {
	      var d = this.data,
	          k = this.options.data,
	          f = [],
	          g = [],
	          h = [],
	          m = a.length,
	          p,
	          l,
	          n = !!b,
	          u = [[], [], [], []];e = "function" === typeof e ? e : F[e];var t = this.pointArrayMap,
	          x = t && t.length,
	          r,
	          y = 0;for (r = l = 0; r <= m && !(a[r] >= c[0]); r++) {}for (r; r <= m; r++) {
	        for (; (void 0 !== c[y + 1] && a[r] >= c[y + 1] || r === m) && (p = c[y], this.dataGroupInfo = { start: l, length: u[0].length }, l = e.apply(this, u), void 0 !== l && (f.push(p), g.push(l), h.push(this.dataGroupInfo)), l = r, u[0] = [], u[1] = [], u[2] = [], u[3] = [], y += 1, r !== m);) {}if (r === m) break;if (t) {
	          p = this.cropStart + r;p = d && d[p] || this.pointClass.prototype.applyOptions.apply({ series: this }, [k[p]]);
	          var v, w;for (v = 0; v < x; v++) {
	            w = p[t[v]], q(w) ? u[v].push(w) : null === w && (u[v].hasNulls = !0);
	          }
	        } else p = n ? b[r] : null, q(p) ? u[0].push(p) : null === p && (u[0].hasNulls = !0);
	      }return [f, g, h];
	    };b.processData = function () {
	      var a = this.chart,
	          c = this.options.dataGrouping,
	          e = !1 !== this.allowDG && c && f(c.enabled, a.options.isStock),
	          h = this.visible || !a.options.chart.ignoreHiddenSeries,
	          p;this.forceCrop = e;this.groupPixelWidth = null;this.hasProcessed = !0;if (!1 !== t.apply(this, arguments) && e) {
	        this.destroyGroupedData();var l = this.processedXData,
	            n = this.processedYData,
	            g = a.plotSizeX,
	            a = this.xAxis,
	            q = a.options.ordinal,
	            r = this.groupPixelWidth = a.getGroupPixelWidth && a.getGroupPixelWidth();if (r) {
	          this.isDirty = p = !0;var x = a.getExtremes(),
	              e = x.min,
	              x = x.max,
	              q = q && a.getGroupIntervalFactor(e, x, this) || 1,
	              g = r * (x - e) / g * q,
	              r = a.getTimeTicks(a.normalizeTimeTickInterval(g, c.units || k), Math.min(e, l[0]), Math.max(x, l[l.length - 1]), a.options.startOfWeek, l, this.closestPointRange),
	              l = b.groupData.apply(this, [l, n, r, c.approximation]),
	              n = l[0],
	              q = l[1];if (c.smoothed) {
	            c = n.length - 1;for (n[c] = Math.min(n[c], x); c-- && 0 < c;) {
	              n[c] += g / 2;
	            }n[0] = Math.max(n[0], e);
	          }this.currentDataGrouping = r.info;this.closestPointRange = r.info.totalRange;this.groupMap = l[2];v(n[0]) && n[0] < a.dataMin && h && (a.min === a.dataMin && (a.min = n[0]), a.dataMin = n[0]);this.processedXData = n;this.processedYData = q;
	        } else this.currentDataGrouping = this.groupMap = null;this.hasGroupedData = p;
	      }
	    };b.destroyGroupedData = function () {
	      var a = this.groupedData;l(a || [], function (b, c) {
	        b && (a[c] = b.destroy ? b.destroy() : null);
	      });this.groupedData = null;
	    };b.generatePoints = function () {
	      h.apply(this);
	      this.destroyGroupedData();this.groupedData = this.hasGroupedData ? this.points : null;
	    };z(c.prototype, "update", function (b) {
	      this.dataGroup ? a.error(24) : b.apply(this, [].slice.call(arguments, 1));
	    });z(e.prototype, "tooltipFooterHeaderFormatter", function (b, c, e) {
	      var d = c.series,
	          k = d.tooltipOptions,
	          f = d.options.dataGrouping,
	          h = k.xDateFormat,
	          g,
	          m = d.xAxis,
	          l = a.dateFormat;return m && "datetime" === m.options.type && f && q(c.key) ? (b = d.currentDataGrouping, f = f.dateTimeLabelFormats, b ? (m = f[b.unitName], 1 === b.count ? h = m[0] : (h = m[1], g = m[2])) : !h && f && (h = this.getXDateFormat(c, k, m)), h = l(h, c.key), g && (h += l(g, c.key + b.totalRange - 1)), w(k[(e ? "footer" : "header") + "Format"], { point: r(c.point, { key: h }), series: d })) : b.call(this, c, e);
	    });b.destroy = function () {
	      for (var a = this.groupedData || [], b = a.length; b--;) {
	        a[b] && a[b].destroy();
	      }B.apply(this);
	    };z(b, "setOptions", function (a, b) {
	      a = a.call(this, b);var c = this.type,
	          d = this.chart.options.plotOptions,
	          e = H[c].dataGrouping;x[c] && (e || (e = n(p, x[c])), a.dataGrouping = n(e, d.series && d.series.dataGrouping, d[c].dataGrouping, b.dataGrouping));
	      this.chart.options.isStock && (this.requireSorting = !0);return a;
	    });z(G.prototype, "setScale", function (a) {
	      a.call(this);l(this.series, function (a) {
	        a.hasProcessed = !1;
	      });
	    });G.prototype.getGroupPixelWidth = function () {
	      var a = this.series,
	          b = a.length,
	          c,
	          e = 0,
	          k = !1,
	          h;for (c = b; c--;) {
	        (h = a[c].options.dataGrouping) && (e = Math.max(e, h.groupPixelWidth));
	      }for (c = b; c--;) {
	        (h = a[c].options.dataGrouping) && a[c].hasProcessed && (b = (a[c].processedXData || a[c].data).length, a[c].groupPixelWidth || b > this.chart.plotSizeX / e || b && h.forced) && (k = !0);
	      }return k ? e : 0;
	    };G.prototype.setDataGrouping = function (a, b) {
	      var c;b = f(b, !0);a || (a = { forced: !1, units: null });if (this instanceof G) for (c = this.series.length; c--;) {
	        this.series[c].update({ dataGrouping: a }, !1);
	      } else l(this.chart.options.series, function (b) {
	        b.dataGrouping = a;
	      }, !1);b && this.chart.redraw();
	    };
	  })(K);(function (a) {
	    var D = a.each,
	        C = a.Point,
	        G = a.seriesType,
	        H = a.seriesTypes;G("ohlc", "column", { lineWidth: 1, tooltip: { pointFormat: "<span style=\"color:{point.color}\">\u25CF</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>" },
	      threshold: null, states: { hover: { lineWidth: 3 } }, stickyTracking: !0 }, { directTouch: !1, pointArrayMap: ["open", "high", "low", "close"], toYData: function toYData(a) {
	        return [a.open, a.high, a.low, a.close];
	      }, pointValKey: "high", pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, pointAttribs: function pointAttribs(a, l) {
	        l = H.column.prototype.pointAttribs.call(this, a, l);var r = this.options;delete l.fill;!a.options.color && r.upColor && a.open < a.close && (l.stroke = r.upColor);return l;
	      }, translate: function translate() {
	        var a = this,
	            l = a.yAxis,
	            r = !!a.modifyValue,
	            w = ["plotOpen", "plotHigh", "plotLow", "plotClose", "yBottom"];H.column.prototype.translate.apply(a);D(a.points, function (q) {
	          D([q.open, q.high, q.low, q.close, q.low], function (n, f) {
	            null !== n && (r && (n = a.modifyValue(n)), q[w[f]] = l.toPixels(n, !0));
	          });
	        });
	      }, drawPoints: function drawPoints() {
	        var a = this,
	            l = a.chart;D(a.points, function (r) {
	          var w,
	              q,
	              n,
	              f,
	              c = r.graphic,
	              e,
	              v = !c;void 0 !== r.plotY && (c || (r.graphic = c = l.renderer.path().add(a.group)), c.attr(a.pointAttribs(r, r.selected && "select")), q = c.strokeWidth() % 2 / 2, e = Math.round(r.plotX) - q, n = Math.round(r.shapeArgs.width / 2), f = ["M", e, Math.round(r.yBottom), "L", e, Math.round(r.plotY)], null !== r.open && (w = Math.round(r.plotOpen) + q, f.push("M", e, w, "L", e - n, w)), null !== r.close && (w = Math.round(r.plotClose) + q, f.push("M", e, w, "L", e + n, w)), c[v ? "attr" : "animate"]({ d: f }).addClass(r.getClassName(), !0));
	        });
	      }, animate: null }, { getClassName: function getClassName() {
	        return C.prototype.getClassName.call(this) + (this.open < this.close ? " highcharts-point-up" : " highcharts-point-down");
	      } });
	  })(K);(function (a) {
	    var D = a.defaultPlotOptions,
	        C = a.each,
	        G = a.merge,
	        H = a.seriesType,
	        v = a.seriesTypes;H("candlestick", "ohlc", G(D.column, { states: { hover: { lineWidth: 2 } }, tooltip: D.ohlc.tooltip, threshold: null, lineColor: "#000000", lineWidth: 1, upColor: "#ffffff", stickyTracking: !0 }), { pointAttribs: function pointAttribs(a, r) {
	        var l = v.column.prototype.pointAttribs.call(this, a, r),
	            q = this.options,
	            n = a.open < a.close,
	            f = q.lineColor || this.color;l["stroke-width"] = q.lineWidth;l.fill = a.options.color || (n ? q.upColor || this.color : this.color);l.stroke = a.lineColor || (n ? q.upLineColor || f : f);r && (a = q.states[r], l.fill = a.color || l.fill, l.stroke = a.lineColor || l.stroke, l["stroke-width"] = a.lineWidth || l["stroke-width"]);return l;
	      }, drawPoints: function drawPoints() {
	        var a = this,
	            r = a.chart;C(a.points, function (l) {
	          var q = l.graphic,
	              n,
	              f,
	              c,
	              e,
	              v,
	              b,
	              t,
	              h = !q;void 0 !== l.plotY && (q || (l.graphic = q = r.renderer.path().add(a.group)), q.attr(a.pointAttribs(l, l.selected && "select")).shadow(a.options.shadow), v = q.strokeWidth() % 2 / 2, b = Math.round(l.plotX) - v, n = l.plotOpen, f = l.plotClose, c = Math.min(n, f), n = Math.max(n, f), t = Math.round(l.shapeArgs.width / 2), f = Math.round(c) !== Math.round(l.plotY), e = n !== l.yBottom, c = Math.round(c) + v, n = Math.round(n) + v, v = [], v.push("M", b - t, n, "L", b - t, c, "L", b + t, c, "L", b + t, n, "Z", "M", b, c, "L", b, f ? Math.round(l.plotY) : c, "M", b, n, "L", b, e ? Math.round(l.yBottom) : n), q[h ? "attr" : "animate"]({ d: v }).addClass(l.getClassName(), !0));
	        });
	      } });
	  })(K);(function (a) {
	    var D = a.addEvent,
	        C = a.each,
	        G = a.merge,
	        H = a.noop,
	        v = a.Renderer,
	        l = a.seriesType,
	        r = a.seriesTypes,
	        w = a.TrackerMixin,
	        q = a.VMLRenderer,
	        n = a.SVGRenderer.prototype.symbols,
	        f = a.stableSort;l("flags", "column", { pointRange: 0, shape: "flag", stackDistance: 12,
	      textAlign: "center", tooltip: { pointFormat: "{point.text}\x3cbr/\x3e" }, threshold: null, y: -30, fillColor: "#ffffff", lineWidth: 1, states: { hover: { lineColor: "#000000", fillColor: "#ccd6eb" } }, style: { fontSize: "11px", fontWeight: "bold" } }, { sorted: !1, noSharedTooltip: !0, allowDG: !1, takeOrdinalPosition: !1, trackerGroups: ["markerGroup"], forceCrop: !0, init: a.Series.prototype.init, pointAttribs: function pointAttribs(a, e) {
	        var c = this.options,
	            b = a && a.color || this.color,
	            f = c.lineColor,
	            h = a && a.lineWidth;a = a && a.fillColor || c.fillColor;e && (a = c.states[e].fillColor, f = c.states[e].lineColor, h = c.states[e].lineWidth);return { fill: a || b, stroke: f || b, "stroke-width": h || c.lineWidth || 0 };
	      }, translate: function translate() {
	        r.column.prototype.translate.apply(this);var a = this.options,
	            e = this.chart,
	            l = this.points,
	            b = l.length - 1,
	            n,
	            h,
	            q = a.onSeries;n = q && e.get(q);var a = a.onKey || "y",
	            q = n && n.options.step,
	            p = n && n.points,
	            x = p && p.length,
	            k = this.xAxis,
	            v = this.yAxis,
	            d = k.getExtremes(),
	            u = 0,
	            m,
	            y,
	            w;if (n && n.visible && x) for (u = (n.pointXOffset || 0) + (n.barW || 0) / 2, n = n.currentDataGrouping, y = p[x - 1].x + (n ? n.totalRange : 0), f(l, function (a, b) {
	          return a.x - b.x;
	        }), a = "plot" + a[0].toUpperCase() + a.substr(1); x-- && l[b] && !(n = l[b], m = p[x], m.x <= n.x && void 0 !== m[a] && (n.x <= y && (n.plotY = m[a], m.x < n.x && !q && (w = p[x + 1]) && void 0 !== w[a] && (n.plotY += (n.x - m.x) / (w.x - m.x) * (w[a] - m[a]))), b--, x++, 0 > b));) {}C(l, function (a, b) {
	          var c;void 0 === a.plotY && (a.x >= d.min && a.x <= d.max ? a.plotY = e.chartHeight - k.bottom - (k.opposite ? k.height : 0) + k.offset - v.top : a.shapeArgs = {});a.plotX += u;(h = l[b - 1]) && h.plotX === a.plotX && (void 0 === h.stackIndex && (h.stackIndex = 0), c = h.stackIndex + 1);a.stackIndex = c;
	        });
	      }, drawPoints: function drawPoints() {
	        var c = this.points,
	            e = this.chart,
	            f = e.renderer,
	            b,
	            l,
	            h = this.options,
	            n = h.y,
	            p,
	            q,
	            k,
	            r,
	            d,
	            u,
	            m,
	            y = this.yAxis;for (q = c.length; q--;) {
	          k = c[q], m = k.plotX > this.xAxis.len, b = k.plotX, r = k.stackIndex, p = k.options.shape || h.shape, l = k.plotY, void 0 !== l && (l = k.plotY + n - (void 0 !== r && r * h.stackDistance)), d = r ? void 0 : k.plotX, u = r ? void 0 : k.plotY, r = k.graphic, void 0 !== l && 0 <= b && !m ? (r || (r = k.graphic = f.label("", null, null, p, null, null, h.useHTML).attr(this.pointAttribs(k)).css(G(h.style, k.style)).attr({ align: "flag" === p ? "left" : "center", width: h.width, height: h.height, "text-align": h.textAlign }).addClass("highcharts-point").add(this.markerGroup), k.graphic.div && (k.graphic.div.point = k), r.shadow(h.shadow)), 0 < b && (b -= r.strokeWidth() % 2), r.attr({ text: k.options.title || h.title || "A", x: b, y: l, anchorX: d, anchorY: u }), k.tooltipPos = e.inverted ? [y.len + y.pos - e.plotLeft - l, this.xAxis.len - b] : [b, l + y.pos - e.plotTop]) : r && (k.graphic = r.destroy());
	        }h.useHTML && a.wrap(this.markerGroup, "on", function (b) {
	          return a.SVGElement.prototype.on.apply(b.apply(this, [].slice.call(arguments, 1)), [].slice.call(arguments, 1));
	        });
	      }, drawTracker: function drawTracker() {
	        var a = this.points;w.drawTrackerPoint.apply(this);C(a, function (c) {
	          var e = c.graphic;e && D(e.element, "mouseover", function () {
	            0 < c.stackIndex && !c.raised && (c._y = e.y, e.attr({ y: c._y - 8 }), c.raised = !0);C(a, function (a) {
	              a !== c && a.raised && a.graphic && (a.graphic.attr({ y: a._y }), a.raised = !1);
	            });
	          });
	        });
	      }, animate: H, buildKDTree: H, setClip: H });n.flag = function (a, e, f, b, l) {
	      return ["M", l && l.anchorX || a, l && l.anchorY || e, "L", a, e + b, a, e, a + f, e, a + f, e + b, a, e + b, "Z"];
	    };
	    C(["circle", "square"], function (a) {
	      n[a + "pin"] = function (c, f, b, l, h) {
	        var e = h && h.anchorX;h = h && h.anchorY;"circle" === a && l > b && (c -= Math.round((l - b) / 2), b = l);c = n[a](c, f, b, l);e && h && c.push("M", e, f > h ? f : f + l, "L", e, h);return c;
	      };
	    });v === q && C(["flag", "circlepin", "squarepin"], function (a) {
	      q.prototype.symbols[a] = n[a];
	    });
	  })(K);(function (a) {
	    function D(a, b, c) {
	      this.init(a, b, c);
	    }var C = a.addEvent,
	        G = a.Axis,
	        H = a.correctFloat,
	        v = a.defaultOptions,
	        l = a.defined,
	        r = a.destroyObjectProperties,
	        w = a.doc,
	        q = a.each,
	        n = a.fireEvent,
	        f = a.hasTouch,
	        c = a.isTouchDevice,
	        e = a.merge,
	        z = a.pick,
	        b = a.removeEvent,
	        t = a.wrap,
	        h,
	        B = { height: c ? 20 : 14, barBorderRadius: 0, buttonBorderRadius: 0, liveRedraw: a.svg && !c, margin: 10, minWidth: 6, step: .2, zIndex: 3, barBackgroundColor: "#cccccc", barBorderWidth: 1, barBorderColor: "#cccccc", buttonArrowColor: "#333333", buttonBackgroundColor: "#e6e6e6", buttonBorderColor: "#cccccc", buttonBorderWidth: 1, rifleColor: "#333333", trackBackgroundColor: "#f2f2f2", trackBorderColor: "#f2f2f2", trackBorderWidth: 1 };v.scrollbar = e(!0, B, v.scrollbar);a.swapXY = h = function h(a, b) {
	      var c = a.length,
	          e;if (b) for (b = 0; b < c; b += 3) {
	        e = a[b + 1], a[b + 1] = a[b + 2], a[b + 2] = e;
	      }return a;
	    };D.prototype = { init: function init(a, b, c) {
	        this.scrollbarButtons = [];this.renderer = a;this.userOptions = b;this.options = e(B, b);this.chart = c;this.size = z(this.options.size, this.options.height);b.enabled && (this.render(), this.initEvents(), this.addEvents());
	      }, render: function render() {
	        var a = this.renderer,
	            b = this.options,
	            c = this.size,
	            e;this.group = e = a.g("scrollbar").attr({ zIndex: b.zIndex, translateY: -99999 }).add();this.track = a.rect().addClass("highcharts-scrollbar-track").attr({ x: 0,
	          r: b.trackBorderRadius || 0, height: c, width: c }).add(e);this.track.attr({ fill: b.trackBackgroundColor, stroke: b.trackBorderColor, "stroke-width": b.trackBorderWidth });this.trackBorderWidth = this.track.strokeWidth();this.track.attr({ y: -this.trackBorderWidth % 2 / 2 });this.scrollbarGroup = a.g().add(e);this.scrollbar = a.rect().addClass("highcharts-scrollbar-thumb").attr({ height: c, width: c, r: b.barBorderRadius || 0 }).add(this.scrollbarGroup);this.scrollbarRifles = a.path(h(["M", -3, c / 4, "L", -3, 2 * c / 3, "M", 0, c / 4, "L", 0, 2 * c / 3, "M", 3, c / 4, "L", 3, 2 * c / 3], b.vertical)).addClass("highcharts-scrollbar-rifles").add(this.scrollbarGroup);this.scrollbar.attr({ fill: b.barBackgroundColor, stroke: b.barBorderColor, "stroke-width": b.barBorderWidth });this.scrollbarRifles.attr({ stroke: b.rifleColor, "stroke-width": 1 });this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);this.drawScrollbarButton(0);this.drawScrollbarButton(1);
	      }, position: function position(a, b, c, e) {
	        var d = this.options.vertical,
	            k = 0,
	            f = this.rendered ? "animate" : "attr";this.x = a;this.y = b + this.trackBorderWidth;this.width = c;this.xOffset = this.height = e;this.yOffset = k;d ? (this.width = this.yOffset = c = k = this.size, this.xOffset = b = 0, this.barWidth = e - 2 * c, this.x = a += this.options.margin) : (this.height = this.xOffset = e = b = this.size, this.barWidth = c - 2 * e, this.y += this.options.margin);this.group[f]({ translateX: a, translateY: this.y });this.track[f]({ width: c, height: e });this.scrollbarButtons[1][f]({ translateX: d ? 0 : c - b, translateY: d ? e - k : 0 });
	      },
	      drawScrollbarButton: function drawScrollbarButton(a) {
	        var b = this.renderer,
	            c = this.scrollbarButtons,
	            e = this.options,
	            d = this.size,
	            f;f = b.g().add(this.group);c.push(f);f = b.rect().addClass("highcharts-scrollbar-button").add(f);f.attr({ stroke: e.buttonBorderColor, "stroke-width": e.buttonBorderWidth, fill: e.buttonBackgroundColor });f.attr(f.crisp({ x: -.5, y: -.5, width: d + 1, height: d + 1, r: e.buttonBorderRadius }, f.strokeWidth()));f = b.path(h(["M", d / 2 + (a ? -1 : 1), d / 2 - 3, "L", d / 2 + (a ? -1 : 1), d / 2 + 3, "L", d / 2 + (a ? 2 : -2), d / 2], e.vertical)).addClass("highcharts-scrollbar-arrow").add(c[a]);
	        f.attr({ fill: e.buttonArrowColor });
	      }, setRange: function setRange(a, b) {
	        var c = this.options,
	            e = c.vertical,
	            d = c.minWidth,
	            f = this.barWidth,
	            h,
	            p,
	            n = this.rendered && !this.hasDragged ? "animate" : "attr";l(f) && (a = Math.max(a, 0), h = Math.ceil(f * a), this.calculatedWidth = p = H(f * Math.min(b, 1) - h), p < d && (h = (f - d + p) * a, p = d), d = Math.floor(h + this.xOffset + this.yOffset), f = p / 2 - .5, this.from = a, this.to = b, e ? (this.scrollbarGroup[n]({ translateY: d }), this.scrollbar[n]({ height: p }), this.scrollbarRifles[n]({ translateY: f }), this.scrollbarTop = d, this.scrollbarLeft = 0) : (this.scrollbarGroup[n]({ translateX: d }), this.scrollbar[n]({ width: p }), this.scrollbarRifles[n]({ translateX: f }), this.scrollbarLeft = d, this.scrollbarTop = 0), 12 >= p ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0), !1 === c.showFull && (0 >= a && 1 <= b ? this.group.hide() : this.group.show()), this.rendered = !0);
	      }, initEvents: function initEvents() {
	        var a = this;a.mouseMoveHandler = function (b) {
	          var c = a.chart.pointer.normalize(b),
	              e = a.options.vertical ? "chartY" : "chartX",
	              d = a.initPositions;!a.grabbedCenter || b.touches && 0 === b.touches[0][e] || (c = a.cursorToScrollbarPosition(c)[e], e = a[e], e = c - e, a.hasDragged = !0, a.updatePosition(d[0] + e, d[1] + e), a.hasDragged && n(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMType: b.type, DOMEvent: b }));
	        };a.mouseUpHandler = function (b) {
	          a.hasDragged && n(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMType: b.type, DOMEvent: b });a.grabbedCenter = a.hasDragged = a.chartX = a.chartY = null;
	        };a.mouseDownHandler = function (b) {
	          b = a.chart.pointer.normalize(b);b = a.cursorToScrollbarPosition(b);a.chartX = b.chartX;a.chartY = b.chartY;
	          a.initPositions = [a.from, a.to];a.grabbedCenter = !0;
	        };a.buttonToMinClick = function (b) {
	          var c = H(a.to - a.from) * a.options.step;a.updatePosition(H(a.from - c), H(a.to - c));n(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMEvent: b });
	        };a.buttonToMaxClick = function (b) {
	          var c = (a.to - a.from) * a.options.step;a.updatePosition(a.from + c, a.to + c);n(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMEvent: b });
	        };a.trackClick = function (b) {
	          var c = a.chart.pointer.normalize(b),
	              e = a.to - a.from,
	              d = a.y + a.scrollbarTop,
	              f = a.x + a.scrollbarLeft;
	          a.options.vertical && c.chartY > d || !a.options.vertical && c.chartX > f ? a.updatePosition(a.from + e, a.to + e) : a.updatePosition(a.from - e, a.to - e);n(a, "changed", { from: a.from, to: a.to, trigger: "scrollbar", DOMEvent: b });
	        };
	      }, cursorToScrollbarPosition: function cursorToScrollbarPosition(a) {
	        var b = this.options,
	            b = b.minWidth > this.calculatedWidth ? b.minWidth : 0;return { chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - b), chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - b) };
	      }, updatePosition: function updatePosition(a, b) {
	        1 < b && (a = H(1 - H(b - a)), b = 1);0 > a && (b = H(b - a), a = 0);
	        this.from = a;this.to = b;
	      }, update: function update(a) {
	        this.destroy();this.init(this.chart.renderer, e(!0, this.options, a), this.chart);
	      }, addEvents: function addEvents() {
	        var a = this.options.inverted ? [1, 0] : [0, 1],
	            b = this.scrollbarButtons,
	            c = this.scrollbarGroup.element,
	            e = this.mouseDownHandler,
	            d = this.mouseMoveHandler,
	            h = this.mouseUpHandler,
	            a = [[b[a[0]].element, "click", this.buttonToMinClick], [b[a[1]].element, "click", this.buttonToMaxClick], [this.track.element, "click", this.trackClick], [c, "mousedown", e], [w, "mousemove", d], [w, "mouseup", h]];
	        f && a.push([c, "touchstart", e], [w, "touchmove", d], [w, "touchend", h]);q(a, function (a) {
	          C.apply(null, a);
	        });this._events = a;
	      }, removeEvents: function removeEvents() {
	        q(this._events, function (a) {
	          b.apply(null, a);
	        });this._events = void 0;
	      }, destroy: function destroy() {
	        var a = this.chart.scroller;this.removeEvents();q(["track", "scrollbarRifles", "scrollbar", "scrollbarGroup", "group"], function (a) {
	          this[a] && this[a].destroy && (this[a] = this[a].destroy());
	        }, this);a && this === a.scrollbar && (a.scrollbar = null, r(a.scrollbarButtons));
	      } };t(G.prototype, "init", function (a) {
	      var b = this;a.apply(b, Array.prototype.slice.call(arguments, 1));b.options.scrollbar && b.options.scrollbar.enabled && (b.options.scrollbar.vertical = !b.horiz, b.options.startOnTick = b.options.endOnTick = !1, b.scrollbar = new D(b.chart.renderer, b.options.scrollbar, b.chart), C(b.scrollbar, "changed", function (a) {
	        var c = Math.min(z(b.options.min, b.min), b.min, b.dataMin),
	            d = Math.max(z(b.options.max, b.max), b.max, b.dataMax) - c,
	            e;b.horiz && !b.reversed || !b.horiz && b.reversed ? (e = c + d * this.to, c += d * this.from) : (e = c + d * (1 - this.from), c += d * (1 - this.to));b.setExtremes(c, e, !0, !1, a);
	      }));
	    });t(G.prototype, "render", function (a) {
	      var b = Math.min(z(this.options.min, this.min), this.min, this.dataMin),
	          c = Math.max(z(this.options.max, this.max), this.max, this.dataMax),
	          e = this.scrollbar,
	          d;a.apply(this, Array.prototype.slice.call(arguments, 1));if (e) {
	        this.horiz ? (e.position(this.left, this.top + this.height + 2 + this.chart.scrollbarsOffsets[1] + (this.opposite ? 0 : this.axisTitleMargin + this.offset), this.width, this.height), d = 1) : (e.position(this.left + this.width + 2 + this.chart.scrollbarsOffsets[0] + (this.opposite ? this.axisTitleMargin + this.offset : 0), this.top, this.width, this.height), d = 0);if (!this.opposite && !this.horiz || this.opposite && this.horiz) this.chart.scrollbarsOffsets[d] += this.scrollbar.size + this.scrollbar.options.margin;isNaN(b) || isNaN(c) || !l(this.min) || !l(this.max) ? e.setRange(0, 0) : (d = (this.min - b) / (c - b), b = (this.max - b) / (c - b), this.horiz && !this.reversed || !this.horiz && this.reversed ? e.setRange(d, b) : e.setRange(1 - b, 1 - d));
	      }
	    });t(G.prototype, "getOffset", function (a) {
	      var b = this.horiz ? 2 : 1,
	          c = this.scrollbar;
	      a.apply(this, Array.prototype.slice.call(arguments, 1));c && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[b] += c.size + c.options.margin);
	    });t(G.prototype, "destroy", function (a) {
	      this.scrollbar && (this.scrollbar = this.scrollbar.destroy());a.apply(this, Array.prototype.slice.call(arguments, 1));
	    });a.Scrollbar = D;
	  })(K);(function (a) {
	    function D(a) {
	      this.init(a);
	    }var C = a.addEvent,
	        G = a.Axis,
	        H = a.Chart,
	        v = a.color,
	        l = a.defaultOptions,
	        r = a.defined,
	        w = a.destroyObjectProperties,
	        q = a.doc,
	        n = a.each,
	        f = a.erase,
	        c = a.error,
	        e = a.extend,
	        z = a.grep,
	        b = a.hasTouch,
	        t = a.isNumber,
	        h = a.isObject,
	        B = a.merge,
	        p = a.pick,
	        x = a.removeEvent,
	        k = a.Scrollbar,
	        F = a.Series,
	        d = a.seriesTypes,
	        u = a.wrap,
	        m = a.swapXY,
	        y = [].concat(a.defaultDataGroupingUnits),
	        J = function J(a) {
	      var b = z(arguments, t);if (b.length) return Math[a].apply(0, b);
	    };y[4] = ["day", [1, 2, 3, 4]];y[5] = ["week", [1, 2, 3]];d = void 0 === d.areaspline ? "line" : "areaspline";e(l, { navigator: { height: 40, margin: 25, maskInside: !0, handles: { backgroundColor: "#f2f2f2", borderColor: "#999999" }, maskFill: v("#6685c2").setOpacity(.3).get(), outlineColor: "#cccccc",
	        outlineWidth: 1, series: { type: d, color: "#335cad", fillOpacity: .05, lineWidth: 1, compare: null, dataGrouping: { approximation: "average", enabled: !0, groupPixelWidth: 2, smoothed: !0, units: y }, dataLabels: { enabled: !1, zIndex: 2 }, id: "highcharts-navigator-series", className: "highcharts-navigator-series", lineColor: null, marker: { enabled: !1 }, pointRange: 0, shadow: !1, threshold: null }, xAxis: { className: "highcharts-navigator-xaxis", tickLength: 0, lineWidth: 0, gridLineColor: "#e6e6e6", gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left",
	            style: { color: "#999999" }, x: 3, y: -4 }, crosshair: !1 }, yAxis: { className: "highcharts-navigator-yaxis", gridLineWidth: 0, startOnTick: !1, endOnTick: !1, minPadding: .1, maxPadding: .1, labels: { enabled: !1 }, crosshair: !1, title: { text: null }, tickLength: 0, tickWidth: 0 } } });D.prototype = { drawHandle: function drawHandle(a, b, c, d) {
	        this.handles[b][d](c ? { translateX: Math.round(this.left + this.height / 2 - 8), translateY: Math.round(this.top + parseInt(a, 10) + .5) } : { translateX: Math.round(this.left + parseInt(a, 10)), translateY: Math.round(this.top + this.height / 2 - 8) });
	      }, getHandlePath: function getHandlePath(a) {
	        return m(["M", -4.5, .5, "L", 3.5, .5, "L", 3.5, 15.5, "L", -4.5, 15.5, "L", -4.5, .5, "M", -1.5, 4, "L", -1.5, 12, "M", .5, 4, "L", .5, 12], a);
	      }, drawOutline: function drawOutline(a, b, c, d) {
	        var g = this.navigatorOptions.maskInside,
	            e = this.outline.strokeWidth(),
	            f = e / 2,
	            e = e % 2 / 2,
	            h = this.outlineHeight,
	            k = this.scrollbarHeight,
	            m = this.size,
	            l = this.left - k,
	            n = this.top;c ? (l -= f, c = n + b + e, b = n + a + e, a = ["M", l + h, n - k - e, "L", l + h, c, "L", l, c, "L", l, b, "L", l + h, b, "L", l + h, n + m + k].concat(g ? ["M", l + h, c - f, "L", l + h, b + f] : [])) : (a += l + k - e, b += l + k - e, n += f, a = ["M", l, n, "L", a, n, "L", a, n + h, "L", b, n + h, "L", b, n, "L", l + m + 2 * k, n].concat(g ? ["M", a - f, n, "L", b + f, n] : []));this.outline[d]({ d: a });
	      }, drawMasks: function drawMasks(a, b, c, d) {
	        var g = this.left,
	            e = this.top,
	            f = this.height,
	            h,
	            k,
	            l,
	            m;c ? (l = [g, g, g], m = [e, e + a, e + b], k = [f, f, f], h = [a, b - a, this.size - b]) : (l = [g, g + a, g + b], m = [e, e, e], k = [a, b - a, this.size - b], h = [f, f, f]);n(this.shades, function (a, b) {
	          a[d]({ x: l[b], y: m[b], width: k[b], height: h[b] });
	        });
	      }, renderElements: function renderElements() {
	        var a = this,
	            b = a.navigatorOptions,
	            c = b.maskInside,
	            d = a.chart,
	            e = d.inverted,
	            f = d.renderer,
	            h;a.navigatorGroup = h = f.g("navigator").attr({ zIndex: 8, visibility: "hidden" }).add();var k = { cursor: e ? "ns-resize" : "ew-resize" };n([!c, c, !c], function (c, d) {
	          a.shades[d] = f.rect().addClass("highcharts-navigator-mask" + (1 === d ? "-inside" : "-outside")).attr({ fill: c ? b.maskFill : "transparent" }).css(1 === d && k).add(h);
	        });a.outline = f.path().addClass("highcharts-navigator-outline").attr({ "stroke-width": b.outlineWidth, stroke: b.outlineColor }).add(h);n([0, 1], function (c) {
	          a.handles[c] = f.path(a.getHandlePath(e)).attr({ zIndex: 7 - c }).addClass("highcharts-navigator-handle highcharts-navigator-handle-" + ["left", "right"][c]).add(h);var d = b.handles;a.handles[c].attr({ fill: d.backgroundColor, stroke: d.borderColor, "stroke-width": 1 }).css(k);
	        });
	      }, update: function update(a) {
	        this.destroy();B(!0, this.chart.options.navigator, this.options, a);this.init(this.chart);
	      }, render: function render(a, b, c, d) {
	        var g = this.chart,
	            e,
	            f,
	            h = this.scrollbarHeight,
	            k,
	            l = this.xAxis;e = this.navigatorEnabled;var m,
	            n = this.rendered;f = g.inverted;var q = g.xAxis[0].minRange;if (!this.hasDragged || r(c)) {
	          if (!t(a) || !t(b)) if (n) c = 0, d = l.width;else return;this.left = p(l.left, g.plotLeft + h + (f ? g.plotWidth : 0));this.size = m = k = p(l.len, (f ? g.plotHeight : g.plotWidth) - 2 * h);g = f ? h : k + 2 * h;c = p(c, l.toPixels(a, !0));d = p(d, l.toPixels(b, !0));t(c) && Infinity !== Math.abs(c) || (c = 0, d = g);a = l.toValue(c, !0);b = l.toValue(d, !0);if (Math.abs(b - a) < q) if (this.grabbedLeft) c = l.toPixels(b - q, !0);else if (this.grabbedRight) d = l.toPixels(a + q, !0);else return;this.zoomedMax = Math.min(Math.max(c, d, 0), m);this.zoomedMin = Math.min(Math.max(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(c, d), 0), m);this.range = this.zoomedMax - this.zoomedMin;m = Math.round(this.zoomedMax);c = Math.round(this.zoomedMin);e && (this.navigatorGroup.attr({ visibility: "visible" }), n = n && !this.hasDragged ? "animate" : "attr", this.drawMasks(c, m, f, n), this.drawOutline(c, m, f, n), this.drawHandle(c, 0, f, n), this.drawHandle(m, 1, f, n));this.scrollbar && (f ? (f = this.top - h, e = this.left - h + (e ? 0 : this.height), h = k + 2 * h) : (f = this.top + (e ? this.height : -h), e = this.left - h), this.scrollbar.position(e, f, g, h), this.scrollbar.setRange(this.zoomedMin / k, this.zoomedMax / k));this.rendered = !0;
	        }
	      }, addMouseEvents: function addMouseEvents() {
	        var a = this,
	            c = a.chart,
	            d = c.container,
	            e = [],
	            f,
	            h;a.mouseMoveHandler = f = function f(b) {
	          a.onMouseMove(b);
	        };a.mouseUpHandler = h = function h(b) {
	          a.onMouseUp(b);
	        };e = a.getPartsEvents("mousedown");e.push(C(d, "mousemove", f), C(q, "mouseup", h));b && (e.push(C(d, "touchmove", f), C(q, "touchend", h)), e.concat(a.getPartsEvents("touchstart")));a.eventsToUnbind = e;a.series && a.series[0] && e.push(C(a.series[0].xAxis, "foundExtremes", function () {
	          c.navigator.modifyNavigatorAxisExtremes();
	        }));
	      },
	      getPartsEvents: function getPartsEvents(a) {
	        var b = this,
	            c = [];n(["shades", "handles"], function (d) {
	          n(b[d], function (g, e) {
	            c.push(C(g.element, a, function (a) {
	              b[d + "Mousedown"](a, e);
	            }));
	          });
	        });return c;
	      }, shadesMousedown: function shadesMousedown(a, b) {
	        a = this.chart.pointer.normalize(a);var c = this.chart,
	            d = this.xAxis,
	            e = this.zoomedMin,
	            f = this.left,
	            h = this.size,
	            k = this.range,
	            l = a.chartX,
	            m;c.inverted && (l = a.chartY, f = this.top);1 === b ? (this.grabbedCenter = l, this.fixedWidth = k, this.dragOffset = l - e) : (a = l - f - k / 2, 0 === b ? a = Math.max(0, a) : 2 === b && a + k >= h && (a = h - k, m = this.getUnionExtremes().dataMax), a !== e && (this.fixedWidth = k, b = d.toFixedRange(a, a + k, null, m), c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, { trigger: "navigator" })));
	      }, handlesMousedown: function handlesMousedown(a, b) {
	        this.chart.pointer.normalize(a);a = this.chart;var c = a.xAxis[0],
	            d = a.inverted && !c.reversed || !a.inverted && c.reversed;0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);a.fixedRange = null;
	      },
	      onMouseMove: function onMouseMove(a) {
	        var b = this,
	            c = b.chart,
	            d = b.left,
	            e = b.navigatorSize,
	            f = b.range,
	            h = b.dragOffset,
	            k = c.inverted;a.touches && 0 === a.touches[0].pageX || (a = c.pointer.normalize(a), c = a.chartX, k && (d = b.top, c = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, c - d, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, c - d)) : b.grabbedCenter && (b.hasDragged = !0, c < h ? c = h : c > e + h - f && (c = e + h - f), b.render(0, 0, c - h, c - h + f)), b.hasDragged && b.scrollbar && b.scrollbar.options.liveRedraw && (a.DOMType = a.type, setTimeout(function () {
	          b.onMouseUp(a);
	        }, 0)));
	      }, onMouseUp: function onMouseUp(a) {
	        var b = this.chart,
	            c = this.xAxis,
	            d = this.scrollbar,
	            e,
	            f,
	            h = a.DOMEvent || a;(!this.hasDragged || d && d.hasDragged) && "scrollbar" !== a.trigger || (this.zoomedMin === this.otherHandlePos ? e = this.fixedExtreme : this.zoomedMax === this.otherHandlePos && (f = this.fixedExtreme), this.zoomedMax === this.size && (f = this.getUnionExtremes().dataMax), c = c.toFixedRange(this.zoomedMin, this.zoomedMax, e, f), r(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: h }));"mousemove" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);
	      }, removeEvents: function removeEvents() {
	        this.eventsToUnbind && (n(this.eventsToUnbind, function (a) {
	          a();
	        }), this.eventsToUnbind = void 0);this.removeBaseSeriesEvents();
	      }, removeBaseSeriesEvents: function removeBaseSeriesEvents() {
	        var a = this.baseSeries || [];this.navigatorEnabled && a[0] && !1 !== this.navigatorOptions.adaptToUpdatedData && (n(a, function (a) {
	          x(a, "updatedData", this.updatedDataHandler);
	        }, this), a[0].xAxis && x(a[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes));
	      }, init: function init(a) {
	        var b = a.options,
	            c = b.navigator,
	            d = c.enabled,
	            e = b.scrollbar,
	            f = e.enabled,
	            b = d ? c.height : 0,
	            h = f ? e.height : 0;this.handles = [];this.shades = [];this.chart = a;this.setBaseSeries();this.height = b;this.scrollbarHeight = h;this.scrollbarEnabled = f;this.navigatorEnabled = d;this.navigatorOptions = c;this.scrollbarOptions = e;this.outlineHeight = b + h;this.opposite = p(c.opposite, !d && a.inverted);var l = this,
	            e = l.baseSeries,
	            f = a.xAxis.length,
	            m = a.yAxis.length,
	            n = e && e[0] && e[0].xAxis || a.xAxis[0];a.extraMargin = { type: l.opposite ? "plotTop" : "marginBottom", value: (d || !a.inverted ? l.outlineHeight : 0) + c.margin };a.inverted && (a.extraMargin.type = l.opposite ? "marginRight" : "plotLeft");a.isDirtyBox = !0;l.navigatorEnabled ? (l.xAxis = new G(a, B({ breaks: n.options.breaks, ordinal: n.options.ordinal }, c.xAxis, { id: "navigator-x-axis", yAxis: "navigator-y-axis", isX: !0, type: "datetime",
	          index: f, offset: 0, keepOrdinalPadding: !0, startOnTick: !1, endOnTick: !1, minPadding: 0, maxPadding: 0, zoomEnabled: !1 }, a.inverted ? { offsets: [h, 0, -h, 0], width: b } : { offsets: [0, -h, 0, h], height: b })), l.yAxis = new G(a, B(c.yAxis, { id: "navigator-y-axis", alignTicks: !1, offset: 0, index: m, zoomEnabled: !1 }, a.inverted ? { width: b } : { height: b })), e || c.series.data ? l.addBaseSeries() : 0 === a.series.length && u(a, "redraw", function (b, c) {
	          0 < a.series.length && !l.series && (l.setBaseSeries(), a.redraw = b);b.call(a, c);
	        }), l.renderElements(), l.addMouseEvents()) : l.xAxis = { translate: function translate(b, c) {
	            var d = a.xAxis[0],
	                g = d.getExtremes(),
	                e = d.len - 2 * h,
	                f = J("min", d.options.min, g.dataMin),
	                d = J("max", d.options.max, g.dataMax) - f;return c ? b * d / e + f : e * (b - f) / d;
	          }, toPixels: function toPixels(a) {
	            return this.translate(a);
	          }, toValue: function toValue(a) {
	            return this.translate(a, !0);
	          }, toFixedRange: G.prototype.toFixedRange, fake: !0 };a.options.scrollbar.enabled && (a.scrollbar = l.scrollbar = new k(a.renderer, B(a.options.scrollbar, { margin: l.navigatorEnabled ? 0 : 10, vertical: a.inverted }), a), C(l.scrollbar, "changed", function (b) {
	          var c = l.size,
	              d = c * this.to,
	              c = c * this.from;l.hasDragged = l.scrollbar.hasDragged;l.render(0, 0, c, d);(a.options.scrollbar.liveRedraw || "mousemove" !== b.DOMType) && setTimeout(function () {
	            l.onMouseUp(b);
	          });
	        }));l.addBaseSeriesEvents();l.addChartEvents();
	      }, getUnionExtremes: function getUnionExtremes(a) {
	        var b = this.chart.xAxis[0],
	            c = this.xAxis,
	            d = c.options,
	            e = b.options,
	            f;a && null === b.dataMin || (f = { dataMin: p(d && d.min, J("min", e.min, b.dataMin, c.dataMin, c.min)), dataMax: p(d && d.max, J("max", e.max, b.dataMax, c.dataMax, c.max)) });return f;
	      }, setBaseSeries: function setBaseSeries(a) {
	        var b = this.chart,
	            c;a = a || b.options && b.options.navigator.baseSeries || 0;this.series && (this.removeBaseSeriesEvents(), n(this.series, function (a) {
	          a.destroy();
	        }));c = this.baseSeries = [];n(b.series || [], function (b, d) {
	          (b.options.showInNavigator || (d === a || b.options.id === a) && !1 !== b.options.showInNavigator) && c.push(b);
	        });this.xAxis && !this.xAxis.fake && this.addBaseSeries();
	      }, addBaseSeries: function addBaseSeries() {
	        var a = this,
	            b = a.chart,
	            c = a.series = [],
	            d = a.baseSeries,
	            e,
	            f,
	            h = a.navigatorOptions.series,
	            k,
	            l = { enableMouseTracking: !1, index: null, group: "nav",
	          padXAxis: !1, xAxis: "navigator-x-axis", yAxis: "navigator-y-axis", showInLegend: !1, stacking: !1, isInternal: !0, visible: !0 };d ? n(d, function (d, g) {
	          l.name = "Navigator " + (g + 1);e = d.options || {};k = e.navigatorOptions || {};f = B(e, l, h, k);g = k.data || h.data;a.hasNavigatorData = a.hasNavigatorData || !!g;f.data = g || e.data && e.data.slice(0);d.navigatorSeries = b.initSeries(f);c.push(d.navigatorSeries);
	        }) : (f = B(h, l), f.data = h.data, a.hasNavigatorData = !!f.data, c.push(b.initSeries(f)));this.addBaseSeriesEvents();
	      }, addBaseSeriesEvents: function addBaseSeriesEvents() {
	        var a = this,
	            b = a.baseSeries || [];b[0] && b[0].xAxis && C(b[0].xAxis, "foundExtremes", this.modifyBaseAxisExtremes);!1 !== this.navigatorOptions.adaptToUpdatedData && n(b, function (b) {
	          b.xAxis && C(b, "updatedData", this.updatedDataHandler);C(b, "remove", function () {
	            this.navigatorSeries && (f(a.series, this.navigatorSeries), this.navigatorSeries.remove(!1), delete this.navigatorSeries);
	          });
	        }, this);
	      }, modifyNavigatorAxisExtremes: function modifyNavigatorAxisExtremes() {
	        var a = this.xAxis,
	            b;a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));
	      }, modifyBaseAxisExtremes: function modifyBaseAxisExtremes() {
	        var a = this.chart.navigator,
	            b = this.getExtremes(),
	            c = b.dataMin,
	            d = b.dataMax,
	            b = b.max - b.min,
	            e = a.stickToMin,
	            f = a.stickToMax,
	            h,
	            k,
	            l = a.series && a.series[0],
	            m = !!this.setExtremes;this.eventArgs && "rangeSelectorButton" === this.eventArgs.trigger || (e && (k = c, h = k + b), f && (h = d, e || (k = Math.max(h - b, l && l.xData ? l.xData[0] : -Number.MAX_VALUE))), m && (e || f) && t(k) && (this.min = this.userMin = k, this.max = this.userMax = h));a.stickToMin = a.stickToMax = null;
	      }, updatedDataHandler: function updatedDataHandler() {
	        var a = this.chart.navigator,
	            b = this.navigatorSeries;a.stickToMin = t(this.xAxis.min) && this.xAxis.min <= this.xData[0];a.stickToMax = Math.round(a.zoomedMax) >= Math.round(a.size);b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));
	      }, addChartEvents: function addChartEvents() {
	        C(this.chart, "redraw", function () {
	          var a = this.navigator,
	              b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || a.scrollbar && this.xAxis[0]);b && a.render(b.min, b.max);
	        });
	      }, destroy: function destroy() {
	        this.removeEvents();this.xAxis && (f(this.chart.xAxis, this.xAxis), f(this.chart.axes, this.xAxis));this.yAxis && (f(this.chart.yAxis, this.yAxis), f(this.chart.axes, this.yAxis));n(this.series || [], function (a) {
	          a.destroy && a.destroy();
	        });n("series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered".split(" "), function (a) {
	          this[a] && this[a].destroy && this[a].destroy();this[a] = null;
	        }, this);n([this.handles], function (a) {
	          w(a);
	        }, this);
	      } };a.Navigator = D;u(G.prototype, "zoom", function (a, b, c) {
	      var d = this.chart,
	          e = d.options,
	          g = e.chart.zoomType,
	          f = e.navigator,
	          e = e.rangeSelector,
	          h;this.isXAxis && (f && f.enabled || e && e.enabled) && ("x" === g ? d.resetZoomButton = "blocked" : "y" === g ? h = !1 : "xy" === g && (d = this.previousZoom, r(b) ? this.previousZoom = [this.min, this.max] : d && (b = d[0], c = d[1], delete this.previousZoom)));return void 0 !== h ? h : a.call(this, b, c);
	    });u(H.prototype, "init", function (a, b, c) {
	      C(this, "beforeRender", function () {
	        var a = this.options;if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new D(this);
	      });a.call(this, b, c);
	    });u(H.prototype, "setChartSize", function (a) {
	      var b = this.legend,
	          c = this.navigator,
	          d,
	          e,
	          f,
	          h;a.apply(this, [].slice.call(arguments, 1));c && (e = b.options, f = c.xAxis, h = c.yAxis, d = c.scrollbarHeight, this.inverted ? (c.left = c.opposite ? this.chartWidth - d - c.height : this.spacing[3] + d, c.top = this.plotTop + d) : (c.left = this.plotLeft + d, c.top = c.navigatorOptions.top || this.chartHeight - c.height - d - this.spacing[2] - ("bottom" === e.verticalAlign && e.enabled && !e.floating ? b.legendHeight + p(e.margin, 10) : 0)), f && h && (this.inverted ? f.options.left = h.options.left = c.left : f.options.top = h.options.top = c.top, f.setAxisSize(), h.setAxisSize()));
	    });u(F.prototype, "addPoint", function (a, b, d, e, f) {
	      var g = this.options.turboThreshold;g && this.xData.length > g && h(b, !0) && this.chart.navigator && c(20, !0);a.call(this, b, d, e, f);
	    });u(H.prototype, "addSeries", function (a, b, c, d) {
	      a = a.call(this, b, !1, d);this.navigator && this.navigator.setBaseSeries();p(c, !0) && this.redraw();return a;
	    });u(F.prototype, "update", function (a, b, c) {
	      a.call(this, b, !1);this.chart.navigator && this.chart.navigator.setBaseSeries();
	      p(c, !0) && this.chart.redraw();
	    });H.prototype.callbacks.push(function (a) {
	      var b = a.navigator;b && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));
	    });
	  })(K);(function (a) {
	    function D(a) {
	      this.init(a);
	    }var C = a.addEvent,
	        G = a.Axis,
	        H = a.Chart,
	        v = a.css,
	        l = a.createElement,
	        r = a.dateFormat,
	        w = a.defaultOptions,
	        q = w.global.useUTC,
	        n = a.defined,
	        f = a.destroyObjectProperties,
	        c = a.discardElement,
	        e = a.each,
	        z = a.extend,
	        b = a.fireEvent,
	        t = a.Date,
	        h = a.isNumber,
	        B = a.merge,
	        p = a.pick,
	        x = a.pInt,
	        k = a.splat,
	        F = a.wrap;z(w, { rangeSelector: { buttonTheme: { "stroke-width": 0,
	          width: 28, height: 18, padding: 2, zIndex: 7 }, height: 35, inputPosition: { align: "right" }, labelStyle: { color: "#666666" } } });w.lang = B(w.lang, { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "From", rangeSelectorTo: "To" });D.prototype = { clickButton: function clickButton(a, b) {
	        var c = this,
	            d = c.chart,
	            f = c.buttonOptions[a],
	            l = d.xAxis[0],
	            n = d.scroller && d.scroller.getUnionExtremes() || l || {},
	            g = n.dataMin,
	            r = n.dataMax,
	            t,
	            u = l && Math.round(Math.min(l.max, p(r, l.max))),
	            v = f.type,
	            w,
	            n = f._range,
	            x,
	            z,
	            B,
	            D = f.dataGrouping;if (null !== g && null !== r) {
	          d.fixedRange = n;D && (this.forcedDataGrouping = !0, G.prototype.setDataGrouping.call(l || { chart: this.chart }, D, !1));if ("month" === v || "year" === v) l ? (v = { range: f, max: u, dataMin: g, dataMax: r }, t = l.minFromRange.call(v), h(v.newMax) && (u = v.newMax)) : n = f;else if (n) t = Math.max(u - n, g), u = Math.min(t + n, r);else if ("ytd" === v) {
	            if (l) void 0 === r && (g = Number.MAX_VALUE, r = Number.MIN_VALUE, e(d.series, function (a) {
	              a = a.xData;g = Math.min(a[0], g);r = Math.max(a[a.length - 1], r);
	            }), b = !1), u = c.getYTDExtremes(r, g, q), t = x = u.min, u = u.max;else {
	              C(d, "beforeRender", function () {
	                c.clickButton(a);
	              });
	              return;
	            }
	          } else "all" === v && l && (t = g, u = r);c.setSelected(a);l ? l.setExtremes(t, u, p(b, 1), null, { trigger: "rangeSelectorButton", rangeSelectorButton: f }) : (w = k(d.options.xAxis)[0], B = w.range, w.range = n, z = w.min, w.min = x, C(d, "load", function () {
	            w.range = B;w.min = z;
	          }));
	        }
	      }, setSelected: function setSelected(a) {
	        this.selected = this.options.selected = a;
	      }, defaultButtons: [{ type: "month", count: 1, text: "1m" }, { type: "month", count: 3, text: "3m" }, { type: "month", count: 6, text: "6m" }, { type: "ytd", text: "YTD" }, { type: "year", count: 1, text: "1y" }, { type: "all", text: "All" }],
	      init: function init(a) {
	        var c = this,
	            d = a.options.rangeSelector,
	            f = d.buttons || [].concat(c.defaultButtons),
	            h = d.selected,
	            k = function k() {
	          var a = c.minInput,
	              d = c.maxInput;a && a.blur && b(a, "blur");d && d.blur && b(d, "blur");
	        };c.chart = a;c.options = d;c.buttons = [];a.extraTopMargin = d.height;c.buttonOptions = f;this.unMouseDown = C(a.container, "mousedown", k);this.unResize = C(a, "resize", k);e(f, c.computeButtonRange);void 0 !== h && f[h] && this.clickButton(h, !1);C(a, "load", function () {
	          C(a.xAxis[0], "setExtremes", function (b) {
	            this.max - this.min !== a.fixedRange && "rangeSelectorButton" !== b.trigger && "updatedData" !== b.trigger && c.forcedDataGrouping && this.setDataGrouping(!1, !1);
	          });
	        });
	      }, updateButtonStates: function updateButtonStates() {
	        var a = this.chart,
	            b = a.xAxis[0],
	            c = Math.round(b.max - b.min),
	            f = !b.hasVisibleSeries,
	            a = a.scroller && a.scroller.getUnionExtremes() || b,
	            k = a.dataMin,
	            l = a.dataMax,
	            a = this.getYTDExtremes(l, k, q),
	            n = a.min,
	            g = a.max,
	            p = this.selected,
	            r = h(p),
	            t = this.options.allButtonsEnabled,
	            v = this.buttons;e(this.buttonOptions, function (a, d) {
	          var e = a._range,
	              h = a.type,
	              m = a.count || 1;a = v[d];
	          var q = 0;d = d === p;var u = e > l - k,
	              y = e < b.minRange,
	              w = !1,
	              x = !1,
	              e = e === c;("month" === h || "year" === h) && c >= 864E5 * { month: 28, year: 365 }[h] * m && c <= 864E5 * { month: 31, year: 366 }[h] * m ? e = !0 : "ytd" === h ? (e = g - n === c, w = !d) : "all" === h && (e = b.max - b.min >= l - k, x = !d && r && e);h = !t && (u || y || x || f);e = d && e || e && !r && !w;h ? q = 3 : e && (r = !0, q = 2);a.state !== q && a.setState(q);
	        });
	      }, computeButtonRange: function computeButtonRange(a) {
	        var b = a.type,
	            c = a.count || 1,
	            d = { millisecond: 1, second: 1E3, minute: 6E4, hour: 36E5, day: 864E5, week: 6048E5 };if (d[b]) a._range = d[b] * c;else if ("month" === b || "year" === b) a._range = 864E5 * { month: 30, year: 365 }[b] * c;
	      }, setInputValue: function setInputValue(a, b) {
	        var c = this.chart.options.rangeSelector,
	            d = this[a + "Input"];n(b) && (d.previousValue = d.HCTime, d.HCTime = b);d.value = r(c.inputEditDateFormat || "%Y-%m-%d", d.HCTime);this[a + "DateBox"].attr({ text: r(c.inputDateFormat || "%b %e, %Y", d.HCTime) });
	      }, showInput: function showInput(a) {
	        var b = this.inputGroup,
	            c = this[a + "DateBox"];v(this[a + "Input"], { left: b.translateX + c.x + "px", top: b.translateY + "px", width: c.width - 2 + "px", height: c.height - 2 + "px", border: "2px solid silver" });
	      },
	      hideInput: function hideInput(a) {
	        v(this[a + "Input"], { border: 0, width: "1px", height: "1px" });this.setInputValue(a);
	      }, drawInput: function drawInput(a) {
	        function b() {
	          var a = p.value,
	              b = (k.inputDateParser || Date.parse)(a),
	              e = d.xAxis[0],
	              g = d.scroller && d.scroller.xAxis ? d.scroller.xAxis : e,
	              f = g.dataMin,
	              g = g.dataMax;b !== p.previousValue && (p.previousValue = b, h(b) || (b = a.split("-"), b = Date.UTC(x(b[0]), x(b[1]) - 1, x(b[2]))), h(b) && (q || (b += 6E4 * new Date().getTimezoneOffset()), n ? b > c.maxInput.HCTime ? b = void 0 : b < f && (b = f) : b < c.minInput.HCTime ? b = void 0 : b > g && (b = g), void 0 !== b && e.setExtremes(n ? b : e.min, n ? e.max : b, void 0, void 0, { trigger: "rangeSelectorInput" })));
	        }var c = this,
	            d = c.chart,
	            e = d.renderer.style || {},
	            f = d.renderer,
	            k = d.options.rangeSelector,
	            g = c.div,
	            n = "min" === a,
	            p,
	            r,
	            t = this.inputGroup;this[a + "Label"] = r = f.label(w.lang[n ? "rangeSelectorFrom" : "rangeSelectorTo"], this.inputGroup.offset).addClass("highcharts-range-label").attr({ padding: 2 }).add(t);t.offset += r.width + 5;this[a + "DateBox"] = f = f.label("", t.offset).addClass("highcharts-range-input").attr({ padding: 2, width: k.inputBoxWidth || 90, height: k.inputBoxHeight || 17, stroke: k.inputBoxBorderColor || "#cccccc", "stroke-width": 1, "text-align": "center" }).on("click", function () {
	          c.showInput(a);c[a + "Input"].focus();
	        }).add(t);t.offset += f.width + (n ? 10 : 0);this[a + "Input"] = p = l("input", { name: a, className: "highcharts-range-selector", type: "text" }, { top: d.plotTop + "px" }, g);r.css(B(e, k.labelStyle));f.css(B({ color: "#333333" }, e, k.inputStyle));v(p, z({ position: "absolute", border: 0, width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: e.fontSize, fontFamily: e.fontFamily,
	          left: "-9em" }, k.inputStyle));p.onfocus = function () {
	          c.showInput(a);
	        };p.onblur = function () {
	          c.hideInput(a);
	        };p.onchange = b;p.onkeypress = function (a) {
	          13 === a.keyCode && b();
	        };
	      }, getPosition: function getPosition() {
	        var a = this.chart,
	            b = a.options.rangeSelector,
	            a = p((b.buttonPosition || {}).y, a.plotTop - a.axisOffset[0] - b.height);return { buttonTop: a, inputTop: a - 10 };
	      }, getYTDExtremes: function getYTDExtremes(a, b, c) {
	        var d = new t(a),
	            e = d[t.hcGetFullYear]();c = c ? t.UTC(e, 0, 1) : +new t(e, 0, 1);b = Math.max(b || 0, c);d = d.getTime();return { max: Math.min(a || d, d), min: b };
	      }, render: function render(a, b) {
	        var c = this,
	            d = c.chart,
	            f = d.renderer,
	            h = d.container,
	            k = d.options,
	            g = k.exporting && !1 !== k.exporting.enabled && k.navigation && k.navigation.buttonOptions,
	            q = k.rangeSelector,
	            r = c.buttons,
	            k = w.lang,
	            t = c.div,
	            t = c.inputGroup,
	            u = q.buttonTheme,
	            v = q.buttonPosition || {},
	            x = q.inputEnabled,
	            B = u && u.states,
	            C = d.plotLeft,
	            D,
	            F = this.getPosition(),
	            G = c.group,
	            H = c.rendered;!1 !== q.enabled && (H || (c.group = G = f.g("range-selector-buttons").add(), c.zoomText = f.text(k.rangeSelectorZoom, p(v.x, C), 15).css(q.labelStyle).add(G), D = p(v.x, C) + c.zoomText.getBBox().width + 5, e(c.buttonOptions, function (a, b) {
	          r[b] = f.button(a.text, D, 0, function () {
	            c.clickButton(b);c.isActive = !0;
	          }, u, B && B.hover, B && B.select, B && B.disabled).attr({ "text-align": "center" }).add(G);D += r[b].width + p(q.buttonSpacing, 5);
	        }), !1 !== x && (c.div = t = l("div", null, { position: "relative", height: 0, zIndex: 1 }), h.parentNode.insertBefore(t, h), c.inputGroup = t = f.g("input-group").add(), t.offset = 0, c.drawInput("min"), c.drawInput("max"))), c.updateButtonStates(), G[H ? "animate" : "attr"]({ translateY: F.buttonTop }), !1 !== x && (t.align(z({ y: F.inputTop,
	          width: t.offset, x: g && F.inputTop < (g.y || 0) + g.height - d.spacing[0] ? -40 : 0 }, q.inputPosition), !0, d.spacingBox), n(x) || (d = G.getBBox(), t[t.alignAttr.translateX < d.x + d.width + 10 ? "hide" : "show"]()), c.setInputValue("min", a), c.setInputValue("max", b)), c.rendered = !0);
	      }, update: function update(a) {
	        var b = this.chart;B(!0, b.options.rangeSelector, a);this.destroy();this.init(b);
	      }, destroy: function destroy() {
	        var a = this.minInput,
	            b = this.maxInput,
	            e;this.unMouseDown();this.unResize();f(this.buttons);a && (a.onfocus = a.onblur = a.onchange = null);b && (b.onfocus = b.onblur = b.onchange = null);for (e in this) {
	          this[e] && "chart" !== e && (this[e].destroy ? this[e].destroy() : this[e].nodeType && c(this[e])), this[e] !== D.prototype[e] && (this[e] = null);
	        }
	      } };G.prototype.toFixedRange = function (a, b, c, e) {
	      var d = this.chart && this.chart.fixedRange;a = p(c, this.translate(a, !0, !this.horiz));b = p(e, this.translate(b, !0, !this.horiz));c = d && (b - a) / d;.7 < c && 1.3 > c && (e ? a = b - d : b = a + d);h(a) || (a = b = void 0);return { min: a, max: b };
	    };G.prototype.minFromRange = function () {
	      var a = this.range,
	          b = { month: "Month", year: "FullYear" }[a.type],
	          c,
	          e = this.max,
	          f,
	          k,
	          l = function l(a, c) {
	        var d = new Date(a);d["set" + b](d["get" + b]() + c);return d.getTime() - a;
	      };h(a) ? (c = e - a, k = a) : (c = e + l(e, -a.count), this.chart && (this.chart.fixedRange = e - c));f = p(this.dataMin, Number.MIN_VALUE);h(c) || (c = f);c <= f && (c = f, void 0 === k && (k = l(c, a.count)), this.newMax = Math.min(c + k, this.dataMax));h(e) || (c = void 0);return c;
	    };F(H.prototype, "init", function (a, b, c) {
	      C(this, "init", function () {
	        this.options.rangeSelector.enabled && (this.rangeSelector = new D(this));
	      });a.call(this, b, c);
	    });H.prototype.callbacks.push(function (a) {
	      function b() {
	        c = a.xAxis[0].getExtremes();h(c.min) && d.render(c.min, c.max);
	      }var c,
	          d = a.rangeSelector,
	          e,
	          f;d && (f = C(a.xAxis[0], "afterSetExtremes", function (a) {
	        d.render(a.min, a.max);
	      }), e = C(a, "redraw", b), b());C(a, "destroy", function () {
	        d && (e(), f());
	      });
	    });a.RangeSelector = D;
	  })(K);(function (a) {
	    var D = a.arrayMax,
	        C = a.arrayMin,
	        G = a.Axis,
	        H = a.Chart,
	        v = a.defined,
	        l = a.each,
	        r = a.extend,
	        w = a.format,
	        q = a.inArray,
	        n = a.isNumber,
	        f = a.isString,
	        c = a.map,
	        e = a.merge,
	        z = a.pick,
	        b = a.Point,
	        t = a.Renderer,
	        h = a.Series,
	        B = a.splat,
	        p = a.SVGRenderer,
	        x = a.VMLRenderer,
	        k = a.wrap,
	        F = h.prototype,
	        d = F.init,
	        u = F.processData,
	        m = b.prototype.tooltipFormatter;a.StockChart = a.stockChart = function (b, d, h) {
	      var k = f(b) || b.nodeName,
	          g = arguments[k ? 1 : 0],
	          l = g.series,
	          m = a.getOptions(),
	          n,
	          p = z(g.navigator && g.navigator.enabled, m.navigator.enabled, !0),
	          q = p ? { startOnTick: !1, endOnTick: !1 } : null,
	          r = { marker: { enabled: !1, radius: 2 } },
	          t = { shadow: !1, borderWidth: 0 };g.xAxis = c(B(g.xAxis || {}), function (a) {
	        return e({ minPadding: 0, maxPadding: 0, ordinal: !0, title: { text: null }, labels: { overflow: "justify" }, showLastLabel: !0 }, m.xAxis, a, { type: "datetime", categories: null }, q);
	      });g.yAxis = c(B(g.yAxis || {}), function (a) {
	        n = z(a.opposite, !0);return e({ labels: { y: -2 }, opposite: n, showLastLabel: !1, title: { text: null } }, m.yAxis, a);
	      });g.series = null;g = e({ chart: { panning: !0, pinchType: "x" }, navigator: { enabled: p }, scrollbar: { enabled: z(m.scrollbar.enabled, !0) }, rangeSelector: { enabled: z(m.rangeSelector.enabled, !0) }, title: { text: null }, tooltip: { shared: !0, crosshairs: !0 }, legend: { enabled: !1 }, plotOptions: { line: r, spline: r, area: r, areaspline: r, arearange: r, areasplinerange: r,
	          column: t, columnrange: t, candlestick: t, ohlc: t } }, g, { isStock: !0 });g.series = l;return k ? new H(b, g, h) : new H(g, d);
	    };k(G.prototype, "autoLabelAlign", function (a) {
	      var b = this.chart,
	          c = this.options,
	          b = b._labelPanes = b._labelPanes || {},
	          d = this.options.labels;return this.chart.options.isStock && "yAxis" === this.coll && (c = c.top + "," + c.height, !b[c] && d.enabled) ? (15 === d.x && (d.x = 0), void 0 === d.align && (d.align = "right"), b[c] = this, "right") : a.call(this, [].slice.call(arguments, 1));
	    });k(G.prototype, "destroy", function (a) {
	      var b = this.chart,
	          c = this.options && this.options.top + "," + this.options.height;c && b._labelPanes && b._labelPanes[c] === this && delete b._labelPanes[c];return a.call(this, Array.prototype.slice.call(arguments, 1));
	    });k(G.prototype, "getPlotLinePath", function (a, b, d, e, g, h) {
	      var k = this,
	          m = this.isLinked && !this.series ? this.linkedParent.series : this.series,
	          p = k.chart,
	          r = p.renderer,
	          t = k.left,
	          u = k.top,
	          w,
	          x,
	          y,
	          B,
	          E = [],
	          C = [],
	          D,
	          F;if ("colorAxis" === k.coll) return a.apply(this, [].slice.call(arguments, 1));C = function (a) {
	        var b = "xAxis" === a ? "yAxis" : "xAxis";a = k.options[b];return n(a) ? [p[b][a]] : f(a) ? [p.get(a)] : c(m, function (a) {
	          return a[b];
	        });
	      }(k.coll);l(k.isXAxis ? p.yAxis : p.xAxis, function (a) {
	        if (v(a.options.id) ? -1 === a.options.id.indexOf("navigator") : 1) {
	          var b = a.isXAxis ? "yAxis" : "xAxis",
	              b = v(a.options[b]) ? p[b][a.options[b]] : p[b][0];k === b && C.push(a);
	        }
	      });D = C.length ? [] : [k.isXAxis ? p.yAxis[0] : p.xAxis[0]];l(C, function (a) {
	        -1 === q(a, D) && D.push(a);
	      });F = z(h, k.translate(b, null, null, e));n(F) && (k.horiz ? l(D, function (a) {
	        var b;x = a.pos;B = x + a.len;w = y = Math.round(F + k.transB);if (w < t || w > t + k.width) g ? w = y = Math.min(Math.max(t, w), t + k.width) : b = !0;b || E.push("M", w, x, "L", y, B);
	      }) : l(D, function (a) {
	        var b;w = a.pos;y = w + a.len;x = B = Math.round(u + k.height - F);if (x < u || x > u + k.height) g ? x = B = Math.min(Math.max(u, x), k.top + k.height) : b = !0;b || E.push("M", w, x, "L", y, B);
	      }));return 0 < E.length ? r.crispPolyLine(E, d || 1) : null;
	    });G.prototype.getPlotBandPath = function (a, b) {
	      b = this.getPlotLinePath(b, null, null, !0);a = this.getPlotLinePath(a, null, null, !0);var c = [],
	          d;if (a && b) {
	        if (a.toString() === b.toString()) c = a, c.flat = !0;else for (d = 0; d < a.length; d += 6) {
	          c.push("M", a[d + 1], a[d + 2], "L", a[d + 4], a[d + 5], b[d + 4], b[d + 5], b[d + 1], b[d + 2], "z");
	        }
	      } else c = null;return c;
	    };p.prototype.crispPolyLine = function (a, b) {
	      var c;for (c = 0; c < a.length; c += 6) {
	        a[c + 1] === a[c + 4] && (a[c + 1] = a[c + 4] = Math.round(a[c + 1]) - b % 2 / 2), a[c + 2] === a[c + 5] && (a[c + 2] = a[c + 5] = Math.round(a[c + 2]) + b % 2 / 2);
	      }return a;
	    };t === x && (x.prototype.crispPolyLine = p.prototype.crispPolyLine);k(G.prototype, "hideCrosshair", function (a, b) {
	      a.call(this, b);this.crossLabel && (this.crossLabel = this.crossLabel.hide());
	    });k(G.prototype, "drawCrosshair", function (a, b, c) {
	      var d, e;a.call(this, b, c);if (v(this.crosshair.label) && this.crosshair.label.enabled && this.cross) {
	        a = this.chart;var f = this.options.crosshair.label,
	            h = this.horiz;d = this.opposite;e = this.left;var k = this.top,
	            l = this.crossLabel,
	            m,
	            n = f.format,
	            p = "",
	            q = "inside" === this.options.tickPosition,
	            t = !1 !== this.crosshair.snap,
	            u = 0;b || (b = this.cross && this.cross.e);m = h ? "center" : d ? "right" === this.labelAlign ? "right" : "left" : "left" === this.labelAlign ? "left" : "center";l || (l = this.crossLabel = a.renderer.label(null, null, null, f.shape || "callout").addClass("highcharts-crosshair-label" + (this.series[0] && " highcharts-color-" + this.series[0].colorIndex)).attr({ align: f.align || m, padding: z(f.padding, 8), r: z(f.borderRadius, 3), zIndex: 2 }).add(this.labelGroup), l.attr({ fill: f.backgroundColor || this.series[0] && this.series[0].color || "#666666", stroke: f.borderColor || "", "stroke-width": f.borderWidth || 0 }).css(r({ color: "#ffffff", fontWeight: "normal", fontSize: "11px", textAlign: "center" }, f.style)));h ? (m = t ? c.plotX + e : b.chartX, k += d ? 0 : this.height) : (m = d ? this.width + e : 0, k = t ? c.plotY + k : b.chartY);n || f.formatter || (this.isDatetimeAxis && (p = "%b %d, %Y"), n = "{value" + (p ? ":" + p : "") + "}");b = t ? c[this.isXAxis ? "x" : "y"] : this.toValue(h ? b.chartX : b.chartY);l.attr({ text: n ? w(n, { value: b }) : f.formatter.call(this, b), x: m, y: k, visibility: "visible" });b = l.getBBox();if (h) {
	          if (q && !d || !q && d) k = l.y - b.height;
	        } else k = l.y - b.height / 2;h ? (d = e - b.x, e = e + this.width - b.x) : (d = "left" === this.labelAlign ? e : 0, e = "right" === this.labelAlign ? e + this.width : a.chartWidth);l.translateX < d && (u = d - l.translateX);
	        l.translateX + b.width >= e && (u = -(l.translateX + b.width - e));l.attr({ x: m + u, y: k, anchorX: h ? m : this.opposite ? 0 : a.chartWidth, anchorY: h ? this.opposite ? a.chartHeight : 0 : k + b.height / 2 });
	      }
	    });F.init = function () {
	      d.apply(this, arguments);this.setCompare(this.options.compare);
	    };F.setCompare = function (a) {
	      this.modifyValue = "value" === a || "percent" === a ? function (b, c) {
	        var d = this.compareValue;if (void 0 !== b && void 0 !== d) return b = "value" === a ? b - d : b / d * 100 - (100 === this.options.compareBase ? 0 : 100), c && (c.change = b), b;
	      } : null;this.userOptions.compare = a;this.chart.hasRendered && (this.isDirty = !0);
	    };F.processData = function () {
	      var a,
	          b = -1,
	          c,
	          d,
	          e,
	          f;u.apply(this, arguments);if (this.xAxis && this.processedYData) for (c = this.processedXData, d = this.processedYData, e = d.length, this.pointArrayMap && (b = q("close", this.pointArrayMap), -1 === b && (b = q(this.pointValKey || "y", this.pointArrayMap))), a = 0; a < e - 1; a++) {
	        if (f = -1 < b ? d[a][b] : d[a], n(f) && c[a + 1] >= this.xAxis.min && 0 !== f) {
	          this.compareValue = f;break;
	        }
	      }
	    };k(F, "getExtremes", function (a) {
	      var b;a.apply(this, [].slice.call(arguments, 1));this.modifyValue && (b = [this.modifyValue(this.dataMin), this.modifyValue(this.dataMax)], this.dataMin = C(b), this.dataMax = D(b));
	    });G.prototype.setCompare = function (a, b) {
	      this.isXAxis || (l(this.series, function (b) {
	        b.setCompare(a);
	      }), z(b, !0) && this.chart.redraw());
	    };b.prototype.tooltipFormatter = function (b) {
	      b = b.replace("{point.change}", (0 < this.change ? "+" : "") + a.numberFormat(this.change, z(this.series.tooltipOptions.changeDecimals, 2)));return m.apply(this, [b]);
	    };k(h.prototype, "render", function (a) {
	      this.chart.is3d && this.chart.is3d() || this.chart.polar || !this.xAxis || this.xAxis.isRadial || (!this.clipBox && this.animate ? (this.clipBox = e(this.chart.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = this.yAxis.len) : this.chart[this.sharedClipKey] ? this.chart[this.sharedClipKey].attr({ width: this.xAxis.len, height: this.yAxis.len }) : this.clipBox && (this.clipBox.width = this.xAxis.len, this.clipBox.height = this.yAxis.len));a.call(this);
	    });
	  })(K);return K;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(190)(module)))

/***/ }),
/* 190 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(192)

	/* script */
	__vue_exports__ = __webpack_require__(194)

	/* template */
	var __vue_template__ = __webpack_require__(195)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\selectValue.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-269c2b69", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-269c2b69", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] selectValue.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(193);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-269c2b69!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./selectValue.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-269c2b69!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./selectValue.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.select-val {\n  background: #160E23;\n  width: 16rem;\n}\n.select-val .select-add {\n  position: relative;\n  font-size: 0rem;\n}\n.select-val .select-add .leverage-wapper {\n  background: #160E23;\n  color: #807691;\n}\n.select-val .select-add .leverage-wapper li {\n  display: inline-block;\n  width: 5.325rem;\n  height: 1.5rem;\n  line-height: 1.5rem;\n  font-size: 0.45rem;\n  text-align: center;\n}\n.select-val .select-add .leverage-wapper li.attribute {\n  color: #967ddb;\n}\n.select-val .select-add .btn-wrapper {\n  position: relative;\n  width: 16rem;\n  height: 2.25rem;\n  font-size: 0.6rem;\n  padding: 0rem 1.25rem;\n  background: #160E23;\n}\n.select-val .select-add .btn-wrapper .btn {\n  position: relative;\n  z-index: 2;\n  width: 2rem;\n  height: 1.25rem;\n  line-height: 1.25rem;\n  text-align: center;\n  background: #967DDB;\n  margin-top: 0.5rem;\n  font-size: 1.5rem;\n  color: #fff;\n  -webkit-border-radius: 0.15rem;\n  -moz-border-radius: 0.15rem;\n  -ms-border-radius: 0.15rem;\n  -o-border-radius: 0.15rem;\n  border-radius: 0.15rem;\n  vertical-align: bottom;\n}\n.select-val .select-add .btn-wrapper .btn.minus {\n  float: left;\n}\n.select-val .select-add .btn-wrapper .btn.add {\n  float: right;\n}\n.select-val .select-add .btn-wrapper .num {\n  position: absolute;\n  width: 10rem;\n  top: 0.475rem;\n  height: 1.25rem;\n  padding-left: 4.25rem;\n  border: none;\n  border-bottom: 0.025rem solid #a092c4;\n  background: inherit;\n  vertical-align: bottom;\n  color: #967adc;\n  outline: 0;\n}\n.select-val .select-add .volume-count-wrapper {\n  position: relative;\n  width: 16rem;\n  font-size: 0.5rem;\n  color: #807691;\n  padding: 0rem 0.75rem;\n  padding-bottom: 0.5rem;\n  background: #160E23;\n}\n.select-val .select-add .volume-count-wrapper p {\n  display: inline-block;\n  width: 7rem;\n  height: 1.5rem;\n  line-height: 1.5rem;\n  text-align: left;\n  padding-left: 0.5rem;\n}\n.select-val .select-add .volume-count-wrapper p.capital {\n  text-align: right;\n  padding-right: 0.5rem;\n}\n.select-val .select-add .volume-count-wrapper .border {\n  position: absolute;\n  width: 0rem;\n  height: 1.5rem;\n  border-right: 0.025rem solid #353244;\n  top: 0rem;\n  left: 7.825rem;\n}\n.select-val .more {\n  position: absolute;\n  width: 1rem;\n  height: 1rem;\n  bottom: 3.25rem;\n  left: 7.325rem;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n  background: #564876;\n}\n.select-val .more span {\n  position: absolute;\n  top: 0.375rem;\n  left: 0.225rem;\n  width: 0;\n  height: 0;\n  border-width: 0.25rem;\n  border-style: solid;\n  border-color: #fff transparent transparent transparent;\n}\n.select-val .fill-data {\n  width: 16rem;\n  color: #807691;\n  background: #160E23;\n}\n.select-val .fill-data div {\n  display: inline-block;\n  vertical-align: middle;\n}\n.select-val .fill-data .set-guadan {\n  width: 6.75rem;\n  height: 2.75rem;\n  padding: 0.75rem;\n}\n.select-val .fill-data .set-guadan .icon-wrap {\n  height: 1.25rem;\n  line-height: 1.25rem;\n  margin-left: 1rem;\n}\n.select-val .fill-data .set-guadan .icon-wrap span {\n  display: inline-block;\n  width: 2.5rem;\n  height: 1.25rem;\n  margin-right: 0.5rem;\n  float: left;\n  background: red;\n}\n.select-val .fill-data .open-price {\n  width: 7.5rem;\n  height: 1.25rem;\n  border: 0.025rem solid #65577a;\n}\n.select-val .fill-data .open-price input {\n  height: 1.25rem;\n  color: #ccc;\n  line-height: 1.25rem;\n  padding-left: 0.6rem;\n  background: inherit;\n  border: none;\n  outline: 0;\n}\n.select-val .set-price {\n  position: relative;\n  height: 5rem;\n  color: #807691;\n  border-bottom: 0.025rem solid #353244;\n}\n.select-val .set-price div {\n  display: inline-block;\n  width: 7.9rem;\n  height: 5rem;\n  padding: 0.125rem 1rem;\n  padding-top: 0.75rem;\n  vertical-align: bottom;\n}\n.select-val .set-price .stop-profit p,\n.select-val .set-price .stop-loss p {\n  width: 5.5rem;\n  height: 1.25rem;\n  margin: 0.2rem 0rem;\n  border: 1px solid #65577a;\n}\n.select-val .set-price .stop-profit p input,\n.select-val .set-price .stop-loss p input {\n  width: 5.5rem;\n  height: 1.25rem;\n  color: #ccc;\n  line-height: 1.25rem;\n  border: none;\n  background: inherit;\n  outline: 0;\n  padding-left: 0.6rem;\n}\n.select-val .set-price > .border {\n  position: absolute;\n  width: 0;\n  bottom: 0rem;\n  left: 7.925rem;\n  border-right: 0.025rem solid #353244;\n  height: 4.25rem;\n}\n.select-val .base {\n  width: 16rem;\n  font-size: 0.75rem;\n  color: #fff;\n  padding: 0.75rem 1.25rem;\n  background: #160E23;\n}\n.select-val .base > div {\n  display: inline-block;\n  width: 5.5rem;\n  height: 2.25rem;\n  text-align: center;\n  -webkit-border-radius: 0.175rem;\n  -moz-border-radius: 0.175rem;\n  -ms-border-radius: 0.175rem;\n  -o-border-radius: 0.175rem;\n  border-radius: 0.175rem;\n  border-bottom: 0.125rem solid #1c5e5d;\n  background-color: #25B9A8;\n}\n.select-val .base > div p {\n  height: 1rem;\n  line-height: 1rem;\n}\n.select-val .base > div:last-child {\n  float: right;\n  background-color: #F9584A;\n}\n", ""]);

	// exports


/***/ }),
/* 194 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: '',

		data: function data() {
			return {
				value: 1.00,
				step: 0.5,
				minValume: 0.1,
				maxValume: 6,
				symbol: '',
				more: false,
				sell_price: '-- --',
				buy_price: '-- --'
			};
		},


		props: ['selectData', 'curPrice'],

		methods: {
			set_volume: function set_volume(add) {
				if (add) {
					if (this.value >= this.maxValume) {
						return;
					}
					// 有一个小数保留问题待解决
					this.value = parseFloat(this.value + this.step);
				} else {
					if (this.value <= this.minValume) {
						return;
					}
					this.value = parseFloat(this.value - this.step);
				}

				return this.value;
			},
			switchMore: function switchMore() {
				this.more = this.more ? false : true;
				return this.more;
			}
		},

		computed: {
			curSymbol: function curSymbol() {
				if (this.selectData) {
					return this.selectData;
				} else {
					return '';
				}
			},
			sell: function sell() {
				// infoBar组件当前价格更新有问题  
				if (this.curPrice) {
					this.sell_price = this.curPrice[3];
					return this.sell_price;
				} else {
					return this.sell_price ? this.sell_price : '-- --';
				}
			},
			buy: function buy() {
				if (this.curPrice) {
					this.buy_price = this.curPrice[1];
					return this.buy_price;
				} else {
					return this.buy_price ? this.buy_price : '-- --';
				}
			}
		},

		created: function created() {
			// console.log(this.selectData)
		}
	};

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "select-val"
	  }, [_c('div', {
	    staticClass: "select-add"
	  }, [_c('ul', {
	    staticClass: "leverage-wapper"
	  }, [_c('li', {
	    staticClass: "lever"
	  }, [_vm._v("杠杆:"), _c('span', {
	    staticClass: "lever-text"
	  }, [_vm._v(_vm._s(this.selectData.leverage ? this.selectData.leverage : '- -'))]), _vm._v("倍")]), _vm._v(" "), _c('li', {
	    staticClass: "desc"
	  }, [_vm._v("1手=\n\t\t\t"), _c('span', {
	    staticClass: "desc-text"
	  }, [_vm._v("\n\t\t\t\t" + _vm._s(_vm.curSymbol ? _vm.curSymbol.policy.lot_size : '- -') + "\n\t\t\t")]), _vm._v("\n\t\t\t\t" + _vm._s(_vm.curSymbol ? _vm.curSymbol.policy.unit : '- -') + "\n\t\t\t")]), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _c('div', {
	    staticClass: "btn-wrapper"
	  }, [_c('div', {
	    staticClass: "minus btn",
	    on: {
	      "click": function($event) {
	        _vm.set_volume(0)
	      }
	    }
	  }, [_vm._v("-")]), _vm._v(" "), _c('div', {
	    staticClass: "add btn",
	    on: {
	      "click": function($event) {
	        _vm.set_volume(1)
	      }
	    }
	  }, [_vm._v("+")]), _vm._v(" "), _c('input', {
	    staticClass: "num",
	    attrs: {
	      "type": "number",
	      "name": ""
	    },
	    domProps: {
	      "value": _vm.value
	    }
	  })]), _vm._v(" "), _vm._m(1)]), _vm._v(" "), _c('div', {
	    staticClass: "more",
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.switchMore()
	      }
	    }
	  }, [_c('span')]), _vm._v(" "), (_vm.more) ? _c('div', {
	    staticClass: "fill-data clearfix"
	  }, [_vm._m(2), _vm._v(" "), _vm._m(3)]) : _vm._e(), _vm._v(" "), (_vm.more) ? _c('div', {
	    staticClass: "set-price"
	  }, [_vm._m(4), _vm._v(" "), _vm._m(5), _vm._v(" "), _c('span', {
	    staticClass: "border"
	  })]) : _vm._e(), _vm._v(" "), _c('div', {
	    staticClass: "base submit"
	  }, [_c('div', {
	    staticClass: "sell"
	  }, [_c('p', {
	    staticClass: "bid-price"
	  }, [_vm._v(_vm._s(_vm.sell))]), _vm._v("\n\t\t买跌")]), _vm._v(" "), _c('div', {
	    staticClass: "buy"
	  }, [_c('p', {
	    staticClass: "ask-price"
	  }, [_vm._v(_vm._s(_vm.buy))]), _vm._v("\n\t\t买涨")])])])
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', {
	    staticClass: "attribute"
	  }, [_c('span', {
	    staticClass: "attribute-text"
	  }, [_vm._v("属性详情")])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "volume-count-wrapper clearfix"
	  }, [_c('p', {
	    staticClass: "max-limit"
	  }, [_vm._v("最大可买(手):\n\t\t\t\t"), _c('span', {
	    staticClass: "max-val"
	  }, [_vm._v("10")])]), _vm._v(" "), _c('p', {
	    staticClass: "capital"
	  }, [_vm._v("占用资金($):\n\t\t\t\t"), _c('span', {
	    staticClass: "capital-val"
	  }, [_vm._v("510.0")])]), _vm._v(" "), _c('span', {
	    staticClass: "border"
	  })])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "set-guadan clearfix"
	  }, [_c('div', {
	    staticClass: "icon-wrap"
	  }, [_c('span', {
	    staticClass: "set-icon clearfix"
	  }), _vm._v("\n\t\t\t\t挂单\n\t\t\t")])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "open-price"
	  }, [_c('input', {
	    attrs: {
	      "type": "number",
	      "name": "",
	      "value": "11"
	    }
	  })])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "stop-profit"
	  }, [_c('span', [_vm._v("止盈价格:")]), _vm._v(" "), _c('p', [_c('input', {
	    attrs: {
	      "type": "number",
	      "value": "111"
	    }
	  })]), _vm._v(" "), _c('span', [_vm._v("目标盈利($)")]), _c('span', {
	    staticClass: "profit-num"
	  }, [_vm._v("11221")])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "stop-loss"
	  }, [_c('span', [_vm._v("止损价格:")]), _vm._v(" "), _c('p', [_c('input', {
	    attrs: {
	      "type": "number",
	      "value": "111"
	    }
	  })]), _vm._v(" "), _c('span', [_vm._v("预期亏损($)")]), _c('span', {
	    staticClass: "profit-num"
	  }, [_vm._v("0.00")])])
	}]}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-269c2b69", module.exports)
	  }
	}

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(197)

	/* script */
	__vue_exports__ = __webpack_require__(199)

	/* template */
	var __vue_template__ = __webpack_require__(200)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\infoBar.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-1fad8019"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-1fad8019", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-1fad8019", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] infoBar.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(198);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-1fad8019&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./infoBar.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-1fad8019&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./infoBar.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.infoBar .info[data-v-1fad8019] {\n  width: 16rem;\n  height: 3.2rem;\n  padding-left: 0.75rem;\n  background: -webkit-gradient(linear, 0 50%, 100% 50%, from(#36dfa1), to(#25b9a8));\n  background: -webkit-linear-gradient(left, #36dfa1, #25b9a8);\n  background: -o-linear-gradient(left, #36dfa1, #25b9a8);\n}\n.infoBar .info.up[data-v-1fad8019] {\n  background: -webkit-gradient(linear, 0 50%, 100% 50%, from(#f07a60), to(#f1375e));\n  background: -webkit-linear-gradient(left, #f07a60, #f1375e);\n  background: -o-linear-gradient(left, #f07a60, #f1375e);\n}\n.infoBar .info > div[data-v-1fad8019] {\n  color: #fff;\n  display: inline-block;\n}\n.infoBar .info > .cur-wrapper[data-v-1fad8019] {\n  display: inline-block;\n  position: relative;\n  width: 5.75rem;\n  height: 2.75rem;\n  float: left;\n  margin-right: 1.25rem;\n}\n.infoBar .info > .cur-wrapper > p[data-v-1fad8019] {\n  font-size: 1.125rem;\n  margin-bottom: 0.2rem;\n  margin-top: 0.375rem;\n}\n.infoBar .info > .cur-wrapper > .range-percent[data-v-1fad8019] {\n  float: right;\n}\n.infoBar .info > .detail-wrapper[data-v-1fad8019] {\n  width: 7.5rem;\n  font-size: 0.55rem;\n  margin-top: 1.05rem;\n}\n.infoBar .info > .detail-wrapper > div > .highest[data-v-1fad8019],\n.infoBar .info > .detail-wrapper > div > .lowest[data-v-1fad8019] {\n  float: right;\n}\n.infoBar .info > .detail-wrapper > div[data-v-1fad8019]:last-child {\n  margin-top: 0.3rem;\n}\n", ""]);

	// exports


/***/ }),
/* 199 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'infoBar',
		data: function data() {
			return {
				//好像有点多余
				info_data: {
					price: '',
					high: '',
					low: '',
					open: '',
					yesterdayClose: ''
				},

				diffPrice: {
					Ratio: '- -',
					diffPrice: '- - '
				}

			};
		},


		props: ['up', 'price', 'curPrice'],

		created: function created() {
			// console.log(this.curPrice)
		},


		computed: {
			infoData: function infoData() {
				var price = this.price.todayPrice,
				    yesterdayPrice = this.price.yesterdayPrice;

				try {
					this.info_data.price = price.price ? price.price : '- -';
					this.info_data.high = price.high ? price.high : '- -';
					this.info_data.low = price.low ? price.low : '- -';
					this.info_data.open = price.open ? price.open : '- -';
					this.info_data.yesterdayClose = yesterdayPrice.close ? yesterdayPrice.close : '- -';
				} catch (e) {
					console.log(e);
				}

				return this.info_data;
			},
			diffPriceRatio: function diffPriceRatio() {
				var diff = NaN;
				if (this.curPrice) {
					diff = (this.curPrice[3] - parseFloat(this.price.yesterdayPrice.close)).toFixed(3);
				} else {
					diff = (this.price.todayPrice.price - parseFloat(this.price.yesterdayPrice.close)).toFixed(3);
				}

				var ratio = !isNaN(diff) && diff / parseFloat(this.price.yesterdayPrice.close);
				return {
					diffPrice: !isNaN(diff) ? diff : '- -',
					Ratio: !isNaN(ratio) ? (ratio * 100).toFixed(2) : '- -'
				};
			}
		},

		watch: {}
	};

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "infoBar"
	  }, [_c('section', {
	    staticClass: "info",
	    class: {
	      up: _vm.up
	    }
	  }, [_c('div', {
	    staticClass: "cur-wrapper"
	  }, [_c('p', {
	    attrs: {
	      "id": "J_Price"
	    }
	  }, [_vm._v(_vm._s(_vm.curPrice && _vm.curPrice[3] ? _vm.curPrice[3] : _vm.infoData.price))]), _vm._v(" "), _c('span', {
	    staticClass: "range",
	    attrs: {
	      "id": "J_range"
	    }
	  }, [_vm._v(_vm._s(_vm.diffPriceRatio.diffPrice))]), _vm._v(" "), _c('span', {
	    staticClass: "range-percent",
	    attrs: {
	      "id": "J_percent"
	    }
	  }, [_vm._v(_vm._s(_vm.diffPriceRatio.Ratio) + "%")])]), _vm._v(" "), _c('div', {
	    staticClass: "detail-wrapper"
	  }, [_c('div', [_c('span', {
	    staticClass: "price-today"
	  }, [_vm._v("今开:" + _vm._s(_vm.infoData.open))]), _vm._v(" "), _c('span', {
	    staticClass: "highest"
	  }, [_vm._v("最高:" + _vm._s(_vm.infoData.high))])]), _vm._v(" "), _c('div', [_c('span', {
	    staticClass: "prec"
	  }, [_vm._v("作收:" + _vm._s(_vm.infoData.yesterdayClose))]), _vm._v(" "), _c('span', {
	    staticClass: "lowest"
	  }, [_vm._v("最低:" + _vm._s(_vm.infoData.low))])])])])])
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-1fad8019", module.exports)
	  }
	}

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "Stock"
	  }, [_c('my-infoBar', {
	    attrs: {
	      "up": _vm.up,
	      "price": _vm.price,
	      "curPrice": _vm.curPrice
	    }
	  }), _vm._v(" "), _c('div', {
	    attrs: {
	      "id": "stockWrap"
	    }
	  }), _vm._v(" "), _c('div', {
	    staticClass: "rang-seclect"
	  }, [_c('ul', {
	    staticClass: "btn-wrap"
	  }, [_c('li', {
	    staticClass: "seclect-btn",
	    class: {
	      active: _vm.pitchActive[0]
	    },
	    on: {
	      "click": function($event) {
	        _vm.initChart(0, 'm1')
	      }
	    }
	  }, [_vm._v("1分钟")]), _vm._v(" "), _c('li', {
	    staticClass: "seclect-btn",
	    class: {
	      active: _vm.pitchActive[1]
	    },
	    on: {
	      "click": function($event) {
	        _vm.initChart(1, 'm5')
	      }
	    }
	  }, [_vm._v("5分钟")]), _vm._v(" "), _c('li', {
	    staticClass: "seclect-btn",
	    class: {
	      active: _vm.pitchActive[2]
	    },
	    on: {
	      "click": function($event) {
	        _vm.initChart(2, 'm15')
	      }
	    }
	  }, [_vm._v("15分钟")]), _vm._v(" "), _c('li', {
	    staticClass: "seclect-btn",
	    class: {
	      active: _vm.pitchActive[3]
	    },
	    on: {
	      "click": function($event) {
	        _vm.initChart(3, 'm30')
	      }
	    }
	  }, [_vm._v("30分钟")]), _vm._v(" "), _c('li', {
	    staticClass: "seclect-btn",
	    class: {
	      active: _vm.pitchActive[4]
	    },
	    on: {
	      "click": function($event) {
	        _vm.initChart(4, 'h1')
	      }
	    }
	  }, [_vm._v("1小时")]), _vm._v(" "), _c('li', {
	    staticClass: "seclect-btn",
	    class: {
	      active: _vm.pitchActive[5]
	    },
	    on: {
	      "click": function($event) {
	        _vm.initChart(5, 'd1')
	      }
	    }
	  }, [_vm._v("1天")])])]), _vm._v(" "), _c('my-account', {
	    attrs: {
	      "bg_color": true
	    }
	  }), _vm._v(" "), _c('my-seclect', {
	    attrs: {
	      "selectData": _vm.selectData,
	      "curPrice": _vm.curPrice
	    }
	  })], 1)
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-057a17a8", module.exports)
	  }
	}

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "pro-trading"
	  }, [_c('my-header', {
	    attrs: {
	      "page-title": _vm.symbol.name
	    }
	  }, [_c('span', {
	    staticClass: "go-back",
	    on: {
	      "click": function($event) {
	        _vm.$router.go(-1)
	      }
	    },
	    slot: "icon-logo"
	  }, [_vm._v(" < ")])]), _vm._v(" "), _c('my-stock', {
	    attrs: {
	      "params": _vm.params
	    }
	  })], 1)
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-8dcba992", module.exports)
	  }
	}

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(204)

	/* script */
	__vue_exports__ = __webpack_require__(207)

	/* template */
	var __vue_template__ = __webpack_require__(209)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\login.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-3b5c2c94", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-3b5c2c94", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] login.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(205);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-3b5c2c94!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./login.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-3b5c2c94!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./login.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.login {\n  background: red;\n  width: 16rem;\n  height: 28.4rem;\n  background: url(" + __webpack_require__(206) + ");\n}\n.login form {\n  height: 20rem;\n  padding-top: 20rem;\n}\n.login form div {\n  text-align: center;\n}\n.login form div input {\n  width: 8.75rem;\n  height: 1.375rem;\n  border-bottom: 0.025rem solid #967BDB;\n  -webkit-border-radius: 0.2rem;\n  -moz-border-radius: 0.2rem;\n  -ms-border-radius: 0.2rem;\n  -o-border-radius: 0.2rem;\n  border-radius: 0.2rem;\n}\n.login form div.phone-wrap {\n  margin-bottom: 0.75rem;\n}\n.login form div.btn-wrap input {\n  background-color: green;\n  margin-top: 1.25rem;\n  border: none;\n  border-bottom: 0.025rem solid #967BDB;\n  -webkit-border-radius: 0.25rem;\n  -moz-border-radius: 0.25rem;\n  -ms-border-radius: 0.25rem;\n  -o-border-radius: 0.25rem;\n  border-radius: 0.25rem;\n}\n", ""]);

	// exports


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "../img/login-bg.jpg?70cc466";

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _extends2 = __webpack_require__(208);

	var _extends3 = _interopRequireDefault(_extends2);

	var _vuex = __webpack_require__(20);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		name: 'login',

		data: function data() {
			return {
				// phone: 'qqqqqqqqqqqqqq',
				// password: '',
			};
		},


		methods: (0, _extends3.default)({}, (0, _vuex.mapMutations)(['ISLOGIN']), {
			submit: function submit() {
				var _this = this;

				this.ajax({
					url: 'http://newapi.invhero.com/v1/user/login',
					type: 'POST',
					data: {
						phone: this.phone,
						password: this.password,
						cc: 86
					},
					unjoin: true
				}).then(function (data) {
					if (data.data.status == 200) {
						_this.ISLOGIN(data.data);
						_this.cookie.set('token', data.data.data.token, {
							expires: Infinity
						});
						_this.$router.push({ path: 'option' });
					}
				});
			}
		})
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _assign = __webpack_require__(133);

	var _assign2 = _interopRequireDefault(_assign);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = _assign2.default || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];

	    for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }

	  return target;
	};

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "login"
	  }, [_c('form', [_c('div', {
	    staticClass: "phone-wrap"
	  }, [_c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.phone),
	      expression: "phone"
	    }],
	    attrs: {
	      "type": "number",
	      "name": "",
	      "placeholder": "请输入手机号"
	    },
	    domProps: {
	      "value": (_vm.phone)
	    },
	    on: {
	      "input": function($event) {
	        if ($event.target.composing) { return; }
	        _vm.phone = $event.target.value
	      },
	      "blur": function($event) {
	        _vm.$forceUpdate()
	      }
	    }
	  })]), _vm._v(" "), _c('div', {
	    staticClass: "password-wrap"
	  }, [_c('input', {
	    directives: [{
	      name: "model",
	      rawName: "v-model",
	      value: (_vm.password),
	      expression: "password"
	    }],
	    attrs: {
	      "type": "number",
	      "name": "",
	      "placeholder": "请输入登录密码"
	    },
	    domProps: {
	      "value": (_vm.password)
	    },
	    on: {
	      "input": function($event) {
	        if ($event.target.composing) { return; }
	        _vm.password = $event.target.value
	      },
	      "blur": function($event) {
	        _vm.$forceUpdate()
	      }
	    }
	  })]), _vm._v(" "), _c('div', {
	    staticClass: "btn-wrap"
	  }, [_c('input', {
	    attrs: {
	      "type": "submit",
	      "name": "",
	      "value": "登录"
	    },
	    on: {
	      "click": function($event) {
	        $event.stopPropagation();
	        _vm.submit($event)
	      }
	    }
	  })])])])
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-3b5c2c94", module.exports)
	  }
	}

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(211)

	/* script */
	__vue_exports__ = __webpack_require__(213)

	/* template */
	var __vue_template__ = __webpack_require__(214)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\curretOrder.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-3053f9fa"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-3053f9fa", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-3053f9fa", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] curretOrder.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(212);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-3053f9fa&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./curretOrder.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-3053f9fa&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./curretOrder.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.current-order[data-v-3053f9fa] {\n  background: #f4f3fb;\n}\n.current-order #J_list > li[data-v-3053f9fa] {\n  position: relative;\n  height: 3.75rem;\n  color: #807691;\n  background-color: #fff;\n  padding: 0.25rem 1rem;\n  border-bottom: 0.25rem solid #f4f3fb;\n}\n.current-order #J_list > li .symbol_way[data-v-3053f9fa] {\n  position: absolute;\n  width: 0.5rem;\n  height: 0.5rem;\n  left: 0.25rem;\n  top: 1.5rem;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n  background: #f9594a;\n}\n.current-order #J_list > li .symbol_way.sell[data-v-3053f9fa] {\n  background: #32d8a3;\n}\n.current-order #J_list > li .symbol-name[data-v-3053f9fa] {\n  display: inline-block;\n  width: 3.75rem;\n  height: 3rem;\n  padding-top: 0.5rem;\n  float: left;\n  border-right: 0.025rem solid #807691;\n}\n.current-order #J_list > li .symbol-name p[data-v-3053f9fa] {\n  width: 3rem;\n  height: 1rem;\n  line-height: 1rem;\n  text-align: left;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.current-order #J_list > li .symbol-name p[data-v-3053f9fa]:last-child {\n  width: 100%;\n  font-size: 0.5rem;\n}\n.current-order #J_list > li .attribute[data-v-3053f9fa] {\n  display: inline-block;\n  /*float: right;*/\n  width: 10rem;\n}\n.current-order #J_list > li .attribute li[data-v-3053f9fa] {\n  display: inline-block;\n  width: 2.5rem;\n  margin: 0.125rem 0.3rem;\n  font-size: 0.5rem;\n}\n.current-order #J_list > li .guide[data-v-3053f9fa] {\n  display: inline-block;\n  position: absolute;\n  width: 0.5rem;\n  height: 0.5rem;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n  background: #d5caf1;\n  top: 1.5rem;\n  right: 0.25rem;\n}\n.current-order #J_list > li .guide span[data-v-3053f9fa] {\n  position: absolute;\n  display: inline-block;\n  top: 0.125rem;\n  left: 0.2rem;\n  width: 0;\n  height: 0;\n  border-width: 0.125rem;\n  border-style: solid;\n  border-color: transparent transparent transparent #fff;\n}\n", ""]);

	// exports


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _regenerator = __webpack_require__(63);

	var _regenerator2 = _interopRequireDefault(_regenerator);

	var _asyncToGenerator2 = __webpack_require__(66);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _pageBase = __webpack_require__(140);

	var _pageBase2 = _interopRequireDefault(_pageBase);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		name: 'currentOrder',

		data: function data() {
			return {
				order_list: ''
			};
		},


		methods: {
			getCurrentOrderList: function getCurrentOrderList() {
				var _this = this;

				return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
					var list;
					return _regenerator2.default.wrap(function _callee$(_context) {
						while (1) {
							switch (_context.prev = _context.next) {
								case 0:
									_context.next = 2;
									return _pageBase2.default.getCurrentOrderList({}).then(function (data) {
										data = data.data.data;
										_this.order_list = data;
									});

								case 2:
									list = _context.sent;
									return _context.abrupt('return', _this.order_list);

								case 4:
								case 'end':
									return _context.stop();
							}
						}
					}, _callee, _this);
				}))();
			}
		},

		created: function created() {
			this.getCurrentOrderList();
		},
		mounted: function mounted() {}
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "current-order"
	  }, [_c('ul', {
	    staticClass: "list",
	    attrs: {
	      "id": "J_list"
	    }
	  }, _vm._l((_vm.order_list), function(symbol) {
	    return _c('router-link', {
	      key: symbol.name,
	      ref: "symbolListNode",
	      refInFor: true,
	      attrs: {
	        "to": {
	          path: "/proTrading",
	          query: {
	            symbolName: symbol.name,
	            symbol: symbol.symbol
	          }
	        },
	        "tag": "li"
	      }
	    }, [_c('div', {
	      staticClass: "symbol_way",
	      class: {
	        sell: symbol.cmd != "buy"
	      }
	    }, [_c('span')]), _vm._v(" "), _c('div', {
	      staticClass: "symbol-name clearfix"
	    }, [_c('p', {
	      staticClass: "name J_SymbolName"
	    }, [_vm._v(_vm._s(symbol.symbolName))]), _vm._v(" "), _c('p', {
	      staticClass: "symbol"
	    }, [_vm._v(_vm._s(symbol.symbol))])]), _vm._v(" "), _c('ul', {
	      staticClass: "attribute detail"
	    }, [_c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("盈亏")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate no-guadan down"
	    }, [_vm._v(_vm._s(symbol.profit))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("当前价格")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Price J_Formate"
	    }, [_vm._v(_vm._s(symbol.openPrice))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("开仓价格")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate"
	    }, [_vm._v(_vm._s(symbol.openPrice))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("交易量")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate"
	    }, [_vm._v(_vm._s(symbol.volume))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("止盈价格")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate"
	    }, [_vm._v(_vm._s(symbol.takeProfit))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("止损价格")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate"
	    }, [_vm._v(_vm._s(symbol.stopLoss))])])]), _vm._v(" "), _c('span', {
	      staticClass: "guide"
	    }, [_c('span')])])
	  }))])
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-3053f9fa", module.exports)
	  }
	}

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(216)

	/* script */
	__vue_exports__ = __webpack_require__(218)

	/* template */
	var __vue_template__ = __webpack_require__(225)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\orderHistory.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-a7ae11ae"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-a7ae11ae", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-a7ae11ae", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] orderHistory.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(217);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-a7ae11ae&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./orderHistory.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-a7ae11ae&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./orderHistory.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.history-order[data-v-a7ae11ae] {\n  background: #f4f3fb;\n}\n.history-order #J_list > li[data-v-a7ae11ae] {\n  position: relative;\n  height: 3.75rem;\n  color: #807691;\n  background-color: #fff;\n  padding: 0.25rem 1rem;\n  border-bottom: 0.25rem solid #f4f3fb;\n}\n.history-order #J_list > li .symbol_way[data-v-a7ae11ae] {\n  position: absolute;\n  width: 0.5rem;\n  height: 0.5rem;\n  left: 0.25rem;\n  top: 1.5rem;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n  background: #f9594a;\n}\n.history-order #J_list > li .symbol_way.sell[data-v-a7ae11ae] {\n  background: #32d8a3;\n}\n.history-order #J_list > li .symbol-name[data-v-a7ae11ae] {\n  display: inline-block;\n  width: 3.75rem;\n  height: 3rem;\n  padding-top: 0.5rem;\n  float: left;\n  border-right: 0.025rem solid #807691;\n}\n.history-order #J_list > li .symbol-name p[data-v-a7ae11ae] {\n  width: 3rem;\n  height: 1rem;\n  line-height: 1rem;\n  text-align: left;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.history-order #J_list > li .symbol-name p[data-v-a7ae11ae]:last-child {\n  width: 100%;\n  font-size: 0.5rem;\n}\n.history-order #J_list > li .attribute[data-v-a7ae11ae] {\n  display: inline-block;\n  /*float: right;*/\n  width: 10rem;\n}\n.history-order #J_list > li .attribute li[data-v-a7ae11ae] {\n  display: inline-block;\n  width: 2.5rem;\n  margin: 0.125rem 0.3rem;\n  font-size: 0.5rem;\n}\n.history-order #J_list > li .guide[data-v-a7ae11ae] {\n  display: inline-block;\n  position: absolute;\n  width: 0.5rem;\n  height: 0.5rem;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n  background: #d5caf1;\n  top: 1.5rem;\n  right: 0.25rem;\n}\n.history-order #J_list > li .guide span[data-v-a7ae11ae] {\n  position: absolute;\n  display: inline-block;\n  top: 0.125rem;\n  left: 0.2rem;\n  width: 0;\n  height: 0;\n  border-width: 0.125rem;\n  border-style: solid;\n  border-color: transparent transparent transparent #fff;\n}\n", ""]);

	// exports


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _regenerator = __webpack_require__(63);

	var _regenerator2 = _interopRequireDefault(_regenerator);

	var _asyncToGenerator2 = __webpack_require__(66);

	var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

	var _pageBase = __webpack_require__(140);

	var _pageBase2 = _interopRequireDefault(_pageBase);

	var _scroll = __webpack_require__(219);

	var _scroll2 = _interopRequireDefault(_scroll);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'currentOrder',

		data: function data() {
			return {
				order_list: '',
				page: 0,
				listdata: [], // 下拉更新数据存放数组
				downdata: [] };
		},


		methods: {
			getHistoryOrderList: function getHistoryOrderList(calBack) {
				var _this = this;

				return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee() {
					var list;
					return _regenerator2.default.wrap(function _callee$(_context) {
						while (1) {
							switch (_context.prev = _context.next) {
								case 0:
									_context.next = 2;
									return _pageBase2.default.getHistoryOrderList({ page: _this.page }).then(function (data) {

										data = data.data.data;

										//  不是这样的  目前只是为了实现效果
										if (!data.length) {
											return;
										}

										_this.order_list = data;
									});

								case 2:
									list = _context.sent;


									if (calBack) {
										setTimeout(function () {
											calBack();
										}, 1000);
									}

									_this.page++;
									return _context.abrupt('return', _this.order_list);

								case 6:
								case 'end':
									return _context.stop();
							}
						}
					}, _callee, _this);
				}))();
			},
			onInfinite: function onInfinite(calBack) {
				var _this2 = this;

				return (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2() {
					var result;
					return _regenerator2.default.wrap(function _callee2$(_context2) {
						while (1) {
							switch (_context2.prev = _context2.next) {
								case 0:
									_context2.next = 2;
									return _this2.getHistoryOrderList();

								case 2:
									result = _context2.sent;


									console.log('加载更多');

									calBack && calBack();

								case 5:
								case 'end':
									return _context2.stop();
							}
						}
					}, _callee2, _this2);
				}))();
			}
		},

		created: function created() {
			this.getHistoryOrderList();
		},
		mounted: function mounted() {},


		components: {
			vScroll: _scroll2.default
		}
	};

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(220)

	/* script */
	__vue_exports__ = __webpack_require__(222)

	/* template */
	var __vue_template__ = __webpack_require__(223)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\scroll.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-642e2be9"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-642e2be9", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-642e2be9", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] scroll.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(221);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-642e2be9&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./scroll.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-642e2be9&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./scroll.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.yo-scroll[data-v-642e2be9] {\n  /*--2017-5-6   兼容Stikty；*/\n  /*  position: absolute;\n\t    .top(204);\n\t    .right(0);\n\t    .left(0);\n\t   .bottom(80);*/\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  background-color: #ddd;\n}\n.yo-scroll .inner[data-v-642e2be9] {\n  /*--2017-5-6   兼容Stikty；*/\n  /*position: absolute;\n\t    \twidth:100%;\n\t    \t.top(-80);*/\n  margin-top: -2rem;\n  transition-duration: 300ms;\n}\n.yo-scroll .inner .pull-refresh[data-v-642e2be9] {\n  width: 100%;\n  height: 2rem;\n  line-height: 2rem;\n  background: #ddd;\n}\n.yo-scroll .inner .up-tip[data-v-642e2be9],\n.yo-scroll .inner .down-tip[data-v-642e2be9],\n.yo-scroll .inner .refresh-tip[data-v-642e2be9] {\n  display: none;\n}\n.yo-scroll.touch .inner[data-v-642e2be9] {\n  transition-duration: 0ms;\n}\n.yo-scroll.down .down-tip[data-v-642e2be9] {\n  display: block;\n}\n.yo-scroll.up .up-tip[data-v-642e2be9] {\n  display: block;\n}\n.yo-scroll.refresh .refresh-tip[data-v-642e2be9] {\n  display: block;\n}\n.yo-scroll .load-more[data-v-642e2be9] {\n  height: 1.25rem;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  margin-bottom: 4.75rem;\n  background: #1ABC9C;\n}\n@keyframes mouth {\n0% {\n    transform: rotate(-80deg);\n    stroke-dasharray: 60, 95;\n    stroke-dashoffset: 0;\n}\n40% {\n    transform: rotate(280deg);\n    stroke-dasharray: 60, 95;\n    stroke-dashoffset: 0;\n}\n70%,\n  100% {\n    transform: rotate(280deg);\n    stroke-dashoffset: -23;\n    stroke-dasharray: 42, 95;\n}\n}\n/*@-webkit-keyframes ball-scale-multiple {\n\t  0% {\n\t    -webkit-transform: scale(0);\n\t            transform: scale(0);\n\t    opacity: 0; }\n\t  5% {\n\t    opacity: 1; }\n\t  100% {\n\t    -webkit-transform: scale(1);\n\t            transform: scale(1);\n\t    opacity: 0; } }\n\n\t@keyframes ball-scale-multiple {\n\t\t0% {\n\t\t    -webkit-transform: scale(0);\n\t\t    transform: scale(0);\n\t\t    opacity: 0; \n\t\t}\n\t\t5% {\n\t\t    opacity: 1; \n\t\t}\n\t\t100% {\n\t\t    -webkit-transform: scale(1);\n\t\t    ransform: scale(1);\n\t\t    opacity: 0; \n\t\t} \n\t}\n\n\t.ball-scale-multiple {\n\t  \tposition: relative;\n\t  \t-webkit-transform: translateY(-30px);\n\t    transform: translateY(-30px); \n\t}\n\t.ball-scale-multiple > div:nth-child(2) {\n\t    -webkit-animation-delay: -0.4s;\n\t    animation-delay: -0.4s; \n\t}\n\t.ball-scale-multiple > div:nth-child(3) {\n\t    -webkit-animation-delay: -0.2s;\n\t    animation-delay: -0.2s; \n\t}\n\t.ball-scale-multiple > div {\n\t    background-color: #fff;\n\t    width: 15px;\n\t    height: 15px;\n\t    border-radius: 100%;\n\t    margin: 2px;\n\t    -webkit-animation-fill-mode: both;\n\t    animation-fill-mode: both;\n\t    position: absolute;\n\t    left: -30px;\n\t    top: 0px;\n\t    opacity: 0;\n\t    margin: 0;\n\t    width: 60px;\n\t    height: 60px;\n\t    -webkit-animation: ball-scale-multiple 1s 0s linear infinite;\n        animation: ball-scale-multiple 1s 0s linear infinite; \n    }*/\n", ""]);

	// exports


/***/ }),
/* 222 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'scroll',
		data: function data() {
			return {
				top: 0,
				state: 0,
				startY: 0,
				touching: false,
				infiniteLoading: false
			};
		},


		props: {
			offset: {
				type: Number,
				default: 80
			},

			enableInfinite: {
				type: Boolean,
				default: true
			},

			enableRefresh: {
				type: Boolean,
				default: true
			},

			onRefresh: {
				type: Function,
				default: undefined,
				required: false
			},

			onInfinite: {
				type: Function,
				default: undefined,
				require: false
			}
		},

		methods: {
			touchStart: function touchStart(e) {
				this.startY = e.targetTouches[0].pageY;
				// 2017-5-6   兼容Stikty；
				// this.startScroll = this.$el.scrollTop || 0;

				this.startScroll = document.body.scrollTop || document.documentElement.scrollTop;
				this.touching = true;
			},
			touchMove: function touchMove(e) {
				// 如果不是向上滑动 则直接退出
				if (!this.enableRefresh || this.$el.scrollTop > 0 || !this.touching) {
					return;
				}

				var diff = e.targetTouches[0].pageY - this.startY - this.startScroll;

				if (diff > 0) e.preventDefault();

				this.top = Math.pow(diff, 0.8) + (this.state === 2 ? this.offset : 0);

				if (this.state === 2) {
					// in refreshing
					return;
				}

				if (this.top >= this.offset) {
					this.state = 1;
				} else {
					this.state = 0;
				}
			},
			touchEnd: function touchEnd(e) {
				if (!this.enableRefresh) return;

				this.touching = false;

				if (this.state === 2) {
					// in refreshing
					this.state = 2;
					this.top = this.offset;
					return;
				}

				if (this.top >= this.offset) {
					// do refresh
					this.refresh();
				} else {
					// cancel refresh
					this.state = 0;
					this.top = 0;
				}
			},
			refresh: function refresh() {
				this.state = 2;
				this.top = this.offset;
				this.onRefresh(this.refreshDone);
			},
			refreshDone: function refreshDone() {
				this.state = 0;
				this.top = 0;
			},
			infinite: function infinite() {
				this.infiniteLoading = true;
				this.onInfinite(this.infiniteDone);
			},
			infiniteDone: function infiniteDone() {
				this.infiniteLoading = false;
			},
			onScroll: function onScroll(e) {
				if (!this.enableInfinite || this.infiniteLoading) {
					return;
				}
				var outerHeight = this.$el.clientHeight;
				var innerHeight = this.$el.querySelector('.inner').clientHeight;
				var scrollTop = this.$el.scrollTop;
				var ptrHeight = this.onRefresh ? this.$el.querySelector('.pull-refresh').clientHeight : 0;
				var infiniteHeight = this.$el.querySelector('.load-more').clientHeight;
				var bottom = innerHeight - outerHeight - scrollTop - ptrHeight;
				if (bottom < infiniteHeight) this.infinite();
			}
		}

	};

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "yo-scroll",
	    class: {
	      'down': (_vm.state === 0), 'up': (_vm.state == 1), refresh: (_vm.state === 2), touch: _vm.touching
	    },
	    on: {
	      "touchstart": function($event) {
	        _vm.touchStart($event)
	      },
	      "touchmove": function($event) {
	        _vm.touchMove($event)
	      },
	      "touchend": function($event) {
	        _vm.touchEnd($event)
	      },
	      "scroll": function($event) {
	        (_vm.onInfinite || _vm.infiniteLoading) ? _vm.onScroll($event): undefined
	      }
	    }
	  }, [_c('section', {
	    staticClass: "inner",
	    style: ({
	      transform: 'translate3d(0, ' + _vm.top / 35 + 'rem, 0)'
	    })
	  }, [_c('div', {
	    staticClass: "pull-refresh"
	  }, [_vm._t("pull-refresh", [_c('svg', {
	    staticStyle: {
	      "fill": "#EC1E79"
	    },
	    attrs: {
	      "width": "100",
	      "height": "100"
	    }
	  }, [_c('circle', {
	    staticStyle: {
	      "stroke-width": "5",
	      "stroke": "#fff"
	    },
	    attrs: {
	      "cx": "50",
	      "cy": "40",
	      "r": "35"
	    }
	  }), _vm._v(" "), _c('circle', {
	    staticStyle: {
	      "fill": "none",
	      "stroke": "#fff",
	      "stroke-width": "5",
	      "stroke-linecap": "round",
	      "animation": "mouth 1s infinite",
	      "transform": "rotate(280deg)",
	      "transform-origin": "50% 50%",
	      "stroke-dashoffset": "-23",
	      "stroke-dasharray": "42, 95"
	    },
	    attrs: {
	      "cx": "50",
	      "cy": "45",
	      "r": "15"
	    }
	  }), _vm._v(" "), _c('path', {
	    staticStyle: {
	      "fill": "none",
	      "stroke-width": "0"
	    },
	    attrs: {
	      "id": "eyeleft",
	      "d": "M 40 35 A 15 15 180 0 1 60 35"
	    }
	  }), _vm._v(" "), _c('path', {
	    staticStyle: {
	      "fill": "none",
	      "stroke-width": "0"
	    },
	    attrs: {
	      "id": "eyeright",
	      "d": "M 35 45 A 15 15 180 0 1 40 35"
	    }
	  }), _vm._v(" "), _c('circle', {
	    staticClass: "eye",
	    staticStyle: {
	      "fill": "#fff"
	    },
	    attrs: {
	      "cx": "",
	      "cy": "",
	      "r": "2.5"
	    }
	  }, [_c('animateMotion', {
	    attrs: {
	      "dur": "1s",
	      "repeatCount": "indefinite",
	      "keyPoints": "0;0;1;1",
	      "keyTimes": "0;0.3;0.8;1",
	      "calcMode": "linear"
	    }
	  }, [_c('mpath', {
	    attrs: {
	      "xlink:href": "#eyeleft"
	    }
	  })], 1)], 1), _vm._v(" "), _c('circle', {
	    staticClass: "eye",
	    staticStyle: {
	      "fill": "#fff"
	    },
	    attrs: {
	      "cx": "",
	      "cy": "",
	      "r": "2.5"
	    }
	  }, [_c('animateMotion', {
	    attrs: {
	      "dur": "1s",
	      "repeatCount": "indefinite",
	      "keyPoints": "0;0;1;1",
	      "keyTimes": "0;0.3;0.8;1",
	      "calcMode": "linear"
	    }
	  }, [_c('mpath', {
	    attrs: {
	      "xlink:href": "#eyeright"
	    }
	  })], 1)], 1)])])], 2), _vm._v(" "), _vm._t("default"), _vm._v(" "), _c('div', {
	    staticClass: "load-more"
	  }, [_vm._t("load-more", [_c('img', {
	    attrs: {
	      "src": __webpack_require__(224)
	    }
	  })])], 2)], 2)])
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-642e2be9", module.exports)
	  }
	}

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "../fonts/three-dots.svg?7627bc8";

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "history-order"
	  }, [_c('v-scroll', {
	    attrs: {
	      "on-refresh": _vm.getHistoryOrderList,
	      "on-infinite": _vm.onInfinite
	    }
	  }, [_c('ul', {
	    staticClass: "list",
	    attrs: {
	      "id": "J_list"
	    }
	  }, _vm._l((_vm.order_list), function(symbol) {
	    return _c('router-link', {
	      key: symbol.name,
	      ref: "symbolListNode",
	      refInFor: true,
	      attrs: {
	        "to": {
	          path: "/proTrading",
	          query: {
	            symbolName: symbol.name,
	            symbol: symbol.symbol
	          }
	        },
	        "tag": "li"
	      }
	    }, [_c('div', {
	      staticClass: "symbol_way",
	      class: {
	        sell: symbol.cmd != "buy"
	      }
	    }, [_c('span')]), _vm._v(" "), _c('div', {
	      staticClass: "symbol-name clearfix"
	    }, [_c('p', {
	      staticClass: "name J_SymbolName"
	    }, [_vm._v(_vm._s(symbol.symbolName))]), _vm._v(" "), _c('p', {
	      staticClass: "symbol"
	    }, [_vm._v(_vm._s(symbol.symbol))])]), _vm._v(" "), _c('ul', {
	      staticClass: "attribute detail"
	    }, [_c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("盈亏")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate no-guadan down"
	    }, [_vm._v(_vm._s(symbol.profit))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("当前价格")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Price J_Formate"
	    }, [_vm._v(_vm._s(symbol.openPrice))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("开仓价格")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate"
	    }, [_vm._v(_vm._s(symbol.openPrice))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("交易量")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate"
	    }, [_vm._v(_vm._s(symbol.volume))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("止盈价格")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate"
	    }, [_vm._v(_vm._s(symbol.takeProfit))])]), _vm._v(" "), _c('li', [_c('p', {
	      staticClass: "name"
	    }, [_vm._v("止损价格")]), _vm._v(" "), _c('p', {
	      staticClass: "J_Formate"
	    }, [_vm._v(_vm._s(symbol.stopLoss))])])]), _vm._v(" "), _c('span', {
	      staticClass: "guide"
	    }, [_c('span')])])
	  }))])], 1)
	},staticRenderFns: []}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-a7ae11ae", module.exports)
	  }
	}

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(227)

	/* script */
	__vue_exports__ = __webpack_require__(230)

	/* template */
	var __vue_template__ = __webpack_require__(236)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\discover.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-f6d0fca8"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-f6d0fca8", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-f6d0fca8", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] discover.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(228);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-f6d0fca8&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./discover.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-f6d0fca8&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./discover.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.discover-wrapper[data-v-f6d0fca8] {\n  background: #EFEFF4;\n  color: #807691;\n  margin-top: 0.5rem;\n  padding-bottom: 6.875rem;\n}\n.discover-wrapper .content[data-v-f6d0fca8] {\n  background: #fff;\n}\n.discover-wrapper .content ul[data-v-f6d0fca8] {\n  padding: 0rem 0.75rem;\n}\n.discover-wrapper .content ul li[data-v-f6d0fca8] {\n  position: relative;\n  height: 2.25rem;\n  line-height: 2.25rem;\n  background: inherit;\n  border-bottom: 0.025rem solid #d0cfd5;\n}\n.discover-wrapper .content ul li .desc-right[data-v-f6d0fca8] {\n  position: absolute;\n  right: 1.25rem;\n}\n.discover-wrapper .content ul li .arrow-right[data-v-f6d0fca8] {\n  position: absolute;\n  width: 0.5rem;\n  height: 1.25rem;\n  background: red;\n  top: 0.75rem;\n  right: 0rem;\n  background: url(" + __webpack_require__(229) + ");\n  background-size: 1.25rem 1.25rem;\n}\n", ""]);

	// exports


/***/ }),
/* 229 */
/***/ (function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyBAMAAADsEZWCAAAAD1BMVEUAAADHx8zHx8zHx8zHx8zPkdAwAAAABHRSTlMAfYJAkNMmwAAAADRJREFUOMtjYBBkwAEYXQRwyJi4OOKQYXLBqUllRGkCyuA2bfhrAaYQUlMVKCWOglEw8AAAXYQO3bsASrEAAAAASUVORK5CYII="

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _header = __webpack_require__(15);

	var _header2 = _interopRequireDefault(_header);

	var _footer = __webpack_require__(10);

	var _footer2 = _interopRequireDefault(_footer);

	var _sliderImage = __webpack_require__(231);

	var _sliderImage2 = _interopRequireDefault(_sliderImage);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		name: 'discover',
		data: function data() {
			return {};
		},


		components: {
			myHeader: _header2.default,
			myFooter: _footer2.default,
			mySliderImage: _sliderImage2.default
		}
	}; //
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(232)

	/* script */
	__vue_exports__ = __webpack_require__(234)

	/* template */
	var __vue_template__ = __webpack_require__(235)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\components\\sliderImage.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-8a16e7e4"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-8a16e7e4", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-8a16e7e4", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] sliderImage.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(233);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-8a16e7e4&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./sliderImage.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-8a16e7e4&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./sliderImage.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.slider-wrapper-outer[data-v-8a16e7e4] {\n  position: relative;\n  height: 8.75rem;\n  margin-bottom: 1.25rem;\n}\n.slider-wrapper-outer .slider-wrapper[data-v-8a16e7e4] {\n  overflow: hidden;\n}\n.slider-wrapper-outer .slider-wrapper ul[data-v-8a16e7e4] {\n  font-size: 0rem;\n  /*.width(1940);*/\n  transition: all 0.5s ease-in;\n  -webkit-transition: all 0.5s ease-in;\n}\n.slider-wrapper-outer .slider-wrapper ul li[data-v-8a16e7e4] {\n  display: inline-block;\n  width: 16rem;\n  height: 8.75rem;\n}\n.slider-wrapper-outer .slider-wrapper ul li img[data-v-8a16e7e4] {\n  width: 100%;\n  height: 100%;\n}\n.slider-wrapper-outer .slider-wrapper ul.first[data-v-8a16e7e4] {\n  transform: translateX(0);\n  -webkit-transform: translateX(0);\n}\n.slider-wrapper-outer .slider-wrapper ul.second[data-v-8a16e7e4] {\n  transform: translateX(-16rem);\n  -webkit-transform: translateX(-16rem);\n}\n.slider-wrapper-outer .slider-wrapper ul.third[data-v-8a16e7e4] {\n  transform: translateX(-32rem);\n  -webkit-transform: translateX(-32rem);\n}\n.slider-wrapper-outer .slider-controller[data-v-8a16e7e4] {\n  position: absolute;\n  z-index: 5;\n  width: 16rem;\n  height: 1.25rem;\n  bottom: 0rem;\n}\n.slider-wrapper-outer .slider-controller ul[data-v-8a16e7e4] {\n  display: flex;\n  display: -webkit-flex;\n  justify-content: center;\n}\n.slider-wrapper-outer .slider-controller ul li[data-v-8a16e7e4] {\n  width: 0.3rem;\n  height: 0.3rem;\n  margin: 0.25rem 0.125rem;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n  border: 0.025rem solid rgba(0, 0, 0, 0.16);\n  background-color: rgba(255, 255, 255, 0.4);\n}\n.slider-wrapper-outer .slider-controller ul li.active[data-v-8a16e7e4] {\n  background: rgba(150, 123, 220, 0.5);\n}\n", ""]);

	// exports


/***/ }),
/* 234 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'sliderImage',
		data: function data() {
			return {
				sliderClass: 'first',
				sliderController: '',
				sliderWrapperStyle: {
					width: ''
				}
			};
		},


		methods: {
			sliderImg: function sliderImg() {
				var _this = this;

				console.log('slider start');

				if (this.sliderClass == 'first') {
					this.sliderClass = 'second';
				} else if (this.sliderClass == 'second') {
					this.sliderClass = 'third';
				} else {
					this.sliderClass = 'first';
				}

				this.sliderController = setTimeout(function () {
					_this.sliderImg();
				}, 2000);
			},
			sliderControEvent: function sliderControEvent(el, index) {
				switch (index) {
					case 1:
						this.sliderClass = 'first';
						break;
					case 2:
						this.sliderClass = 'second';
						break;
					case 3:
						this.sliderClass = 'third';
						break;
				}
				return this.sliderClass;
			}
		},

		created: function created() {
			this.sliderImg();
			this.sliderWrapperStyle.width = 16 * 3 + 'rem';
		}
	};

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "slider-wrapper-outer"
	  }, [_c('div', {
	    staticClass: "slider-wrapper"
	  }, [_c('ul', {
	    staticClass: "slider",
	    class: _vm.sliderClass,
	    style: (_vm.sliderWrapperStyle)
	  }, [_vm._m(0), _vm._v(" "), _vm._m(1), _vm._v(" "), _vm._m(2)])]), _vm._v(" "), _c('div', {
	    staticClass: "slider-controller"
	  }, [_c('ul', [_c('li', {
	    class: {
	      active: _vm.sliderClass == 'first'
	    },
	    on: {
	      "click": function($event) {
	        _vm.sliderControEvent($event, 1)
	      }
	    }
	  }), _vm._v(" "), _c('li', {
	    class: {
	      active: _vm.sliderClass == 'second'
	    },
	    on: {
	      "click": function($event) {
	        _vm.sliderControEvent($event, 2)
	      }
	    }
	  }), _vm._v(" "), _c('li', {
	    class: {
	      active: _vm.sliderClass == 'third'
	    },
	    on: {
	      "click": function($event) {
	        _vm.sliderControEvent($event, 3)
	      }
	    }
	  })])])])
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', [_c('img', {
	    attrs: {
	      "src": "//static.invhero.com//banner/tzyh365/banner_f.1487323474.jpg"
	    }
	  })])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', [_c('img', {
	    attrs: {
	      "src": "//static.invhero.com//banner/tzyh365/banner_f.1478515496.jpg"
	    }
	  })])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('li', [_c('img', {
	    attrs: {
	      "src": "//static.invhero.com//banner/tzyh365/banner_f.1487323474.jpg"
	    }
	  })])
	}]}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-8a16e7e4", module.exports)
	  }
	}

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "discover-wrapper"
	  }, [_c('my-header', {
	    attrs: {
	      "page-title": "发现"
	    }
	  }), _vm._v(" "), _c('my-sliderImage'), _vm._v(" "), _vm._m(0), _vm._v(" "), _c('my-footer')], 1)
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('section', {
	    staticClass: "content"
	  }, [_c('ul', [_c('li', [_c('span', {
	    staticClass: "account"
	  }, [_vm._v("投资圈")]), _vm._v(" "), _c('span', {
	    staticClass: "desc-right"
	  }, [_vm._v("看高手怎么赚钱")]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  }), _vm._v(" "), _c('span', {
	    staticClass: "desc-right"
	  })]), _vm._v(" "), _c('li', [_c('span', {
	    staticClass: "account"
	  }, [_vm._v("朋友赚我也赚")]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  }), _vm._v(" "), _c('span', {
	    staticClass: "desc-right"
	  }, [_c('span', [_vm._v("$")]), _vm._v(" "), _c('span', [_vm._v("0")])])]), _vm._v(" "), _c('li', [_c('span', {
	    staticClass: "account"
	  }, [_vm._v("最新交易")]), _vm._v(" "), _c('span', {
	    staticClass: "desc-right"
	  }, [_vm._v("系统最新交易一览无余")]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })]), _vm._v(" "), _c('li', [_c('span', {
	    staticClass: "account"
	  }, [_vm._v("本月榜单")]), _vm._v(" "), _c('span', {
	    staticClass: "desc-right"
	  }, [_vm._v("真正的赚钱高手才能上榜")]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })]), _vm._v(" "), _c('li', [_c('span', {
	    staticClass: "account"
	  }, [_vm._v("近期盈利")]), _vm._v(" "), _c('span', {
	    staticClass: "desc-right"
	  }, [_vm._v("看看最近15天都谁在赚钱")]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })])])])
	}]}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-f6d0fca8", module.exports)
	  }
	}

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

	var __vue_exports__, __vue_options__
	var __vue_styles__ = {}

	/* styles */
	__webpack_require__(238)

	/* script */
	__vue_exports__ = __webpack_require__(240)

	/* template */
	var __vue_template__ = __webpack_require__(241)
	__vue_options__ = __vue_exports__ = __vue_exports__ || {}
	if (
	  typeof __vue_exports__.default === "object" ||
	  typeof __vue_exports__.default === "function"
	) {
	if (Object.keys(__vue_exports__).some(function (key) { return key !== "default" && key !== "__esModule" })) {console.error("named exports are not supported in *.vue files.")}
	__vue_options__ = __vue_exports__ = __vue_exports__.default
	}
	if (typeof __vue_options__ === "function") {
	  __vue_options__ = __vue_options__.options
	}
	__vue_options__.__file = "D:\\vue-app\\src\\pages\\page\\my.vue"
	__vue_options__.render = __vue_template__.render
	__vue_options__.staticRenderFns = __vue_template__.staticRenderFns
	__vue_options__._scopeId = "data-v-10d75a2f"

	/* hot reload */
	if (false) {(function () {
	  var hotAPI = require("vue-loader/node_modules/vue-hot-reload-api")
	  hotAPI.install(require("vue"), false)
	  if (!hotAPI.compatible) return
	  module.hot.accept()
	  if (!module.hot.data) {
	    hotAPI.createRecord("data-v-10d75a2f", __vue_options__)
	  } else {
	    hotAPI.reload("data-v-10d75a2f", __vue_options__)
	  }
	})()}
	if (__vue_options__.functional) {console.error("[vue-loader] my.vue: functional components are not supported and should be defined in plain js files using render functions.")}

	module.exports = __vue_exports__


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag

	// load the styles
	var content = __webpack_require__(239);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(8)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-10d75a2f&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./my.vue", function() {
				var newContent = require("!!../../../node_modules/.0.25.0@css-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-10d75a2f&scoped=true!../../../node_modules/.2.2.3@less-loader/index.js!../../../node_modules/.9.9.5@vue-loader/lib/selector.js?type=styles&index=0!./my.vue");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(6)();
	// imports


	// module
	exports.push([module.id, "\n.my-wrapper[data-v-10d75a2f] {\n  background: #EFEFF4;\n  overflow-x: hidden;\n  margin-top: 2rem;\n  margin-bottom: 2.5rem;\n}\n.my-wrapper .detail-wrapper-outer[data-v-10d75a2f] {\n  height: 5rem;\n  color: #807691;\n  background: #fff;\n}\n.my-wrapper .detail-wrapper-outer > div[data-v-10d75a2f] {\n  display: inline-block;\n}\n.my-wrapper .detail-wrapper-outer > div[data-v-10d75a2f]:first-child {\n  float: left;\n  padding: 0.75rem 1.5rem;\n}\n.my-wrapper .detail-wrapper-outer .img-wrapper-outer[data-v-10d75a2f] {\n  width: 6.25rem;\n  height: 5rem;\n}\n.my-wrapper .detail-wrapper-outer .img-wrapper-outer .img-wrapper[data-v-10d75a2f] {\n  width: 3.25rem;\n  height: 3.25rem;\n  cursor: pointer;\n  display: table-cell;\n  text-align: center;\n  vertical-align: middle;\n}\n.my-wrapper .detail-wrapper-outer .img-wrapper-outer .img-wrapper .img[data-v-10d75a2f] {\n  max-width: 3.25rem;\n  max-height: 3.25rem;\n  vertical-align: middle;\n}\n.my-wrapper .detail-wrapper-outer .img-wrapper-outer .img-wrapper[data-v-10d75a2f] {\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n  overflow: hidden;\n  border: 0.125rem solid #d9cff2;\n  background: #967BDB;\n  padding: 0.125rem;\n}\n.my-wrapper .detail-wrapper-outer .img-wrapper-outer .img-wrapper .img[data-v-10d75a2f] {\n  width: 3.25rem;\n  height: 3.25rem;\n  -webkit-border-radius: 50%;\n  -moz-border-radius: 50%;\n  -ms-border-radius: 50%;\n  -o-border-radius: 50%;\n  border-radius: 50%;\n}\n.my-wrapper .detail-wrapper-outer .detail-wrapper[data-v-10d75a2f] {\n  padding-top: 0.75rem;\n  padding-left: 0.75rem;\n}\n.my-wrapper .detail-wrapper-outer .detail-wrapper > p[data-v-10d75a2f] {\n  margin-top: 0.375rem;\n}\n.my-wrapper .bd li[data-v-10d75a2f] {\n  position: relative;\n  color: #807691;\n}\n.my-wrapper .bd li .arrow-right[data-v-10d75a2f] {\n  position: absolute;\n  width: 0.5rem;\n  height: 0.75rem;\n  top: 1rem;\n  right: 0rem;\n  background: url(" + __webpack_require__(229) + ");\n  background-size: 1.25rem 1.25rem;\n}\n.my-wrapper .bd-first[data-v-10d75a2f] {\n  background: #fff;\n  margin-top: 1rem;\n  padding-left: 0.75rem;\n  padding-right: 0.75rem;\n}\n.my-wrapper .bd-first .J_Account[data-v-10d75a2f] {\n  display: inline-block;\n  width: 16rem;\n  height: 2.5rem;\n  line-height: 2.5rem;\n}\n.my-wrapper .bd-first .J_Account .profit[data-v-10d75a2f] {\n  margin-left: 3rem;\n}\n.my-wrapper .bd-first .recovery-trade-password[data-v-10d75a2f],\n.my-wrapper .bd-first .recharge[data-v-10d75a2f] {\n  display: inline-block;\n  width: 14.5rem;\n  height: 2.5rem;\n  line-height: 2.5rem;\n}\n.my-wrapper .bd-first .recovery-trade-password[data-v-10d75a2f] {\n  border-bottom: 0.025rem solid #d0cfd5;\n}\n.my-wrapper .bd-second[data-v-10d75a2f] {\n  height: 10rem;\n  background: #fff;\n  margin-top: 1rem;\n  padding-left: 0.75rem;\n  padding-right: 0.75rem;\n}\n.my-wrapper .bd-second .my-count[data-v-10d75a2f],\n.my-wrapper .bd-second .system_notice[data-v-10d75a2f] {\n  display: inline-block;\n  width: 16rem;\n  height: 2.5rem;\n  line-height: 2.5rem;\n}\n.my-wrapper .bd-second .my-count .desc-right[data-v-10d75a2f],\n.my-wrapper .bd-second .system_notice .desc-right[data-v-10d75a2f] {\n  margin-left: 6.5rem;\n}\n.my-wrapper .bd-second .system_notice[data-v-10d75a2f] {\n  border-top: 0.025rem solid #d0cfd5;\n}\n.my-wrapper .btn[data-v-10d75a2f] {\n  margin: 0.75rem 0rem;\n}\n.my-wrapper .btn span[data-v-10d75a2f] {\n  display: block;\n  width: 9.5rem;\n  height: 1.5rem;\n  line-height: 1.5rem;\n  border-bottom: 0.125rem solid #6b4db5;\n  -webkit-border-radius: 0.2rem;\n  -moz-border-radius: 0.2rem;\n  -ms-border-radius: 0.2rem;\n  -o-border-radius: 0.2rem;\n  border-radius: 0.2rem;\n  text-align: center;\n  margin: 0 auto;\n  color: #fff;\n  background: #967adc;\n}\n", ""]);

	// exports


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _header = __webpack_require__(15);

	var _header2 = _interopRequireDefault(_header);

	var _footer = __webpack_require__(10);

	var _footer2 = _interopRequireDefault(_footer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//
	//

	exports.default = {
		name: 'my',
		data: function data() {
			return {};
		},


		components: {
			myHeader: _header2.default,
			myFooter: _footer2.default
		}
	};

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "my-wrapper"
	  }, [_c('my-header', {
	    attrs: {
	      "page-title": "我"
	    }
	  }), _vm._v(" "), _vm._m(0), _vm._v(" "), _vm._m(1), _vm._v(" "), _vm._m(2), _vm._v(" "), _vm._m(3), _vm._v(" "), _vm._m(4), _vm._v(" "), _c('my-footer')], 1)
	},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "detail-wrapper-outer"
	  }, [_c('div', {
	    staticClass: "img-wrapper-outer"
	  }, [_c('div', {
	    staticClass: "img-wrapper"
	  }, [_c('img', {
	    staticClass: "img",
	    attrs: {
	      "src": "https://api.51aishanghui.com/static/user/0/4/avatar.1492178171.jpg"
	    }
	  })])]), _vm._v(" "), _c('div', {
	    staticClass: "detail-wrapper"
	  }, [_c('p', {
	    staticClass: "name"
	  }, [_vm._v("ys")]), _vm._v(" "), _c('p', {}, [_c('span', [_vm._v("手机号:")]), _vm._v(" "), _c('span', {
	    staticClass: "J_Phone"
	  }, [_vm._v("13693544218")])]), _vm._v(" "), _c('p', [_c('span', [_vm._v("邀请码:")]), _vm._v(" "), _c('span', {
	    staticClass: "J_InviteCode"
	  }, [_vm._v("yh3332")])])])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('ul', {
	    staticClass: "J_Rank bd bd-first"
	  }, [_c('li', [_c('span', {
	    staticClass: "J_Account account"
	  }, [_c('span', [_vm._v("我的资产: 14.6")]), _vm._v(" "), _c('span', {
	    staticClass: "profit"
	  }, [_vm._v("浮动盈亏: 0.00")])]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('ul', {
	    staticClass: "bd bd-first"
	  }, [_c('li', [_c('span', {
	    staticClass: "recovery-trade-password"
	  }, [_c('span', [_vm._v("修改密码")])]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })]), _vm._v(" "), _c('li', [_c('span', {
	    staticClass: "recharge"
	  }, [_c('span', [_vm._v("入金")])]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('ul', {
	    staticClass: "bd bd-second"
	  }, [_c('li', [_c('span', {
	    staticClass: "my-count"
	  }, [_c('span', [_vm._v("个人设置")]), _vm._v(" "), _c('span', {
	    staticClass: "desc-right"
	  }, [_vm._v("头像 昵称 隐私")])]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })]), _vm._v(" "), _c('li', [_c('span', {
	    staticClass: "system_notice"
	  }, [_c('span', [_vm._v("系统公告")])]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })]), _vm._v(" "), _c('li', [_c('span', {
	    staticClass: "system_notice"
	  }, [_c('span', [_vm._v("使用帮助")])]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })]), _vm._v(" "), _c('li', [_c('span', {
	    staticClass: "system_notice"
	  }, [_c('span', [_vm._v("关于我们")])]), _vm._v(" "), _c('span', {
	    staticClass: "arrow-right"
	  })])])
	},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
	  return _c('div', {
	    staticClass: "btn"
	  }, [_c('span', [_vm._v("退出")])])
	}]}
	if (false) {
	  module.hot.accept()
	  if (module.hot.data) {
	     require("vue-loader/node_modules/vue-hot-reload-api").rerender("data-v-10d75a2f", module.exports)
	  }
	}

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _vue = __webpack_require__(2);

	var _vue2 = _interopRequireDefault(_vue);

	var _vuex = __webpack_require__(20);

	var _vuex2 = _interopRequireDefault(_vuex);

	var _mutations = __webpack_require__(243);

	var _mutations2 = _interopRequireDefault(_mutations);

	var _action = __webpack_require__(249);

	var _action2 = _interopRequireDefault(_action);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_vue2.default.use(_vuex2.default);

	var state = {
		symbolList: [],
		symbolCurrentPrice: [],
		stockSymbolList: [],
		infoData: [],
		curSymbolInfoData: '',
		userAccount: '',
		isLogin: ''
	};

	exports.default = new _vuex2.default.Store({
		state: state,
		actions: _action2.default,
		mutations: _mutations2.default
	});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _defineProperty2 = __webpack_require__(244);

	var _defineProperty3 = _interopRequireDefault(_defineProperty2);

	var _USERACCOUNT$ISLOGIN$;

	var _mutations_types = __webpack_require__(248);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = (_USERACCOUNT$ISLOGIN$ = {}, (0, _defineProperty3.default)(_USERACCOUNT$ISLOGIN$, _mutations_types.USERACCOUNT, function (state, account) {
		state.userAccount = account;
	}), (0, _defineProperty3.default)(_USERACCOUNT$ISLOGIN$, _mutations_types.ISLOGIN, function (state, login) {
		state.isLogin = login;
	}), (0, _defineProperty3.default)(_USERACCOUNT$ISLOGIN$, _mutations_types.OPTIONLISTDATA, function (state, dataList) {
		state.symbolList = dataList;
	}), (0, _defineProperty3.default)(_USERACCOUNT$ISLOGIN$, _mutations_types.STOMPCURRENTPRICE, function (state, CurrentPrice) {
		state.symbolCurrentPrice = CurrentPrice;
	}), (0, _defineProperty3.default)(_USERACCOUNT$ISLOGIN$, _mutations_types.STOCKSYMBOLLIST, function (state, stockList) {
		state.stockSymbolList = stockList;
	}), (0, _defineProperty3.default)(_USERACCOUNT$ISLOGIN$, _mutations_types.INFODATA, function (state, infoData) {
		state.infoData = infoData;
	}), (0, _defineProperty3.default)(_USERACCOUNT$ISLOGIN$, _mutations_types.CURSYMBOLINFO, function (state, curSymbolInfoData) {
		state.curSymbolInfoData = curSymbolInfoData;
	}), _USERACCOUNT$ISLOGIN$);

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

	"use strict";

	exports.__esModule = true;

	var _defineProperty = __webpack_require__(245);

	var _defineProperty2 = _interopRequireDefault(_defineProperty);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = function (obj, key, value) {
	  if (key in obj) {
	    (0, _defineProperty2.default)(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	};

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(246), __esModule: true };

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

	__webpack_require__(247);
	var $Object = __webpack_require__(78).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(76);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(86), 'Object', {defineProperty: __webpack_require__(82).f});

/***/ }),
/* 248 */
/***/ (function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var OPTIONLISTDATA = exports.OPTIONLISTDATA = 'OPTIONLISTDATA';
	var STOMPCURRENTPRICE = exports.STOMPCURRENTPRICE = 'STOMPCURRENTPRICE';
	var STOCKSYMBOLLIST = exports.STOCKSYMBOLLIST = 'STOCKSYMBOLLIST';
	var INFODATA = exports.INFODATA = 'INFODATA'; //没用到
	var CURSYMBOLINFO = exports.CURSYMBOLINFO = 'CURSYMBOLINFO';
	var USERACCOUNT = exports.USERACCOUNT = 'USERACCOUNT';
	var ISLOGIN = exports.ISLOGIN = 'ISLOGIN';

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _pageBase = __webpack_require__(140);

	var _pageBase2 = _interopRequireDefault(_pageBase);

	var _frame = __webpack_require__(44);

	var _frame2 = _interopRequireDefault(_frame);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	exports.default = {
		// 获取账户信息
		getAccount: function getAccount(_ref) {
			var commit = _ref.commit,
			    state = _ref.state;

			_pageBase2.default.getAccount().then(function (account) {
				commit('USERACCOUNT', account.data.data);
			});
		},


		// 获取交易页面的symbol
		getOptionList: function getOptionList(_ref2, options) {
			var commit = _ref2.commit,
			    state = _ref2.state;

			// axios.get('http://newapi.invhero.com/v3/demo/symbols6/?access_token=d4ea901c-66d4-404f-ae2b-ed5220bbdd32&_f=0.7636744918061493')
			_pageBase2.default.getOptionSymbolList(options).then(function (optionList) {
				commit('OPTIONLISTDATA', optionList.data.data);
			});
		},


		// 获取k线数据
		getStockSymbolList: function getStockSymbolList(_ref3, options) {
			var commit = _ref3.commit,
			    state = _ref3.state;

			_pageBase2.default.getStockSymbolList(options).then(function (StockSymbolList) {
				commit('STOCKSYMBOLLIST', StockSymbolList.data.data.price);
			});
		},


		// 获取当前symbol信息
		getCurSymbolInfo: function getCurSymbolInfo(_ref4, options) {
			var commit = _ref4.commit,
			    state = _ref4.state;

			_pageBase2.default.getCurSymbolInfo(options).then(function (CurSymbolInfo) {
				commit('CURSYMBOLINFO', CurSymbolInfo.data.data);
			});
		},


		//没用到
		getInfoData: function getInfoData(_ref5, options) {
			var commit = _ref5.commit,
			    state = _ref5.state;

			_pageBase2.default.getInfoData(options).then(function (infoData) {
				commit('INFODATA', infoData.data.data.price);
			});
		},


		// 订阅报价
		getStompCurrentPrice: function getStompCurrentPrice(_ref6) {
			var commit = _ref6.commit,
			    state = _ref6.state;
			var login = 'gooduser',
			    passcode = 'passwd1',
			    host = 'localhost',
			    url = 'ws://rtprice.invhero.com:61613/stomp';


			onmessage = function onmessage(message) {
				message = JSON.parse(message.body);
				var symbolPrice = message.d.split(',');
				commit('STOMPCURRENTPRICE', symbolPrice);
			};

			var connect_callback = function connect_callback(message) {
				console.log('Stomp连接成功！');
				var symbols = JSON.parse(_pageBase2.default.getStorageSymbols());

				for (var i = 0; i < symbols.length; i++) {
					Client.subscribe('quote.' + 'real_default.' + symbols[i] + '?format=v2&throttle=1', onmessage);
				}
			};

			var error_callback = function error_callback(err) {
				console.log('Stomp连接失败！');
			};

			_frame2.default.client && _frame2.default.client.disconnect();
			var Client = Stomp.client(url);
			Client.connect(login, passcode, connect_callback, error_callback, host);
		}
	};

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(__webpack_require__(251)) :
	  typeof define === 'function' && define.amd ? define(['hammerjs'], factory) :
	  (factory(global.Hammer));
	}(this, (function (Hammer) { 'use strict';

	Hammer = 'default' in Hammer ? Hammer['default'] : Hammer;

	function assign(target) {
	  var sources = [], len = arguments.length - 1;
	  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];
	  for (var i = 0; i < sources.length; i++) {
	    var source = sources[i];
	    var keys = Object.keys(source);
	    for (var i$1 = 0; i$1 < keys.length; i$1++) {
	      var key = keys[i$1];
	      target[key] = source[key];
	    }
	  }
	  return target
	}
	function createProp() {
	  return {
	    type: Object,
	    default: function() { return {} }
	  }
	}
	function capitalize (str) {
	  return str.charAt(0).toUpperCase() + str.slice(1)
	}
	var directions = ['up', 'down', 'left', 'right', 'horizontal', 'vertical', 'all'];
	function guardDirections (options) {
	  var dir = options.direction;
	  if (typeof dir === 'string') {
	    var hammerDirection = 'DIRECTION_' + dir.toUpperCase();
	    if (directions.indexOf(dir) > -1 && Hammer.hasOwnProperty(hammerDirection)) {
	      options.direction = Hammer[hammerDirection];
	    } else {
	      console.warn('[vue-touch] invalid direction: ' + dir);
	    }
	  }
	  return options
	}
	var config = {
	};
	var customEvents = {
	};
	var gestures = [
	  'pan','panstart','panmove','panend','pancancel','panleft','panright','panup','pandown',
	  'pinch','pinchstart','pinchmove','pinchend','pinchcancel','pinchin','pinchout',
	  'press','pressup',
	  'rotate','rotatestart','rotatemove','rotateend','rotatecancel',
	  'swipe','swipeleft','swiperight','swipeup','swipedown',
	  'tap'
	];
	var gestureMap = {
	  pan: 'pan',
	  panstart: 'pan',
	  panmove: 'pan',
	  panend: 'pan',
	  pancancel: 'pan',
	  panleft: 'pan',
	  panright: 'pan',
	  panup: 'pan',
	  pandown: 'pan',
	  pinch: 'pinch',
	  pinchstart: 'pinch',
	  pinchmove: 'pinch',
	  pinchend: 'pinch',
	  pinchcancel: 'pinch',
	  pinchin: 'pinch',
	  pinchout: 'pinch',
	  press: 'press',
	  pressup: 'press',
	  rotate: 'rotate',
	  rotatestart: 'rotate',
	  rotatemove: 'rotate',
	  rotateend: 'rotate',
	  rotatecancel: 'rotate',
	  swipe: 'swipe',
	  swipeleft: 'swipe',
	  swiperight: 'swipe',
	  swipeup: 'swipe',
	  swipedown: 'swipe',
	  tap: 'tap'
	};

	var Component = {
	  props: {
	    options: createProp(),
	    tapOptions: createProp(),
	    panOptions: createProp(),
	    pinchOptions: createProp(),
	    pressOptions: createProp(),
	    rotateOptions: createProp(),
	    swipeOptions: createProp(),
	    tag: { type: String, default: 'div' },
	    enabled: {
	      default: true,
	      type: [Boolean, Object],
	    }
	  },
	  mounted: function mounted() {
	    if (!this.$isServer) {
	      this.hammer = new Hammer.Manager(this.$el, this.options);
	      this.recognizers = {};
	      this.setupBuiltinRecognizers();
	      this.setupCustomRecognizers();
	      this.updateEnabled(this.enabled);
	    }
	  },
	  destroyed: function destroyed() {
	    if (!this.$isServer) {
	      this.hammer.destroy();
	    }
	  },
	  watch: {
	    enabled: {
	      deep: true,
	      handler: function handler() {
	        var args = [], len = arguments.length;
	        while ( len-- ) args[ len ] = arguments[ len ];
	        (ref = this).updateEnabled.apply(ref, args);
	        var ref;
	      }
	    }
	  },
	  methods: {
	    setupBuiltinRecognizers: function setupBuiltinRecognizers()  {
	      var this$1 = this;
	      for (var i = 0; i < gestures.length; i++) {
	        var gesture = gestures[i];
	        if (this$1._events[gesture]) {
	          var mainGesture = gestureMap[gesture];
	          var options = assign({}, (config[mainGesture] || {}), this$1[(mainGesture + "Options")]);
	          this$1.addRecognizer(mainGesture, options);
	          this$1.addEvent(gesture);
	        }
	      }
	    },
	    setupCustomRecognizers: function setupCustomRecognizers() {
	      var this$1 = this;
	      var gestures$$1 = Object.keys(customEvents);
	      for (var i = 0; i < gestures$$1.length; i++) {
	        var gesture = gestures$$1[i];
	        if (this$1._events[gesture]) {
	          var opts = customEvents[gesture];
	          var localCustomOpts = this$1[(gesture + "Options")] || {};
	          var options = assign({}, opts, localCustomOpts);
	          this$1.addRecognizer(gesture, options, {mainGesture: options.type});
	          this$1.addEvent(gesture);
	        }
	      }
	    },
	    addRecognizer: function addRecognizer(gesture, options, ref) {
	      if ( ref === void 0 ) ref = {};
	      var mainGesture = ref.mainGesture;
	      if (!this.recognizers[gesture]) {
	        var recognizer = new Hammer[capitalize(mainGesture || gesture)](guardDirections(options));
	        this.recognizers[gesture] = recognizer;
	        this.hammer.add(recognizer);
	        recognizer.recognizeWith(this.hammer.recognizers);
	      }
	    },
	    addEvent: function addEvent(gesture) {
	      var this$1 = this;
	      this.hammer.on(gesture, function (e) { return this$1.$emit(gesture, e); });
	    },
	    updateEnabled: function updateEnabled(newVal, oldVal) {
	      var this$1 = this;
	      if (newVal === true) {
	        this.enableAll();
	      } else if (newVal === false) {
	        this.disableAll();
	      } else if (typeof newVal === 'object') {
	        var keys = Object.keys(newVal);
	        for (var i = 0; i < keys.length; i++) {
	          var event = keys[i];
	          if (this$1.recognizers[event]) {
	            newVal[event]
	              ? this$1.enable(event)
	              : this$1.disable(event);
	          }
	        }
	      }
	    },
	    enable: function enable(r) {
	      var recognizer = this.recognizers[r];
	      if (!recognizer.options.enable) {
	        recognizer.set({ enable: true });
	      }
	    },
	    disable: function disable(r) {
	      var recognizer = this.recognizers[r];
	      if (recognizer.options.enable) {
	        recognizer.set({ enable: false });
	      }
	    },
	    toggle: function toggle(r) {
	      var recognizer = this.recognizers[r];
	      if (recognizer) {
	        recognizer.options.enable
	          ? this.disable(r)
	          : this.enable(r);
	      }
	    },
	    enableAll: function enableAll(r) {
	      this.toggleAll({ enable: true });
	    },
	    disableAll: function disableAll(r) {
	      this.toggleAll({ enable: false });
	    },
	    toggleAll: function toggleAll(ref) {
	      var this$1 = this;
	      var enable = ref.enable;
	      var keys = Object.keys(this.recognizers);
	      for (var i = 0; i < keys.length; i++) {
	        var r = this$1.recognizers[keys[i]];
	        if (r.options.enable !== enable) {
	          r.set({ enable: enable });
	        }
	      }
	    },
	    isEnabled: function isEnabled(r) {
	      return this.recognizers[r] && this.recognizers[r].options.enable
	    }
	  },
	  render: function render(h) {
	    return h(this.tag, {}, this.$slots.default)
	  }
	};

	var installed = false;
	var vueTouch = { config: config, customEvents: customEvents };
	vueTouch.install = function install(Vue, opts) {
	  if ( opts === void 0 ) opts = {};
	  var name = opts.name || 'v-touch';
	  Vue.component(name, assign(Component, { name: name }));
	  installed = true;
	}.bind(vueTouch);
	vueTouch.registerCustomEvent = function registerCustomEvent(event, options) {
	  if ( options === void 0 ) options = {};
	  if (installed) {
	    console.warn(("\n      [vue-touch]: Custom Event '" + event + "' couldn't be added to vue-touch.\n      Custom Events have to be registered before installing the plugin.\n      "));
	    return
	  }
	  options.event = event;
	  customEvents[event] = options;
	  Component.props[(event + "Options")] = {
	    type: Object,
	    default: function default$1() { return {} }
	  };
	}.bind(vueTouch);
	vueTouch.component = Component;
	if (true) {
	  module.exports = vueTouch;
	} else if (typeof define == "function" && define.amd) {
	  define([], function(){ return vueTouch });
	} else if (typeof window !== 'undefined' && window.Vue) {
	  window.VueTouch = vueTouch;
	  Vue.use(vueTouch);
	}

	})));
	//# sourceMappingURL=vue-touch.js.map


/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22
	 * http://hammerjs.github.io/
	 *
	 * Copyright (c) 2016 Jorik Tangelder;
	 * Licensed under the MIT license */
	(function(window, document, exportName, undefined) {
	  'use strict';

	var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
	var TEST_ELEMENT = document.createElement('div');

	var TYPE_FUNCTION = 'function';

	var round = Math.round;
	var abs = Math.abs;
	var now = Date.now;

	/**
	 * set a timeout with a given scope
	 * @param {Function} fn
	 * @param {Number} timeout
	 * @param {Object} context
	 * @returns {number}
	 */
	function setTimeoutContext(fn, timeout, context) {
	    return setTimeout(bindFn(fn, context), timeout);
	}

	/**
	 * if the argument is an array, we want to execute the fn on each entry
	 * if it aint an array we don't want to do a thing.
	 * this is used by all the methods that accept a single and array argument.
	 * @param {*|Array} arg
	 * @param {String} fn
	 * @param {Object} [context]
	 * @returns {Boolean}
	 */
	function invokeArrayArg(arg, fn, context) {
	    if (Array.isArray(arg)) {
	        each(arg, context[fn], context);
	        return true;
	    }
	    return false;
	}

	/**
	 * walk objects and arrays
	 * @param {Object} obj
	 * @param {Function} iterator
	 * @param {Object} context
	 */
	function each(obj, iterator, context) {
	    var i;

	    if (!obj) {
	        return;
	    }

	    if (obj.forEach) {
	        obj.forEach(iterator, context);
	    } else if (obj.length !== undefined) {
	        i = 0;
	        while (i < obj.length) {
	            iterator.call(context, obj[i], i, obj);
	            i++;
	        }
	    } else {
	        for (i in obj) {
	            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
	        }
	    }
	}

	/**
	 * wrap a method with a deprecation warning and stack trace
	 * @param {Function} method
	 * @param {String} name
	 * @param {String} message
	 * @returns {Function} A new function wrapping the supplied method.
	 */
	function deprecate(method, name, message) {
	    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
	    return function() {
	        var e = new Error('get-stack-trace');
	        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
	            .replace(/^\s+at\s+/gm, '')
	            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

	        var log = window.console && (window.console.warn || window.console.log);
	        if (log) {
	            log.call(window.console, deprecationMessage, stack);
	        }
	        return method.apply(this, arguments);
	    };
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} target
	 * @param {...Object} objects_to_assign
	 * @returns {Object} target
	 */
	var assign;
	if (typeof Object.assign !== 'function') {
	    assign = function assign(target) {
	        if (target === undefined || target === null) {
	            throw new TypeError('Cannot convert undefined or null to object');
	        }

	        var output = Object(target);
	        for (var index = 1; index < arguments.length; index++) {
	            var source = arguments[index];
	            if (source !== undefined && source !== null) {
	                for (var nextKey in source) {
	                    if (source.hasOwnProperty(nextKey)) {
	                        output[nextKey] = source[nextKey];
	                    }
	                }
	            }
	        }
	        return output;
	    };
	} else {
	    assign = Object.assign;
	}

	/**
	 * extend object.
	 * means that properties in dest will be overwritten by the ones in src.
	 * @param {Object} dest
	 * @param {Object} src
	 * @param {Boolean} [merge=false]
	 * @returns {Object} dest
	 */
	var extend = deprecate(function extend(dest, src, merge) {
	    var keys = Object.keys(src);
	    var i = 0;
	    while (i < keys.length) {
	        if (!merge || (merge && dest[keys[i]] === undefined)) {
	            dest[keys[i]] = src[keys[i]];
	        }
	        i++;
	    }
	    return dest;
	}, 'extend', 'Use `assign`.');

	/**
	 * merge the values from src in the dest.
	 * means that properties that exist in dest will not be overwritten by src
	 * @param {Object} dest
	 * @param {Object} src
	 * @returns {Object} dest
	 */
	var merge = deprecate(function merge(dest, src) {
	    return extend(dest, src, true);
	}, 'merge', 'Use `assign`.');

	/**
	 * simple class inheritance
	 * @param {Function} child
	 * @param {Function} base
	 * @param {Object} [properties]
	 */
	function inherit(child, base, properties) {
	    var baseP = base.prototype,
	        childP;

	    childP = child.prototype = Object.create(baseP);
	    childP.constructor = child;
	    childP._super = baseP;

	    if (properties) {
	        assign(childP, properties);
	    }
	}

	/**
	 * simple function bind
	 * @param {Function} fn
	 * @param {Object} context
	 * @returns {Function}
	 */
	function bindFn(fn, context) {
	    return function boundFn() {
	        return fn.apply(context, arguments);
	    };
	}

	/**
	 * let a boolean value also be a function that must return a boolean
	 * this first item in args will be used as the context
	 * @param {Boolean|Function} val
	 * @param {Array} [args]
	 * @returns {Boolean}
	 */
	function boolOrFn(val, args) {
	    if (typeof val == TYPE_FUNCTION) {
	        return val.apply(args ? args[0] || undefined : undefined, args);
	    }
	    return val;
	}

	/**
	 * use the val2 when val1 is undefined
	 * @param {*} val1
	 * @param {*} val2
	 * @returns {*}
	 */
	function ifUndefined(val1, val2) {
	    return (val1 === undefined) ? val2 : val1;
	}

	/**
	 * addEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function addEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.addEventListener(type, handler, false);
	    });
	}

	/**
	 * removeEventListener with multiple events at once
	 * @param {EventTarget} target
	 * @param {String} types
	 * @param {Function} handler
	 */
	function removeEventListeners(target, types, handler) {
	    each(splitStr(types), function(type) {
	        target.removeEventListener(type, handler, false);
	    });
	}

	/**
	 * find if a node is in the given parent
	 * @method hasParent
	 * @param {HTMLElement} node
	 * @param {HTMLElement} parent
	 * @return {Boolean} found
	 */
	function hasParent(node, parent) {
	    while (node) {
	        if (node == parent) {
	            return true;
	        }
	        node = node.parentNode;
	    }
	    return false;
	}

	/**
	 * small indexOf wrapper
	 * @param {String} str
	 * @param {String} find
	 * @returns {Boolean} found
	 */
	function inStr(str, find) {
	    return str.indexOf(find) > -1;
	}

	/**
	 * split string on whitespace
	 * @param {String} str
	 * @returns {Array} words
	 */
	function splitStr(str) {
	    return str.trim().split(/\s+/g);
	}

	/**
	 * find if a array contains the object using indexOf or a simple polyFill
	 * @param {Array} src
	 * @param {String} find
	 * @param {String} [findByKey]
	 * @return {Boolean|Number} false when not found, or the index
	 */
	function inArray(src, find, findByKey) {
	    if (src.indexOf && !findByKey) {
	        return src.indexOf(find);
	    } else {
	        var i = 0;
	        while (i < src.length) {
	            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
	                return i;
	            }
	            i++;
	        }
	        return -1;
	    }
	}

	/**
	 * convert array-like objects to real arrays
	 * @param {Object} obj
	 * @returns {Array}
	 */
	function toArray(obj) {
	    return Array.prototype.slice.call(obj, 0);
	}

	/**
	 * unique array with objects based on a key (like 'id') or just by the array's value
	 * @param {Array} src [{id:1},{id:2},{id:1}]
	 * @param {String} [key]
	 * @param {Boolean} [sort=False]
	 * @returns {Array} [{id:1},{id:2}]
	 */
	function uniqueArray(src, key, sort) {
	    var results = [];
	    var values = [];
	    var i = 0;

	    while (i < src.length) {
	        var val = key ? src[i][key] : src[i];
	        if (inArray(values, val) < 0) {
	            results.push(src[i]);
	        }
	        values[i] = val;
	        i++;
	    }

	    if (sort) {
	        if (!key) {
	            results = results.sort();
	        } else {
	            results = results.sort(function sortUniqueArray(a, b) {
	                return a[key] > b[key];
	            });
	        }
	    }

	    return results;
	}

	/**
	 * get the prefixed property
	 * @param {Object} obj
	 * @param {String} property
	 * @returns {String|Undefined} prefixed
	 */
	function prefixed(obj, property) {
	    var prefix, prop;
	    var camelProp = property[0].toUpperCase() + property.slice(1);

	    var i = 0;
	    while (i < VENDOR_PREFIXES.length) {
	        prefix = VENDOR_PREFIXES[i];
	        prop = (prefix) ? prefix + camelProp : property;

	        if (prop in obj) {
	            return prop;
	        }
	        i++;
	    }
	    return undefined;
	}

	/**
	 * get a unique id
	 * @returns {number} uniqueId
	 */
	var _uniqueId = 1;
	function uniqueId() {
	    return _uniqueId++;
	}

	/**
	 * get the window object of an element
	 * @param {HTMLElement} element
	 * @returns {DocumentView|Window}
	 */
	function getWindowForElement(element) {
	    var doc = element.ownerDocument || element;
	    return (doc.defaultView || doc.parentWindow || window);
	}

	var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

	var SUPPORT_TOUCH = ('ontouchstart' in window);
	var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
	var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

	var INPUT_TYPE_TOUCH = 'touch';
	var INPUT_TYPE_PEN = 'pen';
	var INPUT_TYPE_MOUSE = 'mouse';
	var INPUT_TYPE_KINECT = 'kinect';

	var COMPUTE_INTERVAL = 25;

	var INPUT_START = 1;
	var INPUT_MOVE = 2;
	var INPUT_END = 4;
	var INPUT_CANCEL = 8;

	var DIRECTION_NONE = 1;
	var DIRECTION_LEFT = 2;
	var DIRECTION_RIGHT = 4;
	var DIRECTION_UP = 8;
	var DIRECTION_DOWN = 16;

	var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
	var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
	var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

	var PROPS_XY = ['x', 'y'];
	var PROPS_CLIENT_XY = ['clientX', 'clientY'];

	/**
	 * create new input type manager
	 * @param {Manager} manager
	 * @param {Function} callback
	 * @returns {Input}
	 * @constructor
	 */
	function Input(manager, callback) {
	    var self = this;
	    this.manager = manager;
	    this.callback = callback;
	    this.element = manager.element;
	    this.target = manager.options.inputTarget;

	    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
	    // so when disabled the input events are completely bypassed.
	    this.domHandler = function(ev) {
	        if (boolOrFn(manager.options.enable, [manager])) {
	            self.handler(ev);
	        }
	    };

	    this.init();

	}

	Input.prototype = {
	    /**
	     * should handle the inputEvent data and trigger the callback
	     * @virtual
	     */
	    handler: function() { },

	    /**
	     * bind the events
	     */
	    init: function() {
	        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    },

	    /**
	     * unbind the events
	     */
	    destroy: function() {
	        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
	        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
	        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
	    }
	};

	/**
	 * create new input type manager
	 * called by the Manager constructor
	 * @param {Hammer} manager
	 * @returns {Input}
	 */
	function createInputInstance(manager) {
	    var Type;
	    var inputClass = manager.options.inputClass;

	    if (inputClass) {
	        Type = inputClass;
	    } else if (SUPPORT_POINTER_EVENTS) {
	        Type = PointerEventInput;
	    } else if (SUPPORT_ONLY_TOUCH) {
	        Type = TouchInput;
	    } else if (!SUPPORT_TOUCH) {
	        Type = MouseInput;
	    } else {
	        Type = TouchMouseInput;
	    }
	    return new (Type)(manager, inputHandler);
	}

	/**
	 * handle input events
	 * @param {Manager} manager
	 * @param {String} eventType
	 * @param {Object} input
	 */
	function inputHandler(manager, eventType, input) {
	    var pointersLen = input.pointers.length;
	    var changedPointersLen = input.changedPointers.length;
	    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
	    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

	    input.isFirst = !!isFirst;
	    input.isFinal = !!isFinal;

	    if (isFirst) {
	        manager.session = {};
	    }

	    // source event is the normalized value of the domEvents
	    // like 'touchstart, mouseup, pointerdown'
	    input.eventType = eventType;

	    // compute scale, rotation etc
	    computeInputData(manager, input);

	    // emit secret event
	    manager.emit('hammer.input', input);

	    manager.recognize(input);
	    manager.session.prevInput = input;
	}

	/**
	 * extend the data with some usable properties like scale, rotate, velocity etc
	 * @param {Object} manager
	 * @param {Object} input
	 */
	function computeInputData(manager, input) {
	    var session = manager.session;
	    var pointers = input.pointers;
	    var pointersLength = pointers.length;

	    // store the first input to calculate the distance and direction
	    if (!session.firstInput) {
	        session.firstInput = simpleCloneInputData(input);
	    }

	    // to compute scale and rotation we need to store the multiple touches
	    if (pointersLength > 1 && !session.firstMultiple) {
	        session.firstMultiple = simpleCloneInputData(input);
	    } else if (pointersLength === 1) {
	        session.firstMultiple = false;
	    }

	    var firstInput = session.firstInput;
	    var firstMultiple = session.firstMultiple;
	    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

	    var center = input.center = getCenter(pointers);
	    input.timeStamp = now();
	    input.deltaTime = input.timeStamp - firstInput.timeStamp;

	    input.angle = getAngle(offsetCenter, center);
	    input.distance = getDistance(offsetCenter, center);

	    computeDeltaXY(session, input);
	    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

	    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
	    input.overallVelocityX = overallVelocity.x;
	    input.overallVelocityY = overallVelocity.y;
	    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

	    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
	    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

	    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
	        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

	    computeIntervalInputData(session, input);

	    // find the correct target
	    var target = manager.element;
	    if (hasParent(input.srcEvent.target, target)) {
	        target = input.srcEvent.target;
	    }
	    input.target = target;
	}

	function computeDeltaXY(session, input) {
	    var center = input.center;
	    var offset = session.offsetDelta || {};
	    var prevDelta = session.prevDelta || {};
	    var prevInput = session.prevInput || {};

	    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
	        prevDelta = session.prevDelta = {
	            x: prevInput.deltaX || 0,
	            y: prevInput.deltaY || 0
	        };

	        offset = session.offsetDelta = {
	            x: center.x,
	            y: center.y
	        };
	    }

	    input.deltaX = prevDelta.x + (center.x - offset.x);
	    input.deltaY = prevDelta.y + (center.y - offset.y);
	}

	/**
	 * velocity is calculated every x ms
	 * @param {Object} session
	 * @param {Object} input
	 */
	function computeIntervalInputData(session, input) {
	    var last = session.lastInterval || input,
	        deltaTime = input.timeStamp - last.timeStamp,
	        velocity, velocityX, velocityY, direction;

	    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
	        var deltaX = input.deltaX - last.deltaX;
	        var deltaY = input.deltaY - last.deltaY;

	        var v = getVelocity(deltaTime, deltaX, deltaY);
	        velocityX = v.x;
	        velocityY = v.y;
	        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
	        direction = getDirection(deltaX, deltaY);

	        session.lastInterval = input;
	    } else {
	        // use latest velocity info if it doesn't overtake a minimum period
	        velocity = last.velocity;
	        velocityX = last.velocityX;
	        velocityY = last.velocityY;
	        direction = last.direction;
	    }

	    input.velocity = velocity;
	    input.velocityX = velocityX;
	    input.velocityY = velocityY;
	    input.direction = direction;
	}

	/**
	 * create a simple clone from the input used for storage of firstInput and firstMultiple
	 * @param {Object} input
	 * @returns {Object} clonedInputData
	 */
	function simpleCloneInputData(input) {
	    // make a simple copy of the pointers because we will get a reference if we don't
	    // we only need clientXY for the calculations
	    var pointers = [];
	    var i = 0;
	    while (i < input.pointers.length) {
	        pointers[i] = {
	            clientX: round(input.pointers[i].clientX),
	            clientY: round(input.pointers[i].clientY)
	        };
	        i++;
	    }

	    return {
	        timeStamp: now(),
	        pointers: pointers,
	        center: getCenter(pointers),
	        deltaX: input.deltaX,
	        deltaY: input.deltaY
	    };
	}

	/**
	 * get the center of all the pointers
	 * @param {Array} pointers
	 * @return {Object} center contains `x` and `y` properties
	 */
	function getCenter(pointers) {
	    var pointersLength = pointers.length;

	    // no need to loop when only one touch
	    if (pointersLength === 1) {
	        return {
	            x: round(pointers[0].clientX),
	            y: round(pointers[0].clientY)
	        };
	    }

	    var x = 0, y = 0, i = 0;
	    while (i < pointersLength) {
	        x += pointers[i].clientX;
	        y += pointers[i].clientY;
	        i++;
	    }

	    return {
	        x: round(x / pointersLength),
	        y: round(y / pointersLength)
	    };
	}

	/**
	 * calculate the velocity between two points. unit is in px per ms.
	 * @param {Number} deltaTime
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Object} velocity `x` and `y`
	 */
	function getVelocity(deltaTime, x, y) {
	    return {
	        x: x / deltaTime || 0,
	        y: y / deltaTime || 0
	    };
	}

	/**
	 * get the direction between two points
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Number} direction
	 */
	function getDirection(x, y) {
	    if (x === y) {
	        return DIRECTION_NONE;
	    }

	    if (abs(x) >= abs(y)) {
	        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
	    }
	    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
	}

	/**
	 * calculate the absolute distance between two points
	 * @param {Object} p1 {x, y}
	 * @param {Object} p2 {x, y}
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} distance
	 */
	function getDistance(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];

	    return Math.sqrt((x * x) + (y * y));
	}

	/**
	 * calculate the angle between two coordinates
	 * @param {Object} p1
	 * @param {Object} p2
	 * @param {Array} [props] containing x and y keys
	 * @return {Number} angle
	 */
	function getAngle(p1, p2, props) {
	    if (!props) {
	        props = PROPS_XY;
	    }
	    var x = p2[props[0]] - p1[props[0]],
	        y = p2[props[1]] - p1[props[1]];
	    return Math.atan2(y, x) * 180 / Math.PI;
	}

	/**
	 * calculate the rotation degrees between two pointersets
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} rotation
	 */
	function getRotation(start, end) {
	    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
	}

	/**
	 * calculate the scale factor between two pointersets
	 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
	 * @param {Array} start array of pointers
	 * @param {Array} end array of pointers
	 * @return {Number} scale
	 */
	function getScale(start, end) {
	    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
	}

	var MOUSE_INPUT_MAP = {
	    mousedown: INPUT_START,
	    mousemove: INPUT_MOVE,
	    mouseup: INPUT_END
	};

	var MOUSE_ELEMENT_EVENTS = 'mousedown';
	var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

	/**
	 * Mouse events input
	 * @constructor
	 * @extends Input
	 */
	function MouseInput() {
	    this.evEl = MOUSE_ELEMENT_EVENTS;
	    this.evWin = MOUSE_WINDOW_EVENTS;

	    this.pressed = false; // mousedown state

	    Input.apply(this, arguments);
	}

	inherit(MouseInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function MEhandler(ev) {
	        var eventType = MOUSE_INPUT_MAP[ev.type];

	        // on start we want to have the left mouse button down
	        if (eventType & INPUT_START && ev.button === 0) {
	            this.pressed = true;
	        }

	        if (eventType & INPUT_MOVE && ev.which !== 1) {
	            eventType = INPUT_END;
	        }

	        // mouse must be down
	        if (!this.pressed) {
	            return;
	        }

	        if (eventType & INPUT_END) {
	            this.pressed = false;
	        }

	        this.callback(this.manager, eventType, {
	            pointers: [ev],
	            changedPointers: [ev],
	            pointerType: INPUT_TYPE_MOUSE,
	            srcEvent: ev
	        });
	    }
	});

	var POINTER_INPUT_MAP = {
	    pointerdown: INPUT_START,
	    pointermove: INPUT_MOVE,
	    pointerup: INPUT_END,
	    pointercancel: INPUT_CANCEL,
	    pointerout: INPUT_CANCEL
	};

	// in IE10 the pointer types is defined as an enum
	var IE10_POINTER_TYPE_ENUM = {
	    2: INPUT_TYPE_TOUCH,
	    3: INPUT_TYPE_PEN,
	    4: INPUT_TYPE_MOUSE,
	    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
	};

	var POINTER_ELEMENT_EVENTS = 'pointerdown';
	var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

	// IE10 has prefixed support, and case-sensitive
	if (window.MSPointerEvent && !window.PointerEvent) {
	    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
	    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
	}

	/**
	 * Pointer events input
	 * @constructor
	 * @extends Input
	 */
	function PointerEventInput() {
	    this.evEl = POINTER_ELEMENT_EVENTS;
	    this.evWin = POINTER_WINDOW_EVENTS;

	    Input.apply(this, arguments);

	    this.store = (this.manager.session.pointerEvents = []);
	}

	inherit(PointerEventInput, Input, {
	    /**
	     * handle mouse events
	     * @param {Object} ev
	     */
	    handler: function PEhandler(ev) {
	        var store = this.store;
	        var removePointer = false;

	        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
	        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
	        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

	        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

	        // get index of the event in the store
	        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

	        // start and mouse must be down
	        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
	            if (storeIndex < 0) {
	                store.push(ev);
	                storeIndex = store.length - 1;
	            }
	        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	            removePointer = true;
	        }

	        // it not found, so the pointer hasn't been down (so it's probably a hover)
	        if (storeIndex < 0) {
	            return;
	        }

	        // update the event in the store
	        store[storeIndex] = ev;

	        this.callback(this.manager, eventType, {
	            pointers: store,
	            changedPointers: [ev],
	            pointerType: pointerType,
	            srcEvent: ev
	        });

	        if (removePointer) {
	            // remove from the store
	            store.splice(storeIndex, 1);
	        }
	    }
	});

	var SINGLE_TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
	var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Touch events input
	 * @constructor
	 * @extends Input
	 */
	function SingleTouchInput() {
	    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
	    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
	    this.started = false;

	    Input.apply(this, arguments);
	}

	inherit(SingleTouchInput, Input, {
	    handler: function TEhandler(ev) {
	        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

	        // should we handle the touch events?
	        if (type === INPUT_START) {
	            this.started = true;
	        }

	        if (!this.started) {
	            return;
	        }

	        var touches = normalizeSingleTouches.call(this, ev, type);

	        // when done, reset the started state
	        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
	            this.started = false;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function normalizeSingleTouches(ev, type) {
	    var all = toArray(ev.touches);
	    var changed = toArray(ev.changedTouches);

	    if (type & (INPUT_END | INPUT_CANCEL)) {
	        all = uniqueArray(all.concat(changed), 'identifier', true);
	    }

	    return [all, changed];
	}

	var TOUCH_INPUT_MAP = {
	    touchstart: INPUT_START,
	    touchmove: INPUT_MOVE,
	    touchend: INPUT_END,
	    touchcancel: INPUT_CANCEL
	};

	var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

	/**
	 * Multi-user touch events input
	 * @constructor
	 * @extends Input
	 */
	function TouchInput() {
	    this.evTarget = TOUCH_TARGET_EVENTS;
	    this.targetIds = {};

	    Input.apply(this, arguments);
	}

	inherit(TouchInput, Input, {
	    handler: function MTEhandler(ev) {
	        var type = TOUCH_INPUT_MAP[ev.type];
	        var touches = getTouches.call(this, ev, type);
	        if (!touches) {
	            return;
	        }

	        this.callback(this.manager, type, {
	            pointers: touches[0],
	            changedPointers: touches[1],
	            pointerType: INPUT_TYPE_TOUCH,
	            srcEvent: ev
	        });
	    }
	});

	/**
	 * @this {TouchInput}
	 * @param {Object} ev
	 * @param {Number} type flag
	 * @returns {undefined|Array} [all, changed]
	 */
	function getTouches(ev, type) {
	    var allTouches = toArray(ev.touches);
	    var targetIds = this.targetIds;

	    // when there is only one touch, the process can be simplified
	    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
	        targetIds[allTouches[0].identifier] = true;
	        return [allTouches, allTouches];
	    }

	    var i,
	        targetTouches,
	        changedTouches = toArray(ev.changedTouches),
	        changedTargetTouches = [],
	        target = this.target;

	    // get target touches from touches
	    targetTouches = allTouches.filter(function(touch) {
	        return hasParent(touch.target, target);
	    });

	    // collect touches
	    if (type === INPUT_START) {
	        i = 0;
	        while (i < targetTouches.length) {
	            targetIds[targetTouches[i].identifier] = true;
	            i++;
	        }
	    }

	    // filter changed touches to only contain touches that exist in the collected target ids
	    i = 0;
	    while (i < changedTouches.length) {
	        if (targetIds[changedTouches[i].identifier]) {
	            changedTargetTouches.push(changedTouches[i]);
	        }

	        // cleanup removed touches
	        if (type & (INPUT_END | INPUT_CANCEL)) {
	            delete targetIds[changedTouches[i].identifier];
	        }
	        i++;
	    }

	    if (!changedTargetTouches.length) {
	        return;
	    }

	    return [
	        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
	        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
	        changedTargetTouches
	    ];
	}

	/**
	 * Combined touch and mouse input
	 *
	 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
	 * This because touch devices also emit mouse events while doing a touch.
	 *
	 * @constructor
	 * @extends Input
	 */

	var DEDUP_TIMEOUT = 2500;
	var DEDUP_DISTANCE = 25;

	function TouchMouseInput() {
	    Input.apply(this, arguments);

	    var handler = bindFn(this.handler, this);
	    this.touch = new TouchInput(this.manager, handler);
	    this.mouse = new MouseInput(this.manager, handler);

	    this.primaryTouch = null;
	    this.lastTouches = [];
	}

	inherit(TouchMouseInput, Input, {
	    /**
	     * handle mouse and touch events
	     * @param {Hammer} manager
	     * @param {String} inputEvent
	     * @param {Object} inputData
	     */
	    handler: function TMEhandler(manager, inputEvent, inputData) {
	        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
	            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

	        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
	            return;
	        }

	        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
	        if (isTouch) {
	            recordTouches.call(this, inputEvent, inputData);
	        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
	            return;
	        }

	        this.callback(manager, inputEvent, inputData);
	    },

	    /**
	     * remove the event listeners
	     */
	    destroy: function destroy() {
	        this.touch.destroy();
	        this.mouse.destroy();
	    }
	});

	function recordTouches(eventType, eventData) {
	    if (eventType & INPUT_START) {
	        this.primaryTouch = eventData.changedPointers[0].identifier;
	        setLastTouch.call(this, eventData);
	    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
	        setLastTouch.call(this, eventData);
	    }
	}

	function setLastTouch(eventData) {
	    var touch = eventData.changedPointers[0];

	    if (touch.identifier === this.primaryTouch) {
	        var lastTouch = {x: touch.clientX, y: touch.clientY};
	        this.lastTouches.push(lastTouch);
	        var lts = this.lastTouches;
	        var removeLastTouch = function() {
	            var i = lts.indexOf(lastTouch);
	            if (i > -1) {
	                lts.splice(i, 1);
	            }
	        };
	        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
	    }
	}

	function isSyntheticEvent(eventData) {
	    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
	    for (var i = 0; i < this.lastTouches.length; i++) {
	        var t = this.lastTouches[i];
	        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
	        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
	            return true;
	        }
	    }
	    return false;
	}

	var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
	var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

	// magical touchAction value
	var TOUCH_ACTION_COMPUTE = 'compute';
	var TOUCH_ACTION_AUTO = 'auto';
	var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
	var TOUCH_ACTION_NONE = 'none';
	var TOUCH_ACTION_PAN_X = 'pan-x';
	var TOUCH_ACTION_PAN_Y = 'pan-y';
	var TOUCH_ACTION_MAP = getTouchActionProps();

	/**
	 * Touch Action
	 * sets the touchAction property or uses the js alternative
	 * @param {Manager} manager
	 * @param {String} value
	 * @constructor
	 */
	function TouchAction(manager, value) {
	    this.manager = manager;
	    this.set(value);
	}

	TouchAction.prototype = {
	    /**
	     * set the touchAction value on the element or enable the polyfill
	     * @param {String} value
	     */
	    set: function(value) {
	        // find out the touch-action by the event handlers
	        if (value == TOUCH_ACTION_COMPUTE) {
	            value = this.compute();
	        }

	        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
	            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
	        }
	        this.actions = value.toLowerCase().trim();
	    },

	    /**
	     * just re-set the touchAction value
	     */
	    update: function() {
	        this.set(this.manager.options.touchAction);
	    },

	    /**
	     * compute the value for the touchAction property based on the recognizer's settings
	     * @returns {String} value
	     */
	    compute: function() {
	        var actions = [];
	        each(this.manager.recognizers, function(recognizer) {
	            if (boolOrFn(recognizer.options.enable, [recognizer])) {
	                actions = actions.concat(recognizer.getTouchAction());
	            }
	        });
	        return cleanTouchActions(actions.join(' '));
	    },

	    /**
	     * this method is called on each input cycle and provides the preventing of the browser behavior
	     * @param {Object} input
	     */
	    preventDefaults: function(input) {
	        var srcEvent = input.srcEvent;
	        var direction = input.offsetDirection;

	        // if the touch action did prevented once this session
	        if (this.manager.session.prevented) {
	            srcEvent.preventDefault();
	            return;
	        }

	        var actions = this.actions;
	        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
	        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
	        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

	        if (hasNone) {
	            //do not prevent defaults if this is a tap gesture

	            var isTapPointer = input.pointers.length === 1;
	            var isTapMovement = input.distance < 2;
	            var isTapTouchTime = input.deltaTime < 250;

	            if (isTapPointer && isTapMovement && isTapTouchTime) {
	                return;
	            }
	        }

	        if (hasPanX && hasPanY) {
	            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
	            return;
	        }

	        if (hasNone ||
	            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
	            (hasPanX && direction & DIRECTION_VERTICAL)) {
	            return this.preventSrc(srcEvent);
	        }
	    },

	    /**
	     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
	     * @param {Object} srcEvent
	     */
	    preventSrc: function(srcEvent) {
	        this.manager.session.prevented = true;
	        srcEvent.preventDefault();
	    }
	};

	/**
	 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
	 * @param {String} actions
	 * @returns {*}
	 */
	function cleanTouchActions(actions) {
	    // none
	    if (inStr(actions, TOUCH_ACTION_NONE)) {
	        return TOUCH_ACTION_NONE;
	    }

	    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
	    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

	    // if both pan-x and pan-y are set (different recognizers
	    // for different directions, e.g. horizontal pan but vertical swipe?)
	    // we need none (as otherwise with pan-x pan-y combined none of these
	    // recognizers will work, since the browser would handle all panning
	    if (hasPanX && hasPanY) {
	        return TOUCH_ACTION_NONE;
	    }

	    // pan-x OR pan-y
	    if (hasPanX || hasPanY) {
	        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
	    }

	    // manipulation
	    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
	        return TOUCH_ACTION_MANIPULATION;
	    }

	    return TOUCH_ACTION_AUTO;
	}

	function getTouchActionProps() {
	    if (!NATIVE_TOUCH_ACTION) {
	        return false;
	    }
	    var touchMap = {};
	    var cssSupports = window.CSS && window.CSS.supports;
	    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

	        // If css.supports is not supported but there is native touch-action assume it supports
	        // all values. This is the case for IE 10 and 11.
	        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
	    });
	    return touchMap;
	}

	/**
	 * Recognizer flow explained; *
	 * All recognizers have the initial state of POSSIBLE when a input session starts.
	 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
	 * Example session for mouse-input: mousedown -> mousemove -> mouseup
	 *
	 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
	 * which determines with state it should be.
	 *
	 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
	 * POSSIBLE to give it another change on the next cycle.
	 *
	 *               Possible
	 *                  |
	 *            +-----+---------------+
	 *            |                     |
	 *      +-----+-----+               |
	 *      |           |               |
	 *   Failed      Cancelled          |
	 *                          +-------+------+
	 *                          |              |
	 *                      Recognized       Began
	 *                                         |
	 *                                      Changed
	 *                                         |
	 *                                  Ended/Recognized
	 */
	var STATE_POSSIBLE = 1;
	var STATE_BEGAN = 2;
	var STATE_CHANGED = 4;
	var STATE_ENDED = 8;
	var STATE_RECOGNIZED = STATE_ENDED;
	var STATE_CANCELLED = 16;
	var STATE_FAILED = 32;

	/**
	 * Recognizer
	 * Every recognizer needs to extend from this class.
	 * @constructor
	 * @param {Object} options
	 */
	function Recognizer(options) {
	    this.options = assign({}, this.defaults, options || {});

	    this.id = uniqueId();

	    this.manager = null;

	    // default is enable true
	    this.options.enable = ifUndefined(this.options.enable, true);

	    this.state = STATE_POSSIBLE;

	    this.simultaneous = {};
	    this.requireFail = [];
	}

	Recognizer.prototype = {
	    /**
	     * @virtual
	     * @type {Object}
	     */
	    defaults: {},

	    /**
	     * set options
	     * @param {Object} options
	     * @return {Recognizer}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // also update the touchAction, in case something changed about the directions/enabled state
	        this.manager && this.manager.touchAction.update();
	        return this;
	    },

	    /**
	     * recognize simultaneous with an other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    recognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
	            return this;
	        }

	        var simultaneous = this.simultaneous;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (!simultaneous[otherRecognizer.id]) {
	            simultaneous[otherRecognizer.id] = otherRecognizer;
	            otherRecognizer.recognizeWith(this);
	        }
	        return this;
	    },

	    /**
	     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRecognizeWith: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        delete this.simultaneous[otherRecognizer.id];
	        return this;
	    },

	    /**
	     * recognizer can only run when an other is failing
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    requireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
	            return this;
	        }

	        var requireFail = this.requireFail;
	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        if (inArray(requireFail, otherRecognizer) === -1) {
	            requireFail.push(otherRecognizer);
	            otherRecognizer.requireFailure(this);
	        }
	        return this;
	    },

	    /**
	     * drop the requireFailure link. it does not remove the link on the other recognizer.
	     * @param {Recognizer} otherRecognizer
	     * @returns {Recognizer} this
	     */
	    dropRequireFailure: function(otherRecognizer) {
	        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
	            return this;
	        }

	        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
	        var index = inArray(this.requireFail, otherRecognizer);
	        if (index > -1) {
	            this.requireFail.splice(index, 1);
	        }
	        return this;
	    },

	    /**
	     * has require failures boolean
	     * @returns {boolean}
	     */
	    hasRequireFailures: function() {
	        return this.requireFail.length > 0;
	    },

	    /**
	     * if the recognizer can recognize simultaneous with an other recognizer
	     * @param {Recognizer} otherRecognizer
	     * @returns {Boolean}
	     */
	    canRecognizeWith: function(otherRecognizer) {
	        return !!this.simultaneous[otherRecognizer.id];
	    },

	    /**
	     * You should use `tryEmit` instead of `emit` directly to check
	     * that all the needed recognizers has failed before emitting.
	     * @param {Object} input
	     */
	    emit: function(input) {
	        var self = this;
	        var state = this.state;

	        function emit(event) {
	            self.manager.emit(event, input);
	        }

	        // 'panstart' and 'panmove'
	        if (state < STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }

	        emit(self.options.event); // simple 'eventName' events

	        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
	            emit(input.additionalEvent);
	        }

	        // panend and pancancel
	        if (state >= STATE_ENDED) {
	            emit(self.options.event + stateStr(state));
	        }
	    },

	    /**
	     * Check that all the require failure recognizers has failed,
	     * if true, it emits a gesture event,
	     * otherwise, setup the state to FAILED.
	     * @param {Object} input
	     */
	    tryEmit: function(input) {
	        if (this.canEmit()) {
	            return this.emit(input);
	        }
	        // it's failing anyway
	        this.state = STATE_FAILED;
	    },

	    /**
	     * can we emit?
	     * @returns {boolean}
	     */
	    canEmit: function() {
	        var i = 0;
	        while (i < this.requireFail.length) {
	            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
	                return false;
	            }
	            i++;
	        }
	        return true;
	    },

	    /**
	     * update the recognizer
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        // make a new copy of the inputData
	        // so we can change the inputData without messing up the other recognizers
	        var inputDataClone = assign({}, inputData);

	        // is is enabled and allow recognizing?
	        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
	            this.reset();
	            this.state = STATE_FAILED;
	            return;
	        }

	        // reset when we've reached the end
	        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
	            this.state = STATE_POSSIBLE;
	        }

	        this.state = this.process(inputDataClone);

	        // the recognizer has recognized a gesture
	        // so trigger an event
	        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
	            this.tryEmit(inputDataClone);
	        }
	    },

	    /**
	     * return the state of the recognizer
	     * the actual recognizing happens in this method
	     * @virtual
	     * @param {Object} inputData
	     * @returns {Const} STATE
	     */
	    process: function(inputData) { }, // jshint ignore:line

	    /**
	     * return the preferred touch-action
	     * @virtual
	     * @returns {Array}
	     */
	    getTouchAction: function() { },

	    /**
	     * called when the gesture isn't allowed to recognize
	     * like when another is being recognized or it is disabled
	     * @virtual
	     */
	    reset: function() { }
	};

	/**
	 * get a usable string, used as event postfix
	 * @param {Const} state
	 * @returns {String} state
	 */
	function stateStr(state) {
	    if (state & STATE_CANCELLED) {
	        return 'cancel';
	    } else if (state & STATE_ENDED) {
	        return 'end';
	    } else if (state & STATE_CHANGED) {
	        return 'move';
	    } else if (state & STATE_BEGAN) {
	        return 'start';
	    }
	    return '';
	}

	/**
	 * direction cons to string
	 * @param {Const} direction
	 * @returns {String}
	 */
	function directionStr(direction) {
	    if (direction == DIRECTION_DOWN) {
	        return 'down';
	    } else if (direction == DIRECTION_UP) {
	        return 'up';
	    } else if (direction == DIRECTION_LEFT) {
	        return 'left';
	    } else if (direction == DIRECTION_RIGHT) {
	        return 'right';
	    }
	    return '';
	}

	/**
	 * get a recognizer by name if it is bound to a manager
	 * @param {Recognizer|String} otherRecognizer
	 * @param {Recognizer} recognizer
	 * @returns {Recognizer}
	 */
	function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
	    var manager = recognizer.manager;
	    if (manager) {
	        return manager.get(otherRecognizer);
	    }
	    return otherRecognizer;
	}

	/**
	 * This recognizer is just used as a base for the simple attribute recognizers.
	 * @constructor
	 * @extends Recognizer
	 */
	function AttrRecognizer() {
	    Recognizer.apply(this, arguments);
	}

	inherit(AttrRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof AttrRecognizer
	     */
	    defaults: {
	        /**
	         * @type {Number}
	         * @default 1
	         */
	        pointers: 1
	    },

	    /**
	     * Used to check if it the recognizer receives valid input, like input.distance > 10.
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {Boolean} recognized
	     */
	    attrTest: function(input) {
	        var optionPointers = this.options.pointers;
	        return optionPointers === 0 || input.pointers.length === optionPointers;
	    },

	    /**
	     * Process the input and return the state for the recognizer
	     * @memberof AttrRecognizer
	     * @param {Object} input
	     * @returns {*} State
	     */
	    process: function(input) {
	        var state = this.state;
	        var eventType = input.eventType;

	        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
	        var isValid = this.attrTest(input);

	        // on cancel input and we've recognized before, return STATE_CANCELLED
	        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
	            return state | STATE_CANCELLED;
	        } else if (isRecognized || isValid) {
	            if (eventType & INPUT_END) {
	                return state | STATE_ENDED;
	            } else if (!(state & STATE_BEGAN)) {
	                return STATE_BEGAN;
	            }
	            return state | STATE_CHANGED;
	        }
	        return STATE_FAILED;
	    }
	});

	/**
	 * Pan
	 * Recognized when the pointer is down and moved in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PanRecognizer() {
	    AttrRecognizer.apply(this, arguments);

	    this.pX = null;
	    this.pY = null;
	}

	inherit(PanRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PanRecognizer
	     */
	    defaults: {
	        event: 'pan',
	        threshold: 10,
	        pointers: 1,
	        direction: DIRECTION_ALL
	    },

	    getTouchAction: function() {
	        var direction = this.options.direction;
	        var actions = [];
	        if (direction & DIRECTION_HORIZONTAL) {
	            actions.push(TOUCH_ACTION_PAN_Y);
	        }
	        if (direction & DIRECTION_VERTICAL) {
	            actions.push(TOUCH_ACTION_PAN_X);
	        }
	        return actions;
	    },

	    directionTest: function(input) {
	        var options = this.options;
	        var hasMoved = true;
	        var distance = input.distance;
	        var direction = input.direction;
	        var x = input.deltaX;
	        var y = input.deltaY;

	        // lock to axis?
	        if (!(direction & options.direction)) {
	            if (options.direction & DIRECTION_HORIZONTAL) {
	                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
	                hasMoved = x != this.pX;
	                distance = Math.abs(input.deltaX);
	            } else {
	                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
	                hasMoved = y != this.pY;
	                distance = Math.abs(input.deltaY);
	            }
	        }
	        input.direction = direction;
	        return hasMoved && distance > options.threshold && direction & options.direction;
	    },

	    attrTest: function(input) {
	        return AttrRecognizer.prototype.attrTest.call(this, input) &&
	            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
	    },

	    emit: function(input) {

	        this.pX = input.deltaX;
	        this.pY = input.deltaY;

	        var direction = directionStr(input.direction);

	        if (direction) {
	            input.additionalEvent = this.options.event + direction;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Pinch
	 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function PinchRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(PinchRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'pinch',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
	    },

	    emit: function(input) {
	        if (input.scale !== 1) {
	            var inOut = input.scale < 1 ? 'in' : 'out';
	            input.additionalEvent = this.options.event + inOut;
	        }
	        this._super.emit.call(this, input);
	    }
	});

	/**
	 * Press
	 * Recognized when the pointer is down for x ms without any movement.
	 * @constructor
	 * @extends Recognizer
	 */
	function PressRecognizer() {
	    Recognizer.apply(this, arguments);

	    this._timer = null;
	    this._input = null;
	}

	inherit(PressRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PressRecognizer
	     */
	    defaults: {
	        event: 'press',
	        pointers: 1,
	        time: 251, // minimal time of the pointer to be pressed
	        threshold: 9 // a minimal movement is ok, but keep it low
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_AUTO];
	    },

	    process: function(input) {
	        var options = this.options;
	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTime = input.deltaTime > options.time;

	        this._input = input;

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
	            this.reset();
	        } else if (input.eventType & INPUT_START) {
	            this.reset();
	            this._timer = setTimeoutContext(function() {
	                this.state = STATE_RECOGNIZED;
	                this.tryEmit();
	            }, options.time, this);
	        } else if (input.eventType & INPUT_END) {
	            return STATE_RECOGNIZED;
	        }
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function(input) {
	        if (this.state !== STATE_RECOGNIZED) {
	            return;
	        }

	        if (input && (input.eventType & INPUT_END)) {
	            this.manager.emit(this.options.event + 'up', input);
	        } else {
	            this._input.timeStamp = now();
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Rotate
	 * Recognized when two or more pointer are moving in a circular motion.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function RotateRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(RotateRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof RotateRecognizer
	     */
	    defaults: {
	        event: 'rotate',
	        threshold: 0,
	        pointers: 2
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_NONE];
	    },

	    attrTest: function(input) {
	        return this._super.attrTest.call(this, input) &&
	            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
	    }
	});

	/**
	 * Swipe
	 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
	 * @constructor
	 * @extends AttrRecognizer
	 */
	function SwipeRecognizer() {
	    AttrRecognizer.apply(this, arguments);
	}

	inherit(SwipeRecognizer, AttrRecognizer, {
	    /**
	     * @namespace
	     * @memberof SwipeRecognizer
	     */
	    defaults: {
	        event: 'swipe',
	        threshold: 10,
	        velocity: 0.3,
	        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
	        pointers: 1
	    },

	    getTouchAction: function() {
	        return PanRecognizer.prototype.getTouchAction.call(this);
	    },

	    attrTest: function(input) {
	        var direction = this.options.direction;
	        var velocity;

	        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
	            velocity = input.overallVelocity;
	        } else if (direction & DIRECTION_HORIZONTAL) {
	            velocity = input.overallVelocityX;
	        } else if (direction & DIRECTION_VERTICAL) {
	            velocity = input.overallVelocityY;
	        }

	        return this._super.attrTest.call(this, input) &&
	            direction & input.offsetDirection &&
	            input.distance > this.options.threshold &&
	            input.maxPointers == this.options.pointers &&
	            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
	    },

	    emit: function(input) {
	        var direction = directionStr(input.offsetDirection);
	        if (direction) {
	            this.manager.emit(this.options.event + direction, input);
	        }

	        this.manager.emit(this.options.event, input);
	    }
	});

	/**
	 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
	 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
	 * a single tap.
	 *
	 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
	 * multi-taps being recognized.
	 * @constructor
	 * @extends Recognizer
	 */
	function TapRecognizer() {
	    Recognizer.apply(this, arguments);

	    // previous time and center,
	    // used for tap counting
	    this.pTime = false;
	    this.pCenter = false;

	    this._timer = null;
	    this._input = null;
	    this.count = 0;
	}

	inherit(TapRecognizer, Recognizer, {
	    /**
	     * @namespace
	     * @memberof PinchRecognizer
	     */
	    defaults: {
	        event: 'tap',
	        pointers: 1,
	        taps: 1,
	        interval: 300, // max time between the multi-tap taps
	        time: 250, // max time of the pointer to be down (like finger on the screen)
	        threshold: 9, // a minimal movement is ok, but keep it low
	        posThreshold: 10 // a multi-tap can be a bit off the initial position
	    },

	    getTouchAction: function() {
	        return [TOUCH_ACTION_MANIPULATION];
	    },

	    process: function(input) {
	        var options = this.options;

	        var validPointers = input.pointers.length === options.pointers;
	        var validMovement = input.distance < options.threshold;
	        var validTouchTime = input.deltaTime < options.time;

	        this.reset();

	        if ((input.eventType & INPUT_START) && (this.count === 0)) {
	            return this.failTimeout();
	        }

	        // we only allow little movement
	        // and we've reached an end event, so a tap is possible
	        if (validMovement && validTouchTime && validPointers) {
	            if (input.eventType != INPUT_END) {
	                return this.failTimeout();
	            }

	            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
	            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

	            this.pTime = input.timeStamp;
	            this.pCenter = input.center;

	            if (!validMultiTap || !validInterval) {
	                this.count = 1;
	            } else {
	                this.count += 1;
	            }

	            this._input = input;

	            // if tap count matches we have recognized it,
	            // else it has began recognizing...
	            var tapCount = this.count % options.taps;
	            if (tapCount === 0) {
	                // no failing requirements, immediately trigger the tap event
	                // or wait as long as the multitap interval to trigger
	                if (!this.hasRequireFailures()) {
	                    return STATE_RECOGNIZED;
	                } else {
	                    this._timer = setTimeoutContext(function() {
	                        this.state = STATE_RECOGNIZED;
	                        this.tryEmit();
	                    }, options.interval, this);
	                    return STATE_BEGAN;
	                }
	            }
	        }
	        return STATE_FAILED;
	    },

	    failTimeout: function() {
	        this._timer = setTimeoutContext(function() {
	            this.state = STATE_FAILED;
	        }, this.options.interval, this);
	        return STATE_FAILED;
	    },

	    reset: function() {
	        clearTimeout(this._timer);
	    },

	    emit: function() {
	        if (this.state == STATE_RECOGNIZED) {
	            this._input.tapCount = this.count;
	            this.manager.emit(this.options.event, this._input);
	        }
	    }
	});

	/**
	 * Simple way to create a manager with a default set of recognizers.
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Hammer(element, options) {
	    options = options || {};
	    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
	    return new Manager(element, options);
	}

	/**
	 * @const {string}
	 */
	Hammer.VERSION = '2.0.7';

	/**
	 * default settings
	 * @namespace
	 */
	Hammer.defaults = {
	    /**
	     * set if DOM events are being triggered.
	     * But this is slower and unused by simple implementations, so disabled by default.
	     * @type {Boolean}
	     * @default false
	     */
	    domEvents: false,

	    /**
	     * The value for the touchAction property/fallback.
	     * When set to `compute` it will magically set the correct value based on the added recognizers.
	     * @type {String}
	     * @default compute
	     */
	    touchAction: TOUCH_ACTION_COMPUTE,

	    /**
	     * @type {Boolean}
	     * @default true
	     */
	    enable: true,

	    /**
	     * EXPERIMENTAL FEATURE -- can be removed/changed
	     * Change the parent input target element.
	     * If Null, then it is being set the to main element.
	     * @type {Null|EventTarget}
	     * @default null
	     */
	    inputTarget: null,

	    /**
	     * force an input class
	     * @type {Null|Function}
	     * @default null
	     */
	    inputClass: null,

	    /**
	     * Default recognizer setup when calling `Hammer()`
	     * When creating a new Manager these will be skipped.
	     * @type {Array}
	     */
	    preset: [
	        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
	        [RotateRecognizer, {enable: false}],
	        [PinchRecognizer, {enable: false}, ['rotate']],
	        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
	        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
	        [TapRecognizer],
	        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
	        [PressRecognizer]
	    ],

	    /**
	     * Some CSS properties can be used to improve the working of Hammer.
	     * Add them to this method and they will be set when creating a new Manager.
	     * @namespace
	     */
	    cssProps: {
	        /**
	         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userSelect: 'none',

	        /**
	         * Disable the Windows Phone grippers when pressing an element.
	         * @type {String}
	         * @default 'none'
	         */
	        touchSelect: 'none',

	        /**
	         * Disables the default callout shown when you touch and hold a touch target.
	         * On iOS, when you touch and hold a touch target such as a link, Safari displays
	         * a callout containing information about the link. This property allows you to disable that callout.
	         * @type {String}
	         * @default 'none'
	         */
	        touchCallout: 'none',

	        /**
	         * Specifies whether zooming is enabled. Used by IE10>
	         * @type {String}
	         * @default 'none'
	         */
	        contentZooming: 'none',

	        /**
	         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
	         * @type {String}
	         * @default 'none'
	         */
	        userDrag: 'none',

	        /**
	         * Overrides the highlight color shown when the user taps a link or a JavaScript
	         * clickable element in iOS. This property obeys the alpha value, if specified.
	         * @type {String}
	         * @default 'rgba(0,0,0,0)'
	         */
	        tapHighlightColor: 'rgba(0,0,0,0)'
	    }
	};

	var STOP = 1;
	var FORCED_STOP = 2;

	/**
	 * Manager
	 * @param {HTMLElement} element
	 * @param {Object} [options]
	 * @constructor
	 */
	function Manager(element, options) {
	    this.options = assign({}, Hammer.defaults, options || {});

	    this.options.inputTarget = this.options.inputTarget || element;

	    this.handlers = {};
	    this.session = {};
	    this.recognizers = [];
	    this.oldCssProps = {};

	    this.element = element;
	    this.input = createInputInstance(this);
	    this.touchAction = new TouchAction(this, this.options.touchAction);

	    toggleCssProps(this, true);

	    each(this.options.recognizers, function(item) {
	        var recognizer = this.add(new (item[0])(item[1]));
	        item[2] && recognizer.recognizeWith(item[2]);
	        item[3] && recognizer.requireFailure(item[3]);
	    }, this);
	}

	Manager.prototype = {
	    /**
	     * set options
	     * @param {Object} options
	     * @returns {Manager}
	     */
	    set: function(options) {
	        assign(this.options, options);

	        // Options that need a little more setup
	        if (options.touchAction) {
	            this.touchAction.update();
	        }
	        if (options.inputTarget) {
	            // Clean up existing event listeners and reinitialize
	            this.input.destroy();
	            this.input.target = options.inputTarget;
	            this.input.init();
	        }
	        return this;
	    },

	    /**
	     * stop recognizing for this session.
	     * This session will be discarded, when a new [input]start event is fired.
	     * When forced, the recognizer cycle is stopped immediately.
	     * @param {Boolean} [force]
	     */
	    stop: function(force) {
	        this.session.stopped = force ? FORCED_STOP : STOP;
	    },

	    /**
	     * run the recognizers!
	     * called by the inputHandler function on every movement of the pointers (touches)
	     * it walks through all the recognizers and tries to detect the gesture that is being made
	     * @param {Object} inputData
	     */
	    recognize: function(inputData) {
	        var session = this.session;
	        if (session.stopped) {
	            return;
	        }

	        // run the touch-action polyfill
	        this.touchAction.preventDefaults(inputData);

	        var recognizer;
	        var recognizers = this.recognizers;

	        // this holds the recognizer that is being recognized.
	        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
	        // if no recognizer is detecting a thing, it is set to `null`
	        var curRecognizer = session.curRecognizer;

	        // reset when the last recognizer is recognized
	        // or when we're in a new session
	        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
	            curRecognizer = session.curRecognizer = null;
	        }

	        var i = 0;
	        while (i < recognizers.length) {
	            recognizer = recognizers[i];

	            // find out if we are allowed try to recognize the input for this one.
	            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
	            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
	            //      that is being recognized.
	            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
	            //      this can be setup with the `recognizeWith()` method on the recognizer.
	            if (session.stopped !== FORCED_STOP && ( // 1
	                    !curRecognizer || recognizer == curRecognizer || // 2
	                    recognizer.canRecognizeWith(curRecognizer))) { // 3
	                recognizer.recognize(inputData);
	            } else {
	                recognizer.reset();
	            }

	            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
	            // current active recognizer. but only if we don't already have an active recognizer
	            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
	                curRecognizer = session.curRecognizer = recognizer;
	            }
	            i++;
	        }
	    },

	    /**
	     * get a recognizer by its event name.
	     * @param {Recognizer|String} recognizer
	     * @returns {Recognizer|Null}
	     */
	    get: function(recognizer) {
	        if (recognizer instanceof Recognizer) {
	            return recognizer;
	        }

	        var recognizers = this.recognizers;
	        for (var i = 0; i < recognizers.length; i++) {
	            if (recognizers[i].options.event == recognizer) {
	                return recognizers[i];
	            }
	        }
	        return null;
	    },

	    /**
	     * add a recognizer to the manager
	     * existing recognizers with the same event name will be removed
	     * @param {Recognizer} recognizer
	     * @returns {Recognizer|Manager}
	     */
	    add: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'add', this)) {
	            return this;
	        }

	        // remove existing
	        var existing = this.get(recognizer.options.event);
	        if (existing) {
	            this.remove(existing);
	        }

	        this.recognizers.push(recognizer);
	        recognizer.manager = this;

	        this.touchAction.update();
	        return recognizer;
	    },

	    /**
	     * remove a recognizer by name or instance
	     * @param {Recognizer|String} recognizer
	     * @returns {Manager}
	     */
	    remove: function(recognizer) {
	        if (invokeArrayArg(recognizer, 'remove', this)) {
	            return this;
	        }

	        recognizer = this.get(recognizer);

	        // let's make sure this recognizer exists
	        if (recognizer) {
	            var recognizers = this.recognizers;
	            var index = inArray(recognizers, recognizer);

	            if (index !== -1) {
	                recognizers.splice(index, 1);
	                this.touchAction.update();
	            }
	        }

	        return this;
	    },

	    /**
	     * bind event
	     * @param {String} events
	     * @param {Function} handler
	     * @returns {EventEmitter} this
	     */
	    on: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }
	        if (handler === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            handlers[event] = handlers[event] || [];
	            handlers[event].push(handler);
	        });
	        return this;
	    },

	    /**
	     * unbind event, leave emit blank to remove all handlers
	     * @param {String} events
	     * @param {Function} [handler]
	     * @returns {EventEmitter} this
	     */
	    off: function(events, handler) {
	        if (events === undefined) {
	            return;
	        }

	        var handlers = this.handlers;
	        each(splitStr(events), function(event) {
	            if (!handler) {
	                delete handlers[event];
	            } else {
	                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
	            }
	        });
	        return this;
	    },

	    /**
	     * emit event to the listeners
	     * @param {String} event
	     * @param {Object} data
	     */
	    emit: function(event, data) {
	        // we also want to trigger dom events
	        if (this.options.domEvents) {
	            triggerDomEvent(event, data);
	        }

	        // no handlers, so skip it all
	        var handlers = this.handlers[event] && this.handlers[event].slice();
	        if (!handlers || !handlers.length) {
	            return;
	        }

	        data.type = event;
	        data.preventDefault = function() {
	            data.srcEvent.preventDefault();
	        };

	        var i = 0;
	        while (i < handlers.length) {
	            handlers[i](data);
	            i++;
	        }
	    },

	    /**
	     * destroy the manager and unbinds all events
	     * it doesn't unbind dom events, that is the user own responsibility
	     */
	    destroy: function() {
	        this.element && toggleCssProps(this, false);

	        this.handlers = {};
	        this.session = {};
	        this.input.destroy();
	        this.element = null;
	    }
	};

	/**
	 * add/remove the css properties as defined in manager.options.cssProps
	 * @param {Manager} manager
	 * @param {Boolean} add
	 */
	function toggleCssProps(manager, add) {
	    var element = manager.element;
	    if (!element.style) {
	        return;
	    }
	    var prop;
	    each(manager.options.cssProps, function(value, name) {
	        prop = prefixed(element.style, name);
	        if (add) {
	            manager.oldCssProps[prop] = element.style[prop];
	            element.style[prop] = value;
	        } else {
	            element.style[prop] = manager.oldCssProps[prop] || '';
	        }
	    });
	    if (!add) {
	        manager.oldCssProps = {};
	    }
	}

	/**
	 * trigger dom event
	 * @param {String} event
	 * @param {Object} data
	 */
	function triggerDomEvent(event, data) {
	    var gestureEvent = document.createEvent('Event');
	    gestureEvent.initEvent(event, true, true);
	    gestureEvent.gesture = data;
	    data.target.dispatchEvent(gestureEvent);
	}

	assign(Hammer, {
	    INPUT_START: INPUT_START,
	    INPUT_MOVE: INPUT_MOVE,
	    INPUT_END: INPUT_END,
	    INPUT_CANCEL: INPUT_CANCEL,

	    STATE_POSSIBLE: STATE_POSSIBLE,
	    STATE_BEGAN: STATE_BEGAN,
	    STATE_CHANGED: STATE_CHANGED,
	    STATE_ENDED: STATE_ENDED,
	    STATE_RECOGNIZED: STATE_RECOGNIZED,
	    STATE_CANCELLED: STATE_CANCELLED,
	    STATE_FAILED: STATE_FAILED,

	    DIRECTION_NONE: DIRECTION_NONE,
	    DIRECTION_LEFT: DIRECTION_LEFT,
	    DIRECTION_RIGHT: DIRECTION_RIGHT,
	    DIRECTION_UP: DIRECTION_UP,
	    DIRECTION_DOWN: DIRECTION_DOWN,
	    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
	    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
	    DIRECTION_ALL: DIRECTION_ALL,

	    Manager: Manager,
	    Input: Input,
	    TouchAction: TouchAction,

	    TouchInput: TouchInput,
	    MouseInput: MouseInput,
	    PointerEventInput: PointerEventInput,
	    TouchMouseInput: TouchMouseInput,
	    SingleTouchInput: SingleTouchInput,

	    Recognizer: Recognizer,
	    AttrRecognizer: AttrRecognizer,
	    Tap: TapRecognizer,
	    Pan: PanRecognizer,
	    Swipe: SwipeRecognizer,
	    Pinch: PinchRecognizer,
	    Rotate: RotateRecognizer,
	    Press: PressRecognizer,

	    on: addEventListeners,
	    off: removeEventListeners,
	    each: each,
	    merge: merge,
	    extend: extend,
	    assign: assign,
	    inherit: inherit,
	    bindFn: bindFn,
	    prefixed: prefixed
	});

	// this prevents errors when Hammer is loaded in the presence of an AMD
	//  style loader but by script tag, not by the loader.
	var freeGlobal = (typeof window !== 'undefined' ? window : (typeof self !== 'undefined' ? self : {})); // jshint ignore:line
	freeGlobal.Hammer = Hammer;

	if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	        return Hammer;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (typeof module != 'undefined' && module.exports) {
	    module.exports = Hammer;
	} else {
	    window[exportName] = Hammer;
	}

	})(window, document, 'Hammer');


/***/ }),
/* 252 */
/***/ (function(module, exports) {

	'use strict';

	// var win = $(window);
	var Sticky = function Sticky(config) {

	    var el = document.querySelector(config.el),
	        marginTop = el.style.marginTop,
	        curElPos = el.style.position;

	    el.style.position = '-webkit-sticky';
	    el.style.width = '100%';
	    el.style.zIndex = 10;
	    el.style.top = 0;

	    if (el && curElPos.indexOf("sticky") == -1) {
	        var timeHandler = function timeHandler() {
	            var winScrollTop = document.body.scrollTop || document.documentElement.scrollTop;
	            var scrollTop = el.offsetTop;

	            if (winScrollTop > scrollTop) {

	                el.style.marginTop = '0';
	                el.style.position = 'fixed';
	            } else {

	                el.style.position = 'static';
	                el.style.marginTop = marginTop;
	            }
	        };

	        console.log();
	        var RAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || function (c) {
	            setTimeout(c, 1 / 60 * 1000);
	        };

	        var CAF = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;

	        window.addEventListener('scroll', function () {
	            RAF(timeHandler);
	        });
	    }
	};

	Sticky.prototype.setPlaceHolder = function () {
	    var nav = this.nav;
	    var marginTop = nav.css('margin-top'),
	        marginBottom = nav.css('margin-bottom'),
	        height = nav.height();
	    var placeHolder = $('<div style="height: ' + height + 'px;margin-top:' + marginTop + ';margin-bottom:' + marginBottom + ';display:none;"></div>');
	    nav.before(placeHolder);
	    this.placeHolder = placeHolder;
	};

	Sticky.prototype.destroySticky = function () {};

	module.exports = Sticky;

/***/ })
/******/ ]);